<!DOCTYPE html>
<html lang="zh">
<head>
    <title>校园自行车分配</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">校园自行车分配</strong>
                标签:
                
                    <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">&#34;&#34;&#34;
bucket sort solution O(MN): find the distance of all combinations, and put them into bucket based on their distance. 
In this way, the distances are represented by idx, which were sort by nature.
Since the range of distance is [0, 2000] which is much lower than the # of pairs, which is 1e6. 
It&#39;s a good time to use bucket sort. Basically, it&#39;s to put each pair into the bucket representing its distance.
Eventually, we can loop thru each bucket from lower distance.
&#34;&#34;&#34;
&#34;&#34;&#34;
Among the available bikes and workers, we choose the (worker, bike) pair with the shortest Manhattan distance between each other, and assign the bike to that worker.
&#34;&#34;&#34;
class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -&gt; List[int]:
        m, n = len(workers), len(bikes)
        # idx is distance, val is a list of (worker, bike) that have that distance   
        buckets = [[] for _ in range(2000)]   # the bucket size is the max_possible_distance 
        for w_idx, w in enumerate(workers):
            for b_idx, b in enumerate(bikes):
                dist = abs(w[0] - b[0]) + abs(w[1] - b[1])
                buckets[dist].append((w_idx, b_idx))

        res = [-1] * m
        used = set() # used bike
        for dist_lst in buckets:      # everytime, we deal with the smallest dist, by looping thru idx/dist
            for w_idx, b_idx in dist_lst:
                if res[w_idx] != -1 or b_idx in used:  # if worker is assigned or bike is assigned
                    continue
                res[w_idx] = b_idx
                used.add(b_idx)
        return res

# TC O(MN + K). Generating all the (worker, bike) pairs takes O(NM) time.
# Space complexity: O(NM + K)


# class Solution:
#     def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -&gt; List[int]:
#         heap = []
#         m, n = len(workers), len(bikes)
#         visited = set() # used bike
#         res = [-1] * m    
#         # step 1: build the distance table
#         dis = [[-1] * n for _ in range(m)]
#         for i, (w0, w1) in enumerate(workers):
#             for j, (b0, b1) in enumerate(bikes):
#                 tmp = abs(b0 - w0) + abs(b1 -w1)
#                 dis[i][j] = [tmp, j]
#         for i in range(len(dis)): # for each work, rank in the order of the closest bike. the j won&#39;t be in the original order
#             dis[i] = sorted(dis[i])

#         # the shortest dis for all workers (w/o bike limitation)
#         for i in range(m):
#             heapq.heappush(heap, (dis[i][0][0], i, 0)) 
#         count = 0
#         while heap:
#             _, i, j = heapq.heappop(heap)  
#             bike_id = dis[i][j][1]
#             if res[i] == -1 and bike_id not in visited: 
#                 res[i] = bike_id
#                 visited.add(bike_id)
#                 count += 1
#                 if count == m:
#                     return res
#             elif res[i] == -1 and bike_id in visited:
#                 if j + 1 &lt; n:
#                     heapq.heappush(heap, (dis[i][j +1][0], i, j +1))
                
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 463 ms</p>
                    <p class="mb-0">内存: 107.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解采用了桶排序的策略（bucket sort）来处理校园自行车分配问题。首先计算每个工人到每辆自行车的曼哈顿距离，并将每对(工人, 自行车)根据距离分到不同的桶中。因为最大可能距离为2000，所以桶的数量也是2000。在所有距离计算完并分桶之后，按距离从小到大的顺序（即桶的顺序）来分配自行车给工人。如果一个工人已经分配了自行车或一个自行车已经被分配，就跳过，直到所有工人都被分配自行车。</p>
                        <p>时间复杂度: O(MN)</p>
                        <p>空间复杂度: O(MN)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">&#34;&#34;&#34;
# Bucket sort solution for assigning bikes to workers based on the shortest Manhattan distance.
# This approach uses a bucket sort mechanism where each bucket corresponds to a specific distance,
# and each bucket contains list of (worker_index, bike_index) pairs with that distance.
class Solution:
    def assignBikes(self, workers: List[List[int]], bikes: List[List[int]]) -&gt; List[int]:
        m, n = len(workers), len(bikes)  # Number of workers and bikes
        # Initialize buckets for each possible distance (up to 2000)
        buckets = [[] for _ in range(2000)]
        # Populate buckets with (worker, bike) pairs based on their Manhattan distance
        for w_idx, w in enumerate(workers):
            for b_idx, b in enumerate(bikes):
                dist = abs(w[0] - b[0]) + abs(w[1] - b[1])  # Compute Manhattan distance
                buckets[dist].append((w_idx, b_idx))

        res = [-1] * m  # Result list to store the assigned bike index for each worker
        used = set()  # Set to keep track of assigned bikes
        # Process each bucket in order of increasing distance
        for dist_lst in buckets:
            for w_idx, b_idx in dist_lst:
                if res[w_idx] != -1 or b_idx in used:  # Skip if worker or bike already assigned
                    continue
                res[w_idx] = b_idx  # Assign bike to worker
                used.add(b_idx)  # Mark bike as used
        return res
&#34;&#34;&#34;
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>