<!DOCTYPE html>
<html lang="zh">
<head>
    <title>夺回据点</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">夺回据点</strong>
                标签:
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=biconnected-component" class="badge bg-secondary tag-link">双连通分量</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python"># vbcc 点双连通
class Solution:
    def minimumCost(self, c: List[int], e: List[List[int]]) -&gt; int:
        n = len(c)
        g = [[] for _ in range(n)]
        for x, y in e:
            g[x].append(y)
            g[y].append(x)
        t = 0 
        dfn = [0]*n
        low = [0]*n 
        cut = [0]*n 
        root = 0 
        vbcc = defaultdict(list)
        cnt = 0 
        stack = []
        def dfs(u, fa):
            nonlocal t 
            t += 1 
            dfn[u] = t 
            low[u] = t 
            flag = 0 
            stack.append(u)
            for v in g[u]:
                if not dfn[v]:
                    dfs(v, u)
                    low[u] = min(low[u], low[v]) 
                    if dfn[u]&lt;=low[v]:
                        flag += 1
                        if (u!=root) or (flag&gt;1):
                            cut[u] = 1 
                        nonlocal cnt 
                        vbcc[cnt].append(u)
                        while 1:
                            z = stack.pop()
                            vbcc[cnt].append(z)
                            if z==v:
                                break 
                        cnt += 1 

                else:
                    low[u] = min(low[u], dfn[v]) 
        dfs(0, -1) # dfs(0, 0)
        ans = []
        for j in vbcc:
            num = 0 
            tmp = []
            for k in vbcc[j]:
                if cut[k]==0:
                    tmp.append(c[k])
                if cut[k]:
                    num += 1 
            if num==1:
                ans.append(min(tmp)) 
        # print(ans)
        if not ans:
            return  min(c)
        if len(ans)==1:
            return ans[0]
        else:
            ans.sort()
            return sum(ans[:-1]) </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 577 ms</p>
                    <p class="mb-0">内存: 67.6 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解采用了基于深度优先搜索（DFS）的点双连通分量（Biconnected Components）的算法来解决问题。每个点双连通分量是一个最大的子图，其中任何两个顶点都有两条不相交的路径相连，这样即使去掉任何一个节点，其余节点依然连通。算法的主要步骤如下：1. 使用DFS遍历图，同时记录每个节点的访问序号dfn和最小可回溯到的祖先节点序号low。2. 利用dfn和low值，判断并记录割点（关键节点，其移除会导致图的不连通）。3. 构建每个点双连通分量，每遇到一个新的割点或遍历完一个连通分量时，将该分量的节点记录下来。4. 对每个点双连通分量，找到非割点的最小成本，以此计算最小的资源消耗。5. 特殊处理单个割点和非割点情况下的最小成本计算。整体思路是通过图的深度优先遍历确定关键节点和连通分量，然后基于每个连通分量的成本最小化总资源消耗。</p>
                        <p>时间复杂度: O(V + E)</p>
                        <p>空间复杂度: O(V + E)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python"># vbcc 点双连通
 class Solution:
 def minimumCost(self, c: List[int], e: List[List[int]]) -&gt; int:
 n = len(c) # 节点数量
 g = [[] for _ in range(n)] # 邻接表
 for x, y in e: # 构建无向图
 g[x].append(y)
 g[y].append(x)
 t = 0 # 时间戳
 dfn = [0]*n # 节点u的访问时间戳
 low = [0]*n # 节点u通过反向边能访问到的最早访问节点的时间戳
 cut = [0]*n # 标记是否为割点
 root = 0 # 根节点
 vbcc = defaultdict(list) # 存储点双连通分量
 cnt = 0 # 点双连通分量的计数
 stack = [] # 栈用于存储路径
 def dfs(u, fa): # 深度优先搜索
 nonlocal t
 t += 1
 dfn[u] = t
 low[u] = t
 flag = 0
 stack.append(u)
 for v in g[u]:
 if not dfn[v]: # 如果v未被访问过
 dfs(v, u)
 low[u] = min(low[u], low[v])
 if dfn[u]&lt;=low[v]: # 判断u是否为割点
 flag += 1
 if (u!=root) or (flag&gt;1):
 cut[u] = 1
 nonlocal cnt
 vbcc[cnt].append(u)
 while 1:
 z = stack.pop()
 vbcc[cnt].append(z)
 if z==v:
 break
 cnt += 1
 else:
 low[u] = min(low[u], dfn[v])
 dfs(0, -1) # 从节点0开始DFS
 ans = []
 for j in vbcc: # 处理每个点双连通分量
 num = 0
 tmp = []
 for k in vbcc[j]:
 if cut[k]==0: # 如果不是割点
 tmp.append(c[k])
 if cut[k]:
 num += 1
 if num==1: # 只有一个割点
 ans.append(min(tmp))
 if not ans:
 return min(c)
 if len(ans)==1:
 return ans[0]
 else:
 ans.sort()
 return sum(ans[:-1])</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>