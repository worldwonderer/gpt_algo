<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最大化一张图中的路径价值</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">最大化一张图中的路径价值</strong>
                标签:
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=backtracking" class="badge bg-secondary tag-link">回溯</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -&gt; int:
        n = len(values)
        g = [[] for _ in range(n)]
        for a, b, t in edges:
            g[a].append((b, t))
            g[b].append((a, t))
        
        disFromStart = [inf] * n
        q = [(0, 0)]
        vis = set([0])
        while q:
            d, x = heappop(q)
            if disFromStart[x] &lt; d: continue
            disFromStart[x] = d
            for y, c in g[x]:
                if disFromStart[y] &gt; (newD := d + c):
                    disFromStart[y] = newD
                    heappush(q, (newD, y))

        total = sum(values)
        q = [(0, values[0], 0, 1)]  # (node, value, cost, visited)
        ans = -inf
        while q:
            tmp, q = q, []
            for node, val, cost, vis in tmp:
                if not node and val &gt; ans:
                    ans = val
                    if ans == total: return ans
                for child, c in g[node]:
                    if (newCost := cost + c) &lt;= maxTime - disFromStart[child]:
                        newVal = val + (vis &gt;&gt; child &amp; 1 ^ 1) * values[child]
                        q.append((child, newVal, newCost, vis | (1 &lt;&lt; child)))
        return ans</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 271 ms</p>
                    <p class="mb-0">内存: 62.2 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The problem is solved using a two-stage strategy. First, Dijkstra&#39;s algorithm is used to find the shortest distance from the start node (node 0) to all other nodes. This information is essential for the second part, where we search for the highest-value path. For the second stage, we employ a breadth-first search (BFS) approach using a queue to explore all possible paths from the start node that return to the start within the allowed time, recording the maximum value achieved by these paths. The BFS iterates over all possible moves from a node, checking the cost to ensure it does not exceed maxTime minus the shortest path to the return node. A bit-mask is used to keep track of visited nodes and to avoid counting a node&#39;s value more than once.</p>
                        <p>时间复杂度: O((n + e) log n + 2^n * n * e)</p>
                        <p>空间复杂度: O(n + e + 2^n * n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maximalPathQuality(self, values: List[int], edges: List[List[int]], maxTime: int) -&gt; int:
        n = len(values)
        g = [[] for _ in range(n)]
        for a, b, t in edges:
            g[a].append((b, t))
            g[b].append((a, t))

        disFromStart = [inf] * n
        q = [(0, 0)]
        while q:
            d, x = heappop(q)
            if disFromStart[x] &lt; d: continue
            disFromStart[x] = d
            for y, c in g[x]:
                if disFromStart[y] &gt; (newD := d + c):
                    disFromStart[y] = newD
                    heappush(q, (newD, y))

        total = sum(values)
        q = [(0, values[0], 0, 1)]
        ans = -inf
        while q:
            tmp, q = q, []
            for node, val, cost, vis in tmp:
                if not node and val &gt; ans:
                    ans = val
                    if ans == total: return ans
                for child, c in g[node]:
                    if (newCost := cost + c) &lt;= maxTime - disFromStart[child]:
                        newVal = val + (vis &gt;&gt; child &amp; 1 ^ 1) * values[child]
                        q.append((child, newVal, newCost, vis | (1 &lt;&lt; child)))
        return ans
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>