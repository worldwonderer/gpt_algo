<!DOCTYPE html>
<html lang="zh">
<head>
    <title>解析布尔表达式</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">解析布尔表达式</strong>
                标签:
                
                    <a href="/problems?tag=stack" class="badge bg-secondary tag-link">栈</a>
                
                    <a href="/problems?tag=recursion" class="badge bg-secondary tag-link">递归</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from typing import List
from collections import defaultdict, deque
from itertools import accumulate
from functools import cache
import sys
import math
inf=float(&#34;inf&#34;)

class Solution:
    def log(self, *s):
        pass
    
    def parseBoolExpr(self,expr:str):
        expr=expr.replace(&#39;,&#39;,&#39;&#39;)
        # print(expr)
        def dfs(op,args:str):
            self.log(f&#39;{op}:{args}&#39;)
            l,r=0,len(args)-1
            while l&lt;=r:
                if args[l]==&#39;f&#39;:
                    tmp_result=False
                elif args[l]==&#39;t&#39;:
                    tmp_result=True
                else:
                    if op == &#39;!&#39;:
                        right_index=r-l
                    else:
                        right_index=args[l:].index(&#39;)&#39;)
                    tmp_result = dfs(args[l],args[l+2:l+right_index])
                    l+=right_index
                if op == &#39;&amp;&#39; and tmp_result==False:
                    return False
                elif op == &#39;|&#39; and tmp_result == True:
                    return True
                elif op==&#39;!&#39;:
                    return not tmp_result
                l+=1   
            return True if op==&#39;&amp;&#39; else False 
        return dfs(expr)
    def parseBoolExpr(self,expr:str):
        expr=expr.replace(&#39;,&#39;,&#39;&#39;)
        stacks=[]
        stack_values=[[]]
        for i,v in enumerate(expr):
            if v == &#39;(&#39;:
                stack_values.append([])
                stacks.append(expr[i-1])
            elif v==&#39;)&#39;:
                op=stacks.pop()
                vs=stack_values.pop()
                if op==&#39;&amp;&#39;:
                    flag=all(vs)
                elif op==&#39;|&#39;:
                    flag=any(vs)
                elif op==&#39;!&#39;:
                    flag=not vs[0]
                # self.log(op,stack_values[:],vs,flag)
                stack_values[-1].append(flag)
               
            elif v==&#39;f&#39;:
                stack_values[-1].append(False)
            elif v==&#39;t&#39;:
                stack_values[-1].append(True)
            
        return stack_values[0][0]
    
    def run(self, *args):
        return self.parseBoolExpr(*args)


class SolutionDebug(Solution):
    logs = &#34;&#34;

    def log(self, *s):
        self.logs += &#34; &#34;.join([str(v) for v in s])+&#34;
&#34;

    def run(self, *args, **kw) -&gt; int:
        self.logs = &#34;&#34;
        try:
            return super().run(*args, **kw)
        except Exception as e:
            import traceback
            traceback.print_exc()
            return None


if __name__ == &#39;__main__&#39;:
    s = SolutionDebug()
    null=None
    true=True
    false=False
    for case in [
        [&#34;|(&amp;(t,f,t),t)&#34;,True],
        [&#34;!(&amp;(!(&amp;(f)),&amp;(t),|(f,f,t)))&#34;,False],
        [&#34;!(&amp;(!(t),&amp;(f),|(f)))&#34;,true],
        [&#34;|(&amp;(t,f,t),!(t))&#34;,false],
        [&#34;&amp;(|(f))&#34;,false],
        [&#34;|(f,f,f,f,t)&#34;,true],
        [&#34;!(&amp;(f,t))&#34;,true]
    ]:
        s.logs = &#34;&#34;
        e = s.run(*case[:-1])
        if e != case[-1]:
            print(e, case)
            print(s.logs)
            break
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 42 ms</p>
                    <p class="mb-0">内存: 16.7 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>该题解使用栈的方法解析并计算布尔表达式的值。首先，将表达式中的逗号删除以简化解析过程。接着，遍历处理表达式的每个字符。遇到左括号时，初始化一个新的栈用于存储当前子表达式的值，并记录当前运算符。遇到右括号时，根据之前记录的运算符从栈中取出所有子表达式的值，进行相应的逻辑运算（AND, OR, NOT），并将结果存入上一个栈。对于 &#39;f&#39; 和 &#39;t&#39;, 直接转换为布尔值 False 或 True 并存入当前栈。最终，栈顶元素即为整个表达式的计算结果。</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from typing import List
from collections import defaultdict, deque
from itertools import accumulate
from functools import cache
import sys
import math
inf=float(\&#34;inf\&#34;)

class Solution:
    def log(self, *s):
        pass  # 日志打印函数，用于调试
    
    def parseBoolExpr(self,expr:str):
        expr=expr.replace(&#39;,&#39;,&#39;&#39;)  # 删除所有逗号以简化解析
        stacks=[]  # 运算符栈
        stack_values=[[]]  # 存储布尔值的栈
        for i,v in enumerate(expr):
            if v == &#39;(&#39;:
                stack_values.append([])  # 遇到左括号，为子表达式创建新的栈
                stacks.append(expr[i-1])  # 记录当前运算符
            elif v==&#39;)&#39;:
                op=stacks.pop()  # 取出运算符
                vs=stack_values.pop()  # 取出当前栈的所有布尔值
                if op==&#39;&amp;&#39;:
                    flag=all(vs)  # 执行AND运算
                elif op==&#39;|&#39;:
                    flag=any(vs)  # 执行OR运算
                elif op==&#39;!&#39;:
                    flag=not vs[0]  # 执行NOT运算
                stack_values[-1].append(flag)  # 将结果存入上一个栈
            elif v==&#39;f&#39;:
                stack_values[-1].append(False)  # 处理&#39;f&#39;为False
            elif v==&#39;t&#39;:
                stack_values[-1].append(True)  # 处理&#39;t&#39;为True
        return stack_values[0][0]  # 返回栈顶元素，即整个表达式的计算结果</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>