<!DOCTYPE html>
<html lang="zh">
<head>
    <title>反转表达式值的最少操作次数</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">反转表达式值的最少操作次数</strong>
                标签:
                
                    <a href="/problems?tag=stack" class="badge bg-secondary tag-link">栈</a>
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minOperationsToFlip(self, expression: str) -&gt; int:
        costs = []
        ops = []

        for ch in expression:
            if ch in &#34;|&amp;(&#34;:
                # Memorize the op
                ops.append(ch)
                continue
            
            # Add an initial cost pair if needed
            if ch == &#34;0&#34;:
                # 0 cost to turn 0; 1 cost to turn 1
                costs.append((0, 1))
            elif ch == &#34;1&#34;:
                # 1 cost to turn 0; 0 cost to turn 1
                costs.append((1, 0))
            elif ch == &#34;)&#34;:
                # Pause caused by &#39;(&#39; should end here
                assert(ops[-1] == &#34;(&#34;)
                ops.pop()
            
            # Try to use the previous op to calculate
            # If &#39;(&#39;, then skip to reserve the previous op
            if len(ops) &gt; 0 and ops[-1] != &#34;(&#34;:
                # Pop an op and two cost pairs
                op = ops.pop()
                c0_r, c1_r = costs.pop()
                c0_l, c1_l = costs.pop()

                # Calculate new cost pair using DP
                if op == &#34;&amp;&#34;:
                    cost = (
                        min(c0_l, c0_r), # No change
                        min(
                            c1_l + c1_r, # No change
                            1 + min(c1_l, c1_r) # Change op
                        )
                    )
                elif op == &#34;|&#34;:
                    cost = (
                        min(
                            c0_l + c0_r, # No change
                            1 + min(c0_l, c0_r) # Change op
                        ),
                        min(c1_l, c1_r), # No change
                    )
                costs.append(cost)
        
        # The smaller one is 0,
        # namely the final value doesn&#39;t change
        return max(costs[-1])


</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 240 ms</p>
                    <p class="mb-0">内存: 17.8 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解采用了堆栈和动态规划的方式解决问题。首先，使用两个堆栈，一个用于保存操作符（包括&#39;&amp;&#39;、&#39;|&#39;和&#39;(&#39;），另一个用于保存每个子表达式的转换成本。转换成本用一对整数表示，其中第一个整数表示将子表达式的值从0转换成1的最小操作次数，第二个整数表示从1转换成0的最小操作次数。遍历表达式字符串，根据当前字符的类型（数字、操作符或括号），更新堆栈。遇到数字时，直接将其转换成本入栈。遇到操作符时，将其入操作符栈。遇到&#39;)&#39;时，处理到对应的&#39;(&#39;之间的表达式，应用动态规划公式来计算合并后的成本，并更新成本堆栈。最后，堆栈顶的成本对就是整个表达式的转换成本，其中较大的值表示将整个表达式的值反转的最小操作次数。</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minOperationsToFlip(self, expression: str) -&gt; int:
        costs = []  # Stack to hold the cost pairs (cost to make 0, cost to make 1)
        ops = []  # Stack to hold operations and &#39;(&#39;

        for ch in expression:
            if ch in &#39;|&amp;(&#39;:  # Push operation or open parenthesis to ops stack
                ops.append(ch)
                continue

            if ch == &#39;0&#39;:
                costs.append((0, 1))  # No cost to keep 0, cost 1 to change to 1
            elif ch == &#39;1&#39;:
                costs.append((1, 0))  # Cost 1 to change to 0, no cost to keep 1

            if ch == &#39;)&#39;:  # Resolve expression inside the parenthesis
                assert(ops[-1] == &#39;(&#39;, &#39;Mismatched parentheses&#39;)
                ops.pop()

            while len(ops) &gt; 0 and ops[-1] != &#39;(&#39;:  # Apply operations to top two cost pairs
                op = ops.pop()
                c0_r, c1_r = costs.pop()  # Right operand costs
                c0_l, c1_l = costs.pop()  # Left operand costs

                if op == &#39;&amp;&#39;:
                    new_cost = (
                        min(c0_l, c0_r),  # Cost for result 0
                        min(c1_l + c1_r, 1 + min(c1_l, c1_r))  # Cost for result 1 (including operation change)
                    )
                elif op == &#39;|&#39;:
                    new_cost = (
                        min(c0_l + c0_r, 1 + min(c0_l, c0_r)),  # Cost for result 0 (including operation change)
                        min(c1_l, c1_r)  # Cost for result 1
                    )
                costs.append(new_cost)  # Push the combined costs

        return max(costs[-1])  # Max of the final costs gives minimum operations to flip the entire expression</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>