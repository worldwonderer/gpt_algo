<!DOCTYPE html>
<html lang="zh">
<head>
    <title>采集果实</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>采集果实</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Easy</span></p>
                
                    <div class="problem-description">
                        欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。

在新手村中，各位勇者需要采集一些果实来制作药剂。`time[i]` 表示勇者每次采集 `1～limit` 颗第 `i` 种类型的果实需要的时间（即每次最多可以采集 `limit` 颗果实）。

当前勇者需要完成「采集若干批果实」的任务， `fruits[j] = [type, num]` 表示第 `j` 批需要采集 `num` 颗 `type` 类型的果实。采集规则如下：
- 按 `fruits` 给定的顺序**依次**采集每一批次
- 采集完当前批次的果实才能开始采集下一批次
- 勇者完成当前批次的采集后将**清空背包**（即多余的果实将清空）

请计算并返回勇者完成采集任务最少需要的时间。


**示例 1：**
>输入：`time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3`
>
>输出：`10`
>
>解释：
>由于单次最多采集 3 颗
>第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2\*1=2
>第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3\*2=6
>第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2\*1=2
>返回总耗时 2+6+2=10

**示例 2：**
>输入：`time = [1], fruits = [[0,3],[0,5]], limit = 2`
>
>输出：`5`
>
>解释：
>由于单次最多采集 2 颗
>第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1\*2=2
>第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1\*3=3
>需按照顺序依次采集，返回 2+3=5

**提示：**
- `1 <= time.length <= 100`
- `1 <= time[i] <= 100`
- `1 <= fruits.length <= 10^3`
- `0 <= fruits[i][0] < time.length`
- `1 <= fruits[i][1] < 10^3`
- `1 <= limit <= 100`
                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 34 ms</p>
                    <p>内存: 16.4 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def getMinimumTime(self, time: List[int], fruits: List[List[int]], limit: int) -&gt; int:
        ans = 0
        for fruit, number in fruits:
            ans += ceil(number / limit) * time[fruit]
        return ans</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>The solution iterates through each batch of fruits specified in the &#39;fruits&#39; list. For each batch, it calculates the number of times the hero needs to collect fruits of that type to meet the required quantity. This is done by dividing the number of fruits needed (&#39;number&#39;) by the maximum number of fruits that can be collected in one go (&#39;limit&#39;), and taking the ceiling of the result to ensure that we account for any remaining fruits that don&#39;t make up a full &#39;limit&#39;. The time taken for each batch is then calculated by multiplying the number of times the hero needs to collect fruits by the time it takes to collect one batch of fruits of that type (&#39;time[fruit]&#39;). The total time taken (&#39;ans&#39;) is the sum of the times taken for all batches.</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2">class Solution:
    def getMinimumTime(self, time: List[int], fruits: List[List[int]], limit: int) -&gt; int:
        ans = 0  # Initialize the total time taken to 0
        for fruit, number in fruits:  # Iterate through each batch of fruits
            ans += ceil(number / limit) * time[fruit]  # Calculate and add the time taken for the current batch
        return ans  # Return the total time taken</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            如何处理当`num`不是`limit`的整数倍时的多余果实？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>当`num`（需要采集的果实数量）不是`limit`（每次可以采集的最大数量）的整数倍时，会有一些多余的果实数量无法恰好组成一个完整的`limit`批次。在这种情况下，使用向上取整的方式（ceil函数），保证即使是超出`limit`的部分也被计算为一个完整的采集周期。例如，如果`num`为10，`limit`为3，计算得到的采集次数为`ceil(10/3) = 4`次。这确保了所有果实都被采集完毕，包括最后一次可能不满`limit`的采集。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在计算需要采集的次数时，为什么需要使用向上取整的方式（ceil函数）？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>使用向上取整的方式（ceil函数）是为了确保所有的果实都能被采集完毕。例如，如果一个批次需要采集的果实数除以每次采集的限制数（limit），结果不是一个整数，表示最后一次采集不会达到完整的限制数，但这些果实仍然需要被采集。向上取整能保证即使最后一次采集果实数少于`limit`，也会被算作一次完整的采集过程，从而保障所有果实都被收集。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            给定的`time`数组在算法中如何与`fruits`数组中的果实类型相对应？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在算法中，`time`数组是一个整数列表，每个元素代表对应类型果实的采集时间。`fruits`数组是一个二维列表，其中每个子列表包含两个元素：果实的类型（fruit）和需要采集的数量（number）。`fruit`的值作为索引直接用于从`time`数组中获取对应类型果实的采集时间。例如，如果`fruits`中某个元素为`[1, 5]`，则表示类型1的果实需要采集5个，其采集时间由`time[1]`提供。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/PTXy4P')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/PTXy4P/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>