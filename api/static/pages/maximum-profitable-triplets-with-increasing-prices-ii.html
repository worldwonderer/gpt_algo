<!DOCTYPE html>
<html lang="zh">
<head>
    <title>价格递增的最大利润三元组 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">价格递增的最大利润三元组 II</strong>
                标签:
                
                    <a href="/problems?tag=binary-indexed-tree" class="badge bg-secondary tag-link">树状数组</a>
                
                    <a href="/problems?tag=segment-tree" class="badge bg-secondary tag-link">线段树</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int], profits: List[int]) -&gt; int:       
        n = len(prices)
        &#39;&#39;&#39;
        二分单调栈
        num,t
        10  8
        9   7
        保证num越大时，t越大
        &#39;&#39;&#39;
        dp = [-1] * (n)
        # 第一次二分单调栈
        up = []        
        for i in range(n):
            a,b = prices[i], profits[i]
            pos = bisect_right(up,(a,0))
            if pos:
                dp[i] = up[pos-1][1] + b
           
            if not pos: 
                while pos &lt; len(up) and up[pos][1] &lt;= b:
                    del up[pos]
                up.insert(0,(a,b))
            else:
                if up[pos-1][1] &lt; b:
                    while pos &lt; len(up) and up[pos][1] &lt;= b:
                        del up[pos]
                    up.insert(pos,(a,b))
        
        # 第二次单调栈，以dp值作为num  
        res = -1
        up = []
        for i in range(n):
            a,b = prices[i], profits[i]
            pos = bisect_right(up,(a,0))
            if pos:
                res = max(res,up[pos-1][1] + b)
            
            if dp[i] == -1:
                continue
            
            if not pos: 
                while pos &lt; len(up) and up[pos][1] &lt;= dp[i]:
                    del up[pos]
                up.insert(0,(a,dp[i]))
            else:
                if up[pos-1][1] &lt; dp[i]:
                    while pos &lt; len(up) and up[pos][1] &lt;= dp[i]:
                        del up[pos]
                    up.insert(pos,(a,dp[i]))
            
            
        # print(dp)
        
        return res </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 280 ms</p>
                    <p class="mb-0">内存: 24.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>该题解采用了二分单调栈的方法来求解价格递增的最大利润三元组问题。首先，我们使用一个单调栈来维护一个由价格和利润组成的元组列表，确保随着价格的增加，相应的利润也是单调递增的。在遍历价格和利润数组时，我们尝试通过二分查找的方式找到当前价格能插入单调栈的位置，并根据这个位置更新可能的最大利润（通过之前的利润加上当前的利润）。第二次使用单调栈时，我们将DP值作为新的利润，以此来尝试更新最终的最大利润。</p>
                        <p>时间复杂度: O(n log n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maxProfit(self, prices: List[int], profits: List[int]) -&gt; int:
        n = len(prices)
        # 初始化DP数组，用于存储中间结果
        dp = [-1] * (n)
        # 第一次构建单调栈
        up = []
        # 遍历每个元素，尝试更新DP值
        for i in range(n):
            a, b = prices[i], profits[i]
            pos = bisect_right(up, (a, 0))
            if pos:
                dp[i] = up[pos-1][1] + b
            # 维护单调栈，确保满足条件
            if not pos or up[pos-1][1] &lt; b:
                while pos &lt; len(up) and up[pos][1] &lt;= b:
                    del up[pos]
                up.insert(pos, (a, b))
        # 第二次构建单调栈，以DP值作为新的利润
        res = -1
        up = []
        for i in range(n):
            a, b = prices[i], profits[i]
            if dp[i] == -1:
                continue
            pos = bisect_right(up, (a, 0))
            if pos:
                res = max(res, up[pos-1][1] + b)
            # 维护单调栈，确保满足条件
            if not pos or up[pos-1][1] &lt; dp[i]:
                while pos &lt; len(up) and up[pos][1] &lt;= dp[i]:
                    del up[pos]
                up.insert(pos, (a, dp[i]))
        # 返回最大利润
        return res</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>