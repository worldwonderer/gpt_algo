<!DOCTYPE html>
<html lang="zh">
<head>
    <title>有效的井字游戏</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>有效的井字游戏</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=matrix" class="badge bg-secondary tag-link">矩阵</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>给你一个字符串数组 <code>board</code> 表示井字游戏的棋盘。当且仅当在井字游戏过程中，棋盘有可能达到 <code>board</code> 所显示的状态时，才返回 <code>true</code> 。</p>

<p>井字游戏的棋盘是一个 <code>3 x 3</code> 数组，由字符 <code>' '</code>，<code>'X'</code> 和 <code>'O'</code> 组成。字符 <code>' '</code> 代表一个空位。</p>

<p>以下是井字游戏的规则：</p>

<ul>
	<li>玩家轮流将字符放入空位（<code>' '</code>）中。</li>
	<li>玩家 1 总是放字符 <code>'X'</code> ，而玩家 2 总是放字符 <code>'O'</code> 。</li>
	<li><code>'X'</code> 和 <code>'O'</code> 只允许放置在空位中，不允许对已放有字符的位置进行填充。</li>
	<li>当有 3 个相同（且非空）的字符填充任何行、列或对角线时，游戏结束。</li>
	<li>当所有位置非空时，也算为游戏结束。</li>
	<li>如果游戏结束，玩家不允许再放置字符。</li>
</ul>



<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe1-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>输入：</strong>board = ["O  ","   ","   "]
<strong>输出：</strong>false
<strong>解释：</strong>玩家 1 总是放字符 "X" 。
</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe2-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>输入：</strong>board = ["XOX"," X ","   "]
<strong>输出：</strong>false
<strong>解释：</strong>玩家应该轮流放字符。
</pre>

<p><strong>示例 3:</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/05/15/tictactoe4-grid.jpg" style="width: 253px; height: 253px;" />
<pre>
<strong>输入：</strong>board = ["XOX","O O","XOX"]
<strong>输出：</strong>true
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>board.length == 3</code></li>
	<li><code>board[i].length == 3</code></li>
	<li><code>board[i][j]</code> 为 <code>'X'</code>、<code>'O'</code> 或 <code>' '</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 23 ms</p>
                    <p>内存: 16.1 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def validTicTacToe(self, board: List[str]) -&gt; bool:
        o_num = 0
        x_num = 0
        for i in range(3):
            for j in range(3):
                if board[i][j] == &#39;O&#39;:
                    o_num += 1
                if board[i][j] == &#39;X&#39;:
                    x_num += 1
                pass
        x_win_num = 0
        o_win_num = 0
        for i in range(3):
            if board[i][0] == board[i][1] and board[i][1] == board[i][2]:
                if board[i][0] == &#39;X&#39;:
                    x_win_num += 1
                elif board[i][0] == &#39;O&#39;:
                    o_win_num += 1
            elif board[0][i] == board[1][i] and board[1][i] == board[2][i]:
                if board[0][i] == &#39;X&#39;:
                    x_win_num += 1
                elif board[0][i] == &#39;O&#39;:
                    o_win_num += 1
                pass
        
        
        print(x_win_num,o_win_num)
        if board[0][0] == board[1][1] and board[1][1] == board[2][2]:
            if board[0][0] == &#39;X&#39;:
                x_win_num += 1
            elif board[0][0] == &#39;O&#39;:
                o_win_num += 1
        
        if board[0][2] == board[1][1] and board[1][1] == board[2][0]:
            if board[2][0] == &#39;X&#39;:
                x_win_num += 1
            elif board[2][0] == &#39;O&#39;:
                o_win_num += 1
           
            

        
        if o_num &gt; x_num or x_num &gt; o_num + 1:
            return False
        elif x_win_num &gt; 0 and o_win_num &gt; 0:
            return False
        elif x_win_num &gt; 0 and x_num &lt; o_num + 1:
            return False
        elif o_win_num &gt; 0 and x_num &gt; o_num:
            return False
        else:
            return True
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>这个题解的思路是先统计棋盘上 &#39;X&#39; 和 &#39;O&#39; 的个数，然后再统计 &#39;X&#39; 和 &#39;O&#39; 各自形成连线获胜的次数。最后根据题目规则判断棋盘状态是否合法。具体判断标准为：1. &#39;O&#39; 的个数不能大于 &#39;X&#39; 的个数，且 &#39;X&#39; 的个数最多比 &#39;O&#39; 多1个；2. &#39;X&#39; 和 &#39;O&#39; 不能同时形成连线获胜；3. 如果 &#39;X&#39; 形成连线获胜，则此时 &#39;X&#39; 的个数必须恰好比 &#39;O&#39; 多1个；4. 如果 &#39;O&#39; 形成连线获胜，则此时 &#39;X&#39; 和 &#39;O&#39; 的个数必须相等。只有同时满足以上条件，才是一个合法的棋盘状态。</p>
                                <p>时间复杂度: O(1)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2">class Solution:
    def validTicTacToe(self, board: List[str]) -&gt; bool:
        # 统计棋盘上 &#39;O&#39; 的个数
        o_num = 0
        # 统计棋盘上 &#39;X&#39; 的个数 
        x_num = 0
        # 双重循环遍历棋盘
        for i in range(3):
            for j in range(3):
                if board[i][j] == &#39;O&#39;:
                    o_num += 1
                if board[i][j] == &#39;X&#39;:
                    x_num += 1
                
        # 统计 &#39;X&#39; 形成连线获胜的次数
        x_win_num = 0
        # 统计 &#39;O&#39; 形成连线获胜的次数
        o_win_num = 0
        # 检查每一行
        for i in range(3):
            if board[i][0] == board[i][1] and board[i][1] == board[i][2]:
                if board[i][0] == &#39;X&#39;:
                    x_win_num += 1
                elif board[i][0] == &#39;O&#39;:
                    o_win_num += 1
            # 检查每一列
            elif board[0][i] == board[1][i] and board[1][i] == board[2][i]:
                if board[0][i] == &#39;X&#39;:
                    x_win_num += 1
                elif board[0][i] == &#39;O&#39;:
                    o_win_num += 1
                
        # 检查正对角线
        if board[0][0] == board[1][1] and board[1][1] == board[2][2]:
            if board[0][0] == &#39;X&#39;:
                x_win_num += 1
            elif board[0][0] == &#39;O&#39;:
                o_win_num += 1
        
        # 检查反对角线
        if board[0][2] == board[1][1] and board[1][1] == board[2][0]:
            if board[2][0] == &#39;X&#39;:
                x_win_num += 1
            elif board[2][0] == &#39;O&#39;:
                o_win_num += 1
        
        # 判断棋盘状态是否合法
        if o_num &gt; x_num or x_num &gt; o_num + 1:
            return False
        elif x_win_num &gt; 0 and o_win_num &gt; 0:
            return False
        elif x_win_num &gt; 0 and x_num &lt;= o_num:
            return False
        elif o_win_num &gt; 0 and x_num &gt; o_num:
            return False
        else:
            return True
</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            代码中如何确保在统计&#39;X&#39;和&#39;O&#39;的胜利次数时，不会重复计算例如某行和某列同时包含的胜利情况？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在代码中，每行和每列的胜利情况是分开检查的，而且对于每行每列的检查都是独立的。这意味着，即使某一行或某一列出现胜利情况，它们各自的胜利都会被独立计算，不会互相影响。但实际上，代码中并没有机制来防止对角线胜利和行或列胜利重复计数，所以如果一个行或列同时也是对角线的一部分并且形成了胜利，那么胜利次数会被重复计算。因此，代码需要进一步优化以防止这种重复计数。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在代码中，为什么在检查每一列的连线胜利时，使用了elif而不是if？这样会不会漏掉某些情况？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在代码中使用elif而不是if来检查列的胜利情况是一个错误，因为这样排除了某一行和某一列可能同时获胜的情况。如果某一行和某一列在同一轮循环中都符合获胜条件，使用elif就会导致该列的胜利情况被忽略，只计算行的胜利。这是一个潜在的bug，应该将elif改为if以确保行和列的胜利都能被正确统计。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            给定代码中，如果&#39;X&#39;或&#39;O&#39;在对角线上获胜，但同时在行或列中也形成了连线，这会如何影响胜利次数的统计？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果&#39;X&#39;或&#39;O&#39;在对角线上获胜，同时在行或列中也形成了连线，这将导致胜利次数被重复计算。例如，如果一个&#39;X&#39;在第一行和主对角线上同时形成了连线，这将使&#39;X&#39;的胜利次数增加两次。这种情况在代码中没有被特别处理，因此可能导致对游戏状态的错误判断。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            为什么当&#39;X&#39;的胜利次数大于0时，需要&#39;X&#39;的数量恰好比&#39;O&#39;多1个，而&#39;O&#39;胜利时，&#39;X&#39;和&#39;O&#39;的数量必须相等？这背后的逻辑是什么？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>这个规则反映了井字游戏的基本规则：玩家轮流放置&#39;X&#39;和&#39;O&#39;。游戏开始时，&#39;X&#39;先行，因此每当&#39;X&#39;获胜时，由于&#39;X&#39;总是先行，&#39;X&#39;的数量必须比&#39;O&#39;多1。相对地，如果&#39;O&#39;获胜，因为&#39;O&#39;是第二个行动，此时&#39;X&#39;和&#39;O&#39;的数量必须相等，说明&#39;O&#39;在其最后一次行动中获胜，而在此之前&#39;X&#39;和&#39;O&#39;的数量是平衡的。这些规则确保了游戏的正常轮换和公平性。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
                <aside class="related-problems-section">
                    <h2>Related Problems</h2>
                    <div class="list-group">
                        
                            <a href="/problem/design-tic-tac-toe" class="list-group-item list-group-item-action">
                                设计井字棋
                            </a>
                        
                    </div>
                </aside>
            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/valid-tic-tac-toe-state')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/valid-tic-tac-toe-state/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>