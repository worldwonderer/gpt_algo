<!DOCTYPE html>
<html lang="zh">
<head>
    <title>K 个不相交子数组的最大能量值</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">K 个不相交子数组的最大能量值</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                    <a href="/problems?tag=prefix-sum" class="badge bg-secondary tag-link">前缀和</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python"># https://leetcode.cn/u/l00/

class Solution:
    def maximumStrength(self, nums: List[int], k: int) -&gt; int:
        n = len(nums)
        acc = [0]
        for num in nums:
            acc.append(acc[-1] + num)
        dps = [0] * (n + 1)
        for ck in range(k):
            cw = k - ck
            if ck &amp; 1: cw = -cw
            # cw = (-1 if ck &amp; 1 else 1) * (k - ck)
            lastDps = dps[ck]
            dps[ck] = curs = -inf
            # bestDps = -inf
            for i in range(ck, n - k + ck + 1):
                t = lastDps - acc[i] * cw
                if curs &lt; t: curs = t
                lastDps = dps[i + 1]
                # if bestDps &lt; curs + acc[i + 1] * cw: bestDps = curs + acc[i + 1] * cw
                # dps[i + 1] = bestDps
                t = curs + acc[i + 1] * cw
                dps[i + 1] = t if dps[i] &lt; t else dps[i]
        return dps[-1]

# class Solution:
#     def maximumStrength(self, nums: List[int], k: int) -&gt; int:
#         n = len(nums)
#         acc = 0 
#         dps = [-inf] * k
#         res = [-inf] * k
#         cws = [(k - ck) * (((ck &amp; 1 ^ 1) &lt;&lt; 1) -1)  for ck in range(k)]
#         for i in range(n):
#             preAcc = acc
#             acc += nums[i]
#             preRes = 0
#             bestDps = dps[0]
#             bestRes = res[0]
#             for ck in range(min(i+1, k)): # for ck in range(k):
#                 cw = cws[ck]
#                 # if preRes - preAcc * cw &gt; bestDps: bestDps = preRes - preAcc * cw
#                 # dps[ck] = bestDps
#                 dps[ck] = max(dps[ck], preRes - preAcc * cw)
#                 preRes = res[ck]
#                 if dps[ck] + acc * cw &gt; bestRes: bestRes = dps[ck] + acc * cw
#                 res[ck] = bestRes
#                 # dps[ck] = max(dps[ck], preRes - preAcc * cw)
#                 # preRes = res[ck]
#                 # res[ck] = max(res[ck], dps[ck] + acc * cw)
#         return res[-1]

# class Solution:
#     def maximumStrength(self, nums: List[int], k: int) -&gt; int:
#         n = len(nums)
#         # 整理前缀和
#         acc = [0]
#         for num in nums:
#             acc.append(acc[-1] + num)
#         # 动态规划每一层选出下标 i 范围内划分 ck 块的最优结果
#         preDps = [0] * (n + 1)
#         dps = [0] * (n + 1)
#         for ck in range(k):
#             cw = k - ck
#             if ck &amp; 1: cw = -cw
#             dps[ck] = -inf
#             curs = -inf
#             for i in range(ck, n):
#                 curs = max(curs, preDps[i] - acc[i] * cw)
#                 dps[i + 1] = max(dps[i], curs + acc[i + 1] * cw)
#             dps, preDps = preDps, dps
#         return preDps[-1]</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 876 ms</p>
                    <p class="mb-0">内存: 17.8 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解采用动态规划的方式来求解。首先，计算数组 `nums` 的累加和 `acc`，这是为了快速计算任意子数组的和。然后，定义动态规划数组 `dps`，其中 `dps[i]` 表示在数组前 `i` 个元素中选取 `ck` 个子数组能够获得的最大能量值。对于每一个可能的 `k`，计算对应的权重 `cw`，这个权重根据 `k` 的值和当前子数组的索引 `ck` 而有所不同，具体为 `(-1)^ck * (k - ck)`。接着，遍历数组使用滚动数组方式更新 `dps`，每次考虑加入新的子数组时，更新 `dps[i]` 为包括新子数组的最大能量值。这个过程中，我们需要维护当前的最大值 `curs` 以便快速更新 `dps`。最终 `dps[-1]` 将包含在整个数组中选取 `k` 个子数组的最大能量值。</p>
                        <p>时间复杂度: O(n^2)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python"># Class definition for the solution to the problem

class Solution:
    def maximumStrength(self, nums: List[int], k: int) -&gt; int:
        n = len(nums)
        # Create prefix sum array
        acc = [0]
        for num in nums:
            acc.append(acc[-1] + num)
        # Initialize the DP array
        dps = [0] * (n + 1)
        # Iterate through possible number of subarrays
        for ck in range(k):
            # Calculate the weight for current number of subarrays
            cw = k - ck
            if ck &amp; 1: cw = -cw
            lastDps = dps[ck]
            dps[ck] = curs = -inf
            # Update DP values for the current subarray count
            for i in range(ck, n - k + ck + 1):
                t = lastDps - acc[i] * cw
                if curs &lt; t: curs = t
                lastDps = dps[i + 1]
                t = curs + acc[i + 1] * cw
                dps[i + 1] = t if dps[i] &lt; t else dps[i]
        # Return the maximum strength from the last DP value
        return dps[-1]</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>