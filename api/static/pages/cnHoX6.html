<!DOCTYPE html>
<html lang="zh">
<head>
    <title>万灵之树</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">万灵之树</strong>
                标签:
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from functools import cache
from collections import Counter
from math import perm
from typing import List


class Solution:
    def treeOfInfiniteSouls(self, gem: List[int], p: int, target: int) -&gt; int:
        if p in (2, 5):
            if target == 9 % p:
                return perm(len(gem) * 2 - 2, len(gem) - 1)
            else:
                return 0
        n = len(gem)
        LIMIT = n - n // 3
        r10 = pow(10, p - 2, p)

        def iter_mask(mask):
            current = 0
            while True:
                current = ((current | ~mask) + 1) &amp; mask
                if current == mask:
                    break
                else:
                    yield current, (~current &amp; mask)

        @cache
        def get_length(mask):
            size = -2
            for i, g in enumerate(gem):
                if (1 &lt;&lt; i) &amp; mask:
                    size += 4 + len(str(g))
            return size

        @cache
        def find_all(mask):
            if mask.bit_count() == 1:
                return [int(&#34;1&#34; + str(gem[mask.bit_length() - 1]) + &#34;9&#34;) % p]
            result = []
            for left, right in iter_mask(mask):
                left_length = get_length(left)
                right_length = get_length(right)
                base = pow(10, left_length + right_length + 1, p)
                mul = pow(10, right_length + 1, p)
                for lr in find_all(left):
                    lm = lr * mul + base + 9
                    for rr in find_all(right):
                        result.append((lm + rr * 10) % p)
            return result

        @cache
        def find_all_counter(mask):
            return Counter(find_all(mask))

        def find_target(mask, target_list):
            if mask.bit_count() &lt;= LIMIT:
                return sum(find_all_counter(mask).get(t, 0) for t in target_list)
            count = 0
            for left, right in iter_mask(mask):
                left_length = get_length(left)
                right_length = get_length(right)
                base = pow(10, left_length + right_length + 1, p)
                if left.bit_count() &lt;= right.bit_count():
                    mul = pow(10, right_length + 1, p)
                    rr_list = []
                    for lr in find_all(left):
                        lm = lr * mul + base + 9
                        rr_list.extend(((t - lm) * r10) % p for t in target_list)
                    count += find_target(right, rr_list)
                else:
                    mulr = pow(r10, right_length + 1, p)
                    lr_list = []
                    for rr in find_all(right):
                        rm = base + 9 + rr * 10
                        lr_list.extend(((t - rm) * mulr) % p for t in target_list)
                    count += find_target(left, lr_list)
            return count

        return find_target((1 &lt;&lt; n) - 1, [target])


sol = Solution()
print(sol.treeOfInfiniteSouls([1, 2, 3], 100, 12319))</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 1843 ms</p>
                    <p class="mb-0">内存: 358.3 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>This solution utilizes dynamic programming and bitmasking to generate all possible binary tree structures using the gems as leaves and then computes the numeric value generated by these trees. Special care is taken with mod arithmetic to handle the large numbers produced during the calculation. The core idea is to recursively calculate potential results for each subset of gems represented as bit masks, and combine these results according to the binary tree structure to check if any of these results modulo p equals the target. The bitmask represents which gems are included in a subtree, and recursive calls help construct the left and right subtrees, with memorization (caching) used to avoid redundant calculations.</p>
                        <p>时间复杂度: O(2^n * n)</p>
                        <p>空间复杂度: O(2^n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from functools import cache
from collections import Counter
from math import perm
from typing import List

class Solution:
    def treeOfInfiniteSouls(self, gem: List[int], p: int, target: int) -&gt; int:
        # Special handling for edge cases involving prime factors of 10
        if p in (2, 5):
            if target == 9 % p:
                return perm(len(gem) * 2 - 2, len(gem) - 1)
            else:
                return 0
        n = len(gem)
        LIMIT = n - n // 3
        r10 = pow(10, p - 2, p)  # Calculate 10^(p-2) mod p to use in reversal

        # Function to iterate through all possible subsets of mask
        def iter_mask(mask):
            current = 0
            while True:
                current = ((current | ~mask) + 1) &amp; mask
                if current == mask:
                    break
                else:
                    yield current, (~current &amp; mask)

        # Calculate the total &#39;length&#39; of the number formed by nodes in the subtree defined by mask
        @cache
        def get_length(mask):
            size = -2
            for i, g in enumerate(gem):
                if (1 &lt;&lt; i) &amp; mask:
                    size += 4 + len(str(g))
            return size

        # Recursively find all possible numbers formed by the tree rooted at a mask
        @cache
        def find_all(mask):
            if mask.bit_count() == 1:
                return [int(&#34;1&#34; + str(gem[mask.bit_length() - 1]) + &#34;9&#34;) % p]
            result = []
            for left, right in iter_mask(mask):
                left_length = get_length(left)
                right_length = get_length(right)
                base = pow(10, left_length + right_length + 1, p)
                mul = pow(10, right_length + 1, p)
                for lr in find_all(left):
                    lm = lr * mul + base + 9
                    for rr in find_all(right):
                        result.append((lm + rr * 10) % p)
            return result

        # Use Counter to count occurrences of each modulo result
        @cache
        def find_all_counter(mask):
            return Counter(find_all(mask))

        # Main function to find how many setups achieve the target modulo
        def find_target(mask, target_list):
            if mask.bit_count() &lt;= LIMIT:
                return sum(find_all_counter(mask).get(t, 0) for t in target_list)
            count = 0
            for left, right in iter_mask(mask):
                left_length = get_length(left)
                right_length = get_length(right)
                base = pow(10, left_length + right_length + 1, p)
                if left.bit_count() &lt;= right.bit_count():
                    mul = pow(10, right_length + 1, p)
                    rr_list = []
                    for lr in find_all(left):
                        lm = lr * mul + base + 9
                        rr_list.extend(((t - lm) * r10) % p for t in target_list)
                    count += find_target(right, rr_list)
                else:
                    mulr = pow(r10, right_length + 1, p)
                    lr_list = []
                    for rr in find_all(right):
                        rm = base + 9 + rr * 10
                        lr_list.extend(((t - rm) * mulr) % p for t in target_list)
                    count += find_target(left, lr_list)
            return count

        return find_target((1 &lt;&lt; n) - 1, [target])

sol = Solution()
print(sol.treeOfInfiniteSouls([1, 2, 3], 100, 12319))
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>