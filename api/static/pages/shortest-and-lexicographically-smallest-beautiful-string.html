<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最短且字典序最小的美丽子字符串</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>最短且字典序最小的美丽子字符串</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                        <a href="/problems?tag=sliding-window" class="badge bg-secondary tag-link">滑动窗口</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>给你一个二进制字符串 <code>s</code> 和一个正整数 <code>k</code> 。</p>

<p>如果 <code>s</code> 的某个子字符串中 <code>1</code> 的个数恰好等于 <code>k</code> ，则称这个子字符串是一个 <strong>美丽子字符串</strong> 。</p>

<p>令 <code>len</code> 等于 <strong>最短</strong> 美丽子字符串的长度。</p>

<p>返回长度等于 <code>len</code> 且字典序 <strong>最小</strong> 的美丽子字符串。如果 <code>s</code> 中不含美丽子字符串，则返回一个 <strong>空</strong> 字符串。</p>

<p>对于相同长度的两个字符串 <code>a</code> 和 <code>b</code> ，如果在 <code>a</code> 和 <code>b</code> 出现不同的第一个位置上，<code>a</code> 中该位置上的字符严格大于 <code>b</code> 中的对应字符，则认为字符串 <code>a</code> 字典序 <strong>大于</strong> 字符串 <code>b</code> 。</p>

<ul>
	<li>例如，<code>"abcd"</code> 的字典序大于 <code>"abcc"</code> ，因为两个字符串出现不同的第一个位置对应第四个字符，而 <code>d</code> 大于 <code>c</code> 。</li>
</ul>



<p><strong class="example">示例 1：</strong></p>

<pre>
<strong>输入：</strong>s = "100011001", k = 3
<strong>输出：</strong>"11001"
<strong>解释：</strong>示例中共有 7 个美丽子字符串：
1. 子字符串 "<em><strong>100011</strong></em>001" 。
2. 子字符串 "<strong><em>1000110</em></strong>01" 。
3. 子字符串 "<strong><em>100011001</em></strong>" 。
4. 子字符串 "1<strong><em>00011001</em></strong>" 。
5. 子字符串 "10<strong><em>0011001</em></strong>" 。
6. 子字符串 "100<em><strong>011001</strong></em>" 。
7. 子字符串 "1000<strong><em>11001</em></strong>" 。
最短美丽子字符串的长度是 5 。
长度为 5 且字典序最小的美丽子字符串是子字符串 "11001" 。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<strong>输入：</strong>s = "1011", k = 2
<strong>输出：</strong>"11"
<strong>解释：</strong>示例中共有 3 个美丽子字符串：
1. 子字符串 "<em><strong>101</strong></em>1" 。
2. 子字符串 "1<em><strong>011</strong></em>" 。
3. 子字符串 "10<em><strong>11</strong></em>" 。
最短美丽子字符串的长度是 2 。
长度为 2 且字典序最小的美丽子字符串是子字符串 "11" 。 
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<strong>输入：</strong>s = "000", k = 1
<strong>输出：</strong>""
<strong>解释：</strong>示例中不存在美丽子字符串。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= s.length &lt;= 100</code></li>
	<li><code>1 &lt;= k &lt;= s.length</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 26 ms</p>
                    <p>内存: 15.9 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -&gt; str:
        res=[]
        t=0
        c=0
        a=False
        for x,i in enumerate(s):
            if i==&#39;1&#39;:
                t+=1
            while t&gt;k:
                if s[c]==&#39;1&#39;:
                    t-=1
                    c+=1
            while c&lt;x and s[c]==&#39;0&#39;:
                c+=1
            if t==k:
                res.append(s[c:x+1])
        if not res:
            return &#39;&#39;
        mi=len(res[0])
        for i in res:
            mi=min(mi,len(i))
        re=[]
        for i in res:
            if len(i)==mi:
                re.append(i)
        re.sort()
        return re[0]</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该解法使用了一个滑动窗口的策略来找到所有包含恰好 k 个 &#39;1&#39; 的子字符串。首先，定义两个指针 c (窗口左边界) 和 x (窗口右边界) 来扫描整个字符串。变量 t 用于记录当前窗口中 &#39;1&#39; 的数量。当 t 大于 k 时，移动左边界 c 直到 t 等于 k。随后检查左边界的 &#39;0&#39;，若左边界是 &#39;0&#39; 则向右移动以找到最短的子字符串。每次当 t 等于 k 时，记录当前的子字符串。最后，在记录的所有满足条件的子字符串中找到长度最短且字典序最小的字符串返回。</p>
                                <p>时间复杂度: O(n + m log m)</p>
                                <p>空间复杂度: O(m * n)</p>
                                <pre class="bg-light p-2">class Solution:
    def shortestBeautifulSubstring(self, s: str, k: int) -&gt; str:
        res=[]  # 存储找到的所有满足条件的子字符串
        t=0  # 当前窗口内 &#39;1&#39; 的数量
        c=0  # 窗口的左边界
        for x, i in enumerate(s):  # x 是当前考虑的字符的位置，i 是字符本身
            if i==&#39;1&#39;:
                t+=1  # 如果当前字符是 &#39;1&#39;，增加计数
            while t&gt;k:  # 如果 &#39;1&#39; 的数量超过了 k，需要移动左边界直到 &#39;1&#39; 的数量等于 k
                if s[c]==&#39;1&#39;:
                    t-=1
                c+=1
            while c&lt;x and s[c]==&#39;0&#39;:  # 移动左边界跳过开头的 &#39;0&#39; 以找到最短的子字符串
                c+=1
            if t==k:  # 如果当前窗口内 &#39;1&#39; 的数量正好是 k，记录下来
                res.append(s[c:x+1])
        if not res:  # 如果没有找到任何满足条件的子字符串，返回空字符串
            return &#39;&#39;
        mi=len(res[0])
        for i in res:  # 找到最短的子字符串长度
            mi=min(mi,len(i))
        re=[]
        for i in res:  # 收集所有最短的子字符串
            if len(i)==mi:
                re.append(i)
        re.sort()  # 对所有最短的子字符串按字典序排序
        return re[0]  # 返回字典序最小的字符串</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            如何确保处理的子字符串始终包含恰好k个&#39;1&#39;，而不是超过k个？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在算法中，通过维护一个计数变量 t 来记录窗口内 &#39;1&#39; 的数量。每当 t 大于 k，就移动窗口的左边界 c，直到 t 减少至 k。这个过程通过检查并调整左边界 c 的位置，确保每次当窗口内的 &#39;1&#39; 数量超过 k 时，能够通过移动窗口左边界来减少 &#39;1&#39; 的数量至恰好 k。这样，每次记录子字符串时，都确保了其包含的 &#39;1&#39; 数量恰好为 k。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在移动左边界以跳过开头的&#39;0&#39;时，为什么没有检查是否还保持有k个&#39;1&#39;？是否可能错过了一些有效的子字符串？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在代码中，移动左边界 c 跳过 &#39;0&#39; 是在确认窗口内已经有 k 个 &#39;1&#39; 之后进行的。这一步只是为了缩短子字符串的长度，并不会改变窗口内 &#39;1&#39; 的数量。因此，这一步并不会导致错过任何有效的子字符串。左边界的移动只发生在 &#39;1&#39; 的数量已经正确匹配为 k 之后，所以不会影响窗口内 &#39;1&#39; 的计数。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            解法中提到当t等于k时记录子字符串，但如果这时候子字符串的开头是&#39;0&#39;，这是否会影响到最终的子字符串长度和字典序的判断？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果子字符串的开头是 &#39;0&#39;, 算法中已经包含了逻辑来移动左边界 c 跳过这些 &#39;0&#39;。这样做的目的是确保记录的子字符串长度尽可能短，同时确保字典序尽可能小。因此，这种处理会有助于找到最短且字典序最小的子字符串，而不会影响到最终的长度和字典序判断。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            为什么在找到所有满足条件的子字符串后还需要进行一次排序？这是否影响算法的效率？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在找到所有满足条件的子字符串后，需要进行排序以确保可以选择出字典序最小的字符串。虽然这一步增加了额外的时间复杂度，但是通常情况下，满足条件的子字符串数量并不会非常大，因此排序的代价相对较小。此外，排序是必要的，因为只有这样才能确保结果是字典序最小的。这是一种权衡效率和正确性的实用做法。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/shortest-and-lexicographically-smallest-beautiful-string')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/shortest-and-lexicographically-smallest-beautiful-string/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>