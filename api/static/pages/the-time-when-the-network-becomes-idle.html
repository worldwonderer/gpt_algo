<!DOCTYPE html>
<html lang="zh">
<head>
    <title>网络空闲的时刻</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>网络空闲的时刻</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=breadth-first-search" class="badge bg-secondary tag-link">广度优先搜索</a>
                    
                        <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>给你一个有 <code>n</code>&nbsp;个服务器的计算机网络，服务器编号为&nbsp;<code>0</code>&nbsp;到&nbsp;<code>n - 1</code>&nbsp;。同时给你一个二维整数数组&nbsp;<code>edges</code>&nbsp;，其中&nbsp;<code>edges[i] = [u<sub>i</sub>, v<sub>i</sub>]</code>&nbsp;表示服务器&nbsp;<code>u<sub>i</sub></code> 和&nbsp;<code>v<sub>i</sub></code><sub>&nbsp;</sub>之间有一条信息线路，在&nbsp;<strong>一秒</strong>&nbsp;内它们之间可以传输&nbsp;<strong>任意</strong>&nbsp;数目的信息。再给你一个长度为 <code>n</code>&nbsp;且下标从&nbsp;<strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>patience</code>&nbsp;。</p>

<p>题目保证所有服务器都是 <b>相通</b>&nbsp;的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。</p>

<p>编号为 <code>0</code>&nbsp;的服务器是 <strong>主</strong>&nbsp;服务器，其他服务器为 <strong>数据</strong>&nbsp;服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 <strong>最优</strong>&nbsp;线路传输，也就是说每个信息都会以 <strong>最少时间</strong>&nbsp;到达主服务器。主服务器会处理 <strong>所有</strong>&nbsp;新到达的信息并 <strong>立即</strong>&nbsp;按照每条信息来时的路线 <strong>反方向</strong> 发送回复信息。</p>

<p>在 <code>0</code>&nbsp;秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 <code>1</code>&nbsp;秒开始，<strong>每</strong>&nbsp;一秒最 <strong>开始</strong>&nbsp;时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：</p>

<ul>
	<li>如果还没收到任何回复信息，那么该服务器会周期性&nbsp;<strong>重发</strong>&nbsp;信息。数据服务器&nbsp;<code>i</code>&nbsp;每&nbsp;<code>patience[i]</code>&nbsp;秒都会重发一条信息，也就是说，数据服务器&nbsp;<code>i</code>&nbsp;在上一次发送信息给主服务器后的 <code>patience[i]</code>&nbsp;秒 <strong>后</strong>&nbsp;会重发一条信息给主服务器。</li>
	<li>否则，该数据服务器&nbsp;<strong>不会重发</strong>&nbsp;信息。</li>
</ul>

<p>当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 <strong>空闲</strong>&nbsp;状态。</p>

<p>请返回计算机网络变为 <strong>空闲</strong>&nbsp;状态的&nbsp;<strong>最早秒数</strong>&nbsp;。</p>



<p><strong>示例 1：</strong></p>

<p><img alt="example 1" src="https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png" style="width: 750px; height: 384px;"></p>

<pre><b>输入：</b>edges = [[0,1],[1,2]], patience = [0,2,1]
<b>输出：</b>8
<strong>解释：</strong>
0 秒最开始时，
- 数据服务器 1 给主服务器发出信息（用 1A 表示）。
- 数据服务器 2 给主服务器发出信息（用 2A 表示）。

1 秒时，
- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。
- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 &lt; patience[1] = 2），所以不会重发信息。
- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。

2 秒时，
- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。
- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。
- 服务器 2 重发一条信息（用 2C 表示）。
...
4 秒时，
- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。
...
7 秒时，回复信息 2D 到达服务器 2 。

从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。
所以第 8 秒是网络变空闲的最早时刻。
</pre>

<p><strong>示例 2：</strong></p>

<p><img alt="example 2" src="https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png" style="width: 100px; height: 85px;"></p>

<pre><b>输入：</b>edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
<b>输出：</b>3
<b>解释：</b>数据服务器 1 和 2 第 2 秒初收到回复信息。
从第 3 秒开始，网络变空闲。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>n == patience.length</code></li>
	<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>
	<li><code>patience[0] == 0</code></li>
	<li>对于&nbsp;<code>1 &lt;= i &lt; n</code> ，满足&nbsp;<code>1 &lt;= patience[i] &lt;= 10<sup>5</sup></code></li>
	<li><code>1 &lt;= edges.length &lt;= min(10<sup>5</sup>, n * (n - 1) / 2)</code></li>
	<li><code>edges[i].length == 2</code></li>
	<li><code>0 &lt;= u<sub>i</sub>, v<sub>i</sub> &lt; n</code></li>
	<li><code>u<sub>i</sub> != v<sub>i</sub></code></li>
	<li>不会有重边。</li>
	<li>每个服务器都直接或间接与别的服务器相连。</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 302 ms</p>
                    <p>内存: 52.7 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -&gt; int:
            
        n = len(patience)
        # 构建图的邻接表表示
        graph = [[] for _ in range(n)]
        for u, v in edges:
            graph[u].append(v)
            graph[v].append(u)

        # BFS 计算从主服务器到每个数据服务器的最短距离
        distance = [0] * n  # distance[i] 表示从主服务器到服务器i的最短距离
        visited = [False] * n
        queue = deque([0])
        visited[0] = True
        while queue:
            node = queue.popleft()
            for neighbor in graph[node]:
                if not visited[neighbor]:
                    visited[neighbor] = True
                    distance[neighbor] = distance[node] + 1
                    queue.append(neighbor)

        # 计算变为空闲的时间
        idle_time = 0
        for i in range(1, n):
            round_trip = 2 * distance[i]  # 往返时间
            last_message_time = ((round_trip - 1) // patience[i]) * patience[i] + round_trip  # 最后一次信息的到达时间
            idle_time = max(idle_time, last_message_time)

        return idle_time + 1  # +1 是因为在最后一次信息到达后的下一秒，网络变为空闲
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题解首先通过构建一个图的邻接表来表示各服务器间的连接关系。利用广度优先搜索（BFS），计算从主服务器（编号为0）到所有其他服务器的最短距离。接着，计算每个数据服务器在不再发送新信息的情况下，最后一条信息的到达时间。这是通过计算每个数据服务器的重发间隔和往返时间来完成的。最终，通过确定所有服务器最后一条信息的到达时间来计算网络何时变为空闲。</p>
                                <p>时间复杂度: O(V + E)</p>
                                <p>空间复杂度: O(V + E)</p>
                                <pre class="bg-light p-2">class Solution:
    def networkBecomesIdle(self, edges: List[List[int]], patience: List[int]) -&gt; int:
            
        n = len(patience)  # 数据服务器的数量
        # 构建图的邻接表表示
        graph = [[] for _ in range(n)]
        for u, v in edges:  # 创建无向边
            graph[u].append(v)
            graph[v].append(u)

        # BFS 计算从主服务器到每个数据服务器的最短距离
        distance = [0] * n  # distance[i] 表示从主服务器到服务器i的最短距离
        visited = [False] * n  # 访问标记数组
        queue = deque([0])  # 使用队列实现BFS
        visited[0] = True  # 标记主服务器已访问
        while queue:  # BFS 主循环
            node = queue.popleft()  # 取出队列首部元素
            for neighbor in graph[node]:  # 遍历当前节点的所有邻居
                if not visited[neighbor]:  # 如果邻居未被访问过
                    visited[neighbor] = True  # 标记为已访问
                    distance[neighbor] = distance[node] + 1  # 更新距离
                    queue.append(neighbor)  # 将邻居节点加入队列

        # 计算变为空闲的时间
        idle_time = 0
        for i in range(1, n):  # 遍历所有数据服务器
            round_trip = 2 * distance[i]  # 往返时间
            last_message_time = ((round_trip - 1) // patience[i]) * patience[i] + round_trip  # 最后一次信息的到达时间
            idle_time = max(idle_time, last_message_time)  # 更新最长等待时间

        return idle_time + 1  # +1 是因为在最后一次信息到达后的下一秒，网络变为空闲
</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            为什么在使用广度优先搜索（BFS）来计算从主服务器到每个数据服务器的最短距离时，可以保证找到的就是最短路径？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>广度优先搜索（BFS）从起点开始，逐层遍历图中的节点，首先访问起点的直接邻居，再访问直接邻居的邻居，依此类推。由于BFS一层层地扩展，对于任何从起点到达特定节点的路径，当这个节点第一次被访问时，该路径就是从起点到该节点的最短路径。在题解中，使用BFS计算从主服务器（编号0）到其他所有服务器的距离，确保了每次当一个服务器第一次被访问时，记录的路径长度是从主服务器到该服务器的最短距离。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            题解中提到了所有服务器都是相通的，这个信息如何帮助简化算法的实现？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中提到所有服务器都是相通的，这意味着从主服务器出发可以到达网络中的任何一个服务器。这个信息的前提简化了算法的实现，因为我们不需要检查连接的完整性或处理无法到达的服务器。在实现BFS时，无需考虑图中是否存在孤立的部分或分支，可以直接假设所有服务器都将在搜索过程中被访问。这减少了算法在处理孤岛或分割网络时可能需要的额外逻辑或错误处理。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解最终返回的`idle_time + 1`是否表示网络在这一刻完全没有数据传输，包括主服务器向数据服务器的回复？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中计算的`idle_time`是所有数据服务器发出的最后一条信息的到达时间的最大值。通过将这个时间加1，我们得到的`idle_time + 1`代表的是在所有服务器发出的最后一条信息到达后的下一秒，即此刻之后再也没有新的信息被发送或到达。所以，`idle_time + 1`确实表示网络在这一刻完全没有任何数据传输，包括主服务器向数据服务器的回复。这标志着网络空闲的开始时刻。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/the-time-when-the-network-becomes-idle')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/the-time-when-the-network-becomes-idle/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>