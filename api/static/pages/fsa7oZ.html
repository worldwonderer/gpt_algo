<!DOCTYPE html>
<html lang="zh">
<head>
    <title>无限棋局</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">无限棋局</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=enumeration" class="badge bg-secondary tag-link">枚举</a>
                
                    <a href="/problems?tag=game-theory" class="badge bg-secondary tag-link">博弈</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
class Solution:
    def gobang(self, pieces: List[List[int]]) -&gt; str:
        B = [defaultdict(SortedList) for _ in range(4)] # 黑棋的四类直线：水平, 垂直, 斜率为1, 斜率为-1
        W = [defaultdict(SortedList) for _ in range(4)] # 白棋的四类直线：水平, 垂直, 斜率为1, 斜率为-1

        def add_piece(x, y, c):
            P = W if c else B
            P[0][y].add(x)
            P[1][x].add(y)
            P[2][y - x].add(x)
            P[3][y + x].add(x)

        def get_pos(k, v, d):
            if d == 0: x, y = v, k
            elif d == 1: x, y = k, v
            elif d == 2: x, y = v, k + v
            elif d == 3: x, y = v, k - v
            return (x, y)

        # 找到P的棋子中，冲np(3或4)的点（填上这个点就必胜，并且没有Q的棋子阻挡）
        def find_win_ps(P, Q, np) -&gt; defaultdict(set):
            win_points = defaultdict(set)
            for d in range(4):
                for k in P[d]:
                    ps, n = P[d][k], len(P[d][k])
                    if n &lt; np: continue
                    for i in range(n + 1 - np):
                        dif = ps[i + np - 1] - ps[i]
                        if dif &lt; 5: # &lt;5 说明能成5
                            # 找出空缺的v。找规律发现在[ps[i]-(4-dif), ps[i] + 5]，不是已有的v的点
                            vs = [v for v in range(ps[i] + dif - 4, ps[i] + 5) if
                                  v not in ps[i:i + np] and not has_piece(Q, (k, v, d))]
                            nvs = len(vs)
                            if nvs &lt; 5 - np: continue  # 3-&gt;2, 4-&gt;1
                            dt = 4 - np
                            for j in range(nvs - dt):
                                v1, v2 = vs[j], vs[j + dt]
                                if v2 - v1 &gt; 4: continue
                                xy1, xy2 = get_pos(k, v1, d), get_pos(k, v2, d)
                                win_points[xy1].add(xy2)
                                win_points[xy2].add(xy1)
                                if np == 4 and len(win_points) &gt; 1: return win_points
            return win_points

        def has_piece(X, kvd) -&gt; bool:
            k, v, d = kvd
            return k in X[d] and v in X[d][k]

        # 开始，棋子先存好
        for x, y, c in pieces:
            add_piece(x, y, c)

        # 1. 黑先手有4连黑子，并且有空位放下能成5连黑子，就黑胜
        if len(find_win_ps(B, W, 4)) &gt; 0:
            return &#39;Black&#39;

        # 白如果有多个冲4就赢
        live_w4 = find_win_ps(W, B, 4)
        if len(live_w4) &gt; 1:
            return &#39;White&#39;

        # 白只有1个冲4，黑先堵上；如果黑有多个冲4就赢，否则None
        if len(live_w4) == 1:
            x, y = list(live_w4.keys())[0]
            add_piece(x, y, 0)
            return &#39;Black&#39; if len(find_win_ps(B, W, 4)) &gt; 1 else &#39;None&#39;

        # 检查最开始如果有形成双4的点，就黑赢
        return &#39;Black&#39; if any(len(ds) &gt; 1 for ds in find_win_ps(B, W, 3).values()) else &#39;None&#39;
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 200 ms</p>
                    <p class="mb-0">内存: 19.6 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解采用了搜索和评估的策略来预测五子棋的输赢情况。核心思路是通过哈希表记录各类直线（水平、垂直、两个对角线）上的棋子位置。通过这种数据结构可以快速地评估和更新棋局。具体方法包括：1. 初始化黑白棋的数据结构来记录棋子位置；2. 为每种颜色的棋子定义添加函数，便于更新棋局；3. 评估每种直线上的棋子配置，查找可以直接赢得比赛的落子点；4. 根据当前棋局使用最优策略预测接下来的三步棋，包括黑白双方的最优防守和进攻。根据棋局动态评估，判断棋局的输赢情况。</p>
                        <p>时间复杂度: O(m * n * log n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from collections import defaultdict

class Solution:
    def gobang(self, pieces: List[List[int]]) -&gt; str:
        B = [defaultdict(SortedList) for _ in range(4)]  # Black pieces lines: horizontal, vertical, diagonal with slope 1 and -1
        W = [defaultdict(SortedList) for _ in range(4)]  # White pieces lines

        def add_piece(x, y, c):
            P = W if c else B  # Select color array
            P[0][y].add(x)  # Add to horizontal line
            P[1][x].add(y)  # Add to vertical line
            P[2][y - x].add(x)  # Add to diagonal line slope 1
            P[3][y + x].add(x)  # Add to diagonal line slope -1

        def get_pos(k, v, d):  # Helper to get the actual position based on line and index
            if d == 0: x, y = v, k
            elif d == 1: x, y = k, v
            elif d == 2: x, y = v, k + v
            elif d == 3: x, y = v, k - v
            return (x, y)

        # Search for winning moves, where adding a piece leads to a victory
        def find_win_ps(P, Q, np) -&gt; defaultdict(set):
            win_points = defaultdict(set)
            for d in range(4):
                for k in P[d]:
                    ps, n = P[d][k], len(P[d][k])
                    if n &lt; np: continue  # Not enough pieces to form a line
                    for i in range(n + 1 - np):
                        dif = ps[i + np - 1] - ps[i]
                        if dif &lt; 5:  # Potential win by filling gaps
                            vs = [v for v in range(ps[i] + dif - 4, ps[i] + 5) if v not in ps[i:i + np] and not has_piece(Q, (k, v, d))]
                            nvs = len(vs)
                            if nvs &lt; 5 - np: continue  # Not enough spots to win
                            dt = 4 - np
                            for j in range(nvs - dt):
                                v1, v2 = vs[j], vs[j + dt]
                                if v2 - v1 &gt; 4: continue  # Too far apart to form a line
                                xy1, xy2 = get_pos(k, v1, d), get_pos(k, v2, d)
                                win_points[xy1].add(xy2)
                                win_points[xy2].add(xy1)
                                if np == 4 and len(win_points) &gt; 1: return win_points  # Immediate win for 4 in a row
            return win_points

        def has_piece(X, kvd) -&gt; bool:  # Check if a position is occupied
            k, v, d = kvd
            return k in X[d] and v in X[d][k]

        for x, y, c in pieces:
            add_piece(x, y, c)  # Add initial pieces to the board

        if len(find_win_ps(B, W, 4)) &gt; 0:
            return &#39;Black&#39;  # Black wins with a potential 5 in a row

        live_w4 = find_win_ps(W, B, 4)
        if len(live_w4) &gt; 1:
            return &#39;White&#39;  # White wins if multiple 4 in a row options exist

        if len(live_w4) == 1:
            x, y = list(live_w4.keys())[0]
            add_piece(x, y, 0)  # Block white&#39;s potential 4 in a row
            return &#39;Black&#39; if len(find_win_ps(B, W, 4)) &gt; 1 else &#39;None&#39;  # Check if blocking leads to a new win or a draw

        return &#39;Black&#39; if any(len(ds) &gt; 1 for ds in find_win_ps(B, W, 3).values()) else &#39;None&#39;  # Check for possible double 4&#39;s for black
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>