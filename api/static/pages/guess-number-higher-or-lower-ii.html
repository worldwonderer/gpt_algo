<!DOCTYPE html>
<html lang="zh">
<head>
    <title>猜数字大小 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>猜数字大小 II</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                    
                        <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                    
                        <a href="/problems?tag=game-theory" class="badge bg-secondary tag-link">博弈</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>我们正在玩一个猜数游戏，游戏规则如下：</p>

<ol>
	<li>我从&nbsp;<code>1</code><strong>&nbsp;</strong>到 <code>n</code> 之间选择一个数字。</li>
	<li>你来猜我选了哪个数字。</li>
	<li>如果你猜到正确的数字，就会 <strong>赢得游戏</strong> 。</li>
	<li>如果你猜错了，那么我会告诉你，我选的数字比你的 <strong>更大或者更小</strong> ，并且你需要继续猜数。</li>
	<li>每当你猜了数字 <code>x</code> 并且猜错了的时候，你需要支付金额为 <code>x</code> 的现金。如果你花光了钱，就会<strong> 输掉游戏</strong> 。</li>
</ol>

<p>给你一个特定的数字 <code>n</code> ，返回能够 <strong>确保你获胜</strong> 的最小现金数，<strong>不管我选择那个数字</strong> 。</p>



<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2020/09/10/graph.png" style="width: 505px; height: 388px;" />
<pre>
<strong>输入：</strong>n = 10
<strong>输出：</strong>16
<strong>解释：</strong>制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
&nbsp;   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
&nbsp;   - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
&nbsp;       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
&nbsp;       - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
&nbsp;       - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
&nbsp;   - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
&nbsp;       - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
&nbsp;       - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
&nbsp;           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
&nbsp;           - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
&nbsp;           - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
&nbsp;       - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
&nbsp;           - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
&nbsp;           - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>0
<strong>解释：</strong>只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>n = 2
<strong>输出：</strong>1
<strong>解释：</strong>有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
&nbsp;   - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
&nbsp;   - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 200</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 35 ms</p>
                    <p>内存: 16.1 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        def min(x,y):
            if x&gt;=y:return y
            return x
        def max(x,y):
            return x if x&gt;y else y
        dp=[[0]*(1+n) for _ in range(1+n)]
        for j in range(1,n+1):
            for i in range(j-1,-1,-1):
                dp[i][j]=i+dp[i+1][j]
                for k in range(i+1,j):
                    dp[i][j]=min(dp[i][j],k+max(dp[i][k-1],dp[k+1][j]))
        return dp[0][-1]
        @cache
        def dfs(left,right):
            if right-left==1:
                return left
            elif right-left==2:
                return left+1
            elif right-left==3:return left+left+2
            elif left&gt;=right:return 0
            ans=inf
            for i in range(left+1,right):
                ans=min(ans,i+max(dfs(left,i-1),dfs(i+1,right)))
            return ans
        return dfs(1,n)</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>这个题解使用了动态规划的策略来解决问题。定义一个二维数组 dp，其中 dp[i][j] 表示在范围 i 到 j 内确保胜利的最小支付金额。我们从较小的范围开始计算，并逐步扩展到整个范围。对于每一个范围 [i, j]，我们考虑所有可能的猜测点 k，计算在猜测点 k 失败后，左侧范围 [i, k-1] 和右侧范围 [k+1, j] 中较大的代价，并加上当前的猜测代价 k，从而更新 dp[i][j]。通过这种方式，我们可以填满整个 dp 表，dp[0][n] 就是从 1 到 n 确保胜利所需的最小金额。</p>
                                <p>时间复杂度: O(n^3)</p>
                                <p>空间复杂度: O(n^2)</p>
                                <pre class="bg-light p-2">class Solution:
    def getMoneyAmount(self, n: int) -&gt; int:
        # 自定义小的min函数
        def min(x,y):
            return y if x &gt;= y else x
        # 自定义大的max函数
        def max(x,y):
            return x if x &gt; y else y
        # 初始化dp数组
        dp = [[0] * (1 + n) for _ in range(1 + n)]
        # 外层循环，逐步扩大范围
        for j in range(1, n + 1):
            # 内层循环，从后向前计算
            for i in range(j - 1, -1, -1):
                # 初始化dp[i][j]为i+dp[i+1][j]，即考虑最小的i作为猜测点
                dp[i][j] = i + dp[i + 1][j]
                # 中间层循环，考虑所有可能的猜测点
                for k in range(i + 1, j):
                    # 更新dp[i][j]为从k点猜错后两侧的最大代价加上当前猜测代价k
                    dp[i][j] = min(dp[i][j], k + max(dp[i][k - 1], dp[k + 1][j]))
        # 返回整个范围的最小代价
        return dp[0][-1]</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            题解中用到了二维数组dp，每个元素dp[i][j]代表什么意义？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在这个问题中，每个元素dp[i][j]表示的是在数字范围i到j之间，为了确保无论对方选择哪个数字你都能赢得游戏，你需要支付的最小金额。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            为什么在初始化dp数组时，dp[i][j]被初始化为i+dp[i+1][j]？这种初始化方式有什么特别的考虑吗？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>这种初始化方式考虑的是最小可能的猜测点情况，即当你首先猜测最小的边界数字i时的情况。如果猜测错误（实际数字大于i），则你需要支付i元，并且面对的新范围是[i+1, j]。因此，总的最小成本就是猜测成本i加上新范围[i+1, j]的最小成本。这是一种保守的初始化，为后续的计算提供一个基准值。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解中提到，对于每一个k点，计算的是k + max(dp[i][k-1], dp[k+1][j])。请问为什么要选择两侧范围中的最大代价而不是最小代价？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>选择两侧范围中的最大代价是因为我们需要考虑最坏情况，即对手选择了使你支付最多的数字。如果你猜测数字k并且猜错了，你需要继续在两个新的范围[i, k-1]或[k+1, j]中猜测。这里的最大代价确保了无论对手如何选择，你都有足够的资金来继续游戏，从而确保能赢得游戏。选择最小代价可能导致在某些不利情况下资金不足，无法继续游戏。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
                <aside class="related-problems-section">
                    <h2>Related Problems</h2>
                    <div class="list-group">
                        
                            <a href="/problem/flip-game-ii" class="list-group-item list-group-item-action">
                                翻转游戏 II
                            </a>
                        
                            <a href="/problem/guess-number-higher-or-lower" class="list-group-item list-group-item-action">
                                猜数字大小
                            </a>
                        
                            <a href="/problem/can-i-win" class="list-group-item list-group-item-action">
                                我能赢吗
                            </a>
                        
                            <a href="/problem/find-k-closest-elements" class="list-group-item list-group-item-action">
                                找到 K 个最接近的元素
                            </a>
                        
                    </div>
                </aside>
            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/guess-number-higher-or-lower-ii')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/guess-number-higher-or-lower-ii/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>