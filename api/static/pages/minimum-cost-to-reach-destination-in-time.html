<!DOCTYPE html>
<html lang="zh">
<head>
    <title>规定时间内到达终点的最小花费</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">规定时间内到达终点的最小花费</strong>
                标签:
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -&gt; int:
        n = len(passingFees)
        graph = [[] for _ in range(n)]
        for edge in edges:
            from_ = edge[0]
            to_ = edge[1]
            time = edge[2]
            graph[from_].append([to_, time])
            graph[to_].append([from_,time])

        # 计算以 src 为起点在 maxtime 时间内到达 dst 的最短路径
        return dijkstra(graph, 0, maxTime, n-1, passingFees)


class State:
    # 图节点的 id
    def __init__(self, id_: int, costFromSrc: int, timeFromSrc: int):
        self.id = id_
        self.costFromSrc = costFromSrc
        self.timeFromSrc = timeFromSrc

    def __lt__(self, other):
        return self.costFromSrc &lt; other.costFromSrc


# 输入一个起点 src，计算从 src 到其他节点的最短距离
def dijkstra(graph: List[List[int]], src: int, maxtime: int, dst: int,price) -&gt; int:
    # 定义：从起点 src 到达节点 i 的最小权重路径至少花的时间
    distTo = [float(&#34;inf&#34;) for _ in range(len(graph))]
    # 定义：从起点 src 到达节点 i 的最少通行费
    nodeNumTo = [float(&#34;inf&#34;) for _ in range(len(graph))]
    # base case
    distTo[src] = 0
    nodeNumTo[src] = price[src]

    # 优先级队列，costFromSrc 较小的排在前面
    pq = []
    # 从起点 src 开始进行 BFS
    heapq.heappush(pq, State(src, price[0], 0))

    while pq:
        curState = heapq.heappop(pq)
        curNodeID = curState.id
        costFromSrc = curState.costFromSrc
        timeFromSrc = curState.timeFromSrc

        if costFromSrc &gt;nodeNumTo[curNodeID] and timeFromSrc &gt; distTo[curNodeID]:
            continue

        if timeFromSrc &gt; maxtime:
            # 时间耗尽
            continue

        if curNodeID == dst:
            # 找到最短路径
            return costFromSrc


        # 将 curNode 的相邻节点装入队列
        for neighbor in graph[curNodeID]:
            nextNodeID = neighbor[0]
            costToNextNode = costFromSrc + price[nextNodeID]
            # 增加时间消耗
            nexttimeFromSrc = timeFromSrc + neighbor[1]
            if nexttimeFromSrc&gt;maxtime:
                continue
            # 更新 dp table
            if nodeNumTo[nextNodeID] &gt; costToNextNode:
                nodeNumTo[nextNodeID] = costToNextNode
                distTo[nextNodeID] = min(distTo[nextNodeID],nexttimeFromSrc)
                heapq.heappush(pq, State(nextNodeID, costToNextNode, nexttimeFromSrc))

            elif distTo[nextNodeID]&gt;nexttimeFromSrc:
                heapq.heappush(pq, State(nextNodeID, costToNextNode, nexttimeFromSrc))
                distTo[nextNodeID] = nexttimeFromSrc
            
    return -1</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 108 ms</p>
                    <p class="mb-0">内存: 16.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题使用了带有优先队列的 Dijkstra 算法来寻找在规定时间内从起点到终点的最小费用路径。首先，构建一个图来表示城市之间的道路和通行时间。然后，使用 Dijkstra 算法，通过优先队列来优先处理费用较小的路径。在遍历过程中，记录每个节点到起点的最小费用和最短时间，如果到达某个节点的路径费用更小或者时间更短，则更新该节点的信息并将其加入优先队列中继续遍历。最终，如果能在规定时间内到达终点，则返回最小费用，否则返回 -1。</p>
                        <p>时间复杂度: O(E + VlogV)</p>
                        <p>空间复杂度: O(V + E)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minCost(self, maxTime: int, edges: List[List[int]], passingFees: List[int]) -&gt; int:
        n = len(passingFees)
        graph = [[] for _ in range(n)]
        for edge in edges:
            from_ = edge[0]
            to_ = edge[1]
            time = edge[2]
            graph[from_].append([to_, time])
            graph[to_].append([from_,time])

        return dijkstra(graph, 0, maxTime, n-1, passingFees)


class State:
    def __init__(self, id_: int, costFromSrc: int, timeFromSrc: int):
        self.id = id_
        self.costFromSrc = costFromSrc
        self.timeFromSrc = timeFromSrc

    def __lt__(self, other):
        return self.costFromSrc &lt; other.costFromSrc


def dijkstra(graph: List[List[int]], src: int, maxtime: int, dst: int,price) -&gt; int:
    distTo = [float(&#39;inf&#39;)] * len(graph)
    nodeNumTo = [float(&#39;inf&#39;)] * len(graph)
    distTo[src] = 0
    nodeNumTo[src] = price[src]

    pq = []
    heapq.heappush(pq, State(src, price[0], 0))

    while pq:
        curState = heapq.heappop(pq)
        curNodeID = curState.id
        costFromSrc = curState.costFromSrc
        timeFromSrc = curState.timeFromSrc

        if costFromSrc &gt; nodeNumTo[curNodeID] and timeFromSrc &gt; distTo[curNodeID]:
            continue

        if timeFromSrc &gt; maxtime:
            continue

        if curNodeID == dst:
            return costFromSrc

        for neighbor in graph[curNodeID]:
            nextNodeID = neighbor[0]
            costToNextNode = costFromSrc + price[nextNodeID]
            nexttimeFromSrc = timeFromSrc + neighbor[1]
            if nexttimeFromSrc &gt; maxtime:
                continue
            if nodeNumTo[nextNodeID] &gt; costToNextNode:
                nodeNumTo[nextNodeID] = costToNextNode
                distTo[nextNodeID] = min(distTo[nextNodeID], nexttimeFromSrc)
                heapq.heappush(pq, State(nextNodeID, costToNextNode, nexttimeFromSrc))
            elif distTo[nextNodeID] &gt; nexttimeFromSrc:
                heapq.heappush(pq, State(nextNodeID, costToNextNode, nexttimeFromSrc))
                distTo[nextNodeID] = nexttimeFromSrc

    return -1</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>