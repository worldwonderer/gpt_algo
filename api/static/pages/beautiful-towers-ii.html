<!DOCTYPE html>
<html lang="zh">
<head>
    <title>美丽塔 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">美丽塔 II</strong>
                标签:
                
                    <a href="/problems?tag=stack" class="badge bg-secondary tag-link">栈</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=monotonic-stack" class="badge bg-secondary tag-link">单调栈</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:

    def maximumSumOfHeights(self, maxHeights: List[int]) -&gt; int:
        n = len(maxHeights)
        pre = [0] * n 
        post = [0] * n 
        s = []
        for i in range(n):
            while s and maxHeights[s[-1]] &gt; maxHeights[i]:
                s.pop()
            if not s:
                pre[i] = (i+1)*maxHeights[i]
            else:
                pre[i] = pre[s[-1]]+(i-s[-1])*maxHeights[i]
            s.append(i)
        s = []
        res = 0
        for i in range(n-1, -1, -1):
            while s and maxHeights[s[-1]] &gt; maxHeights[i]:
                s.pop()
            if not s:
                post[i] = (n-i)*maxHeights[i]
            else:
                post[i] = post[s[-1]]+(s[-1]-i)*maxHeights[i]
            s.append(i)
            res = max(res, pre[i]+post[i]-maxHeights[i])
        return res

            </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 227 ms</p>
                    <p class="mb-0">内存: 39.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The given solution tries to find the maximum sum of heights for a mountain array configuration. First, it uses two arrays `pre` and `post` to store the maximum possible sum of heights from the start to the current index (for `pre`) and from the current index to the end (for `post`). The algorithm performs two passes over the `maxHeights` array. In the first pass (forward direction), it computes for each tower the maximum sum of heights from the start up to and including that tower, under the constraint that tower heights must not decrease. It uses a stack to maintain indices of towers such that the heights at these indices are in a non-decreasing order. This helps in efficiently computing the range sum by popping indices from the stack when the current tower height is less than the height at the top index of the stack. In the second pass (backward direction), it similarly computes the maximum sum of heights from each tower to the end of the array. Finally, for each tower, it combines these sums (subtracting the tower&#39;s height once because it&#39;s added in both `pre` and `post`), and tracks the maximum sum obtained. This maximum sum represents the highest sum of heights for a mountain array configuration.</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maximumSumOfHeights(self, maxHeights: List[int]) -&gt; int:
        n = len(maxHeights)
        pre = [0] * n  # Array to store max sum from start to i
        post = [0] * n  # Array to store max sum from i to end
        s = []  # Stack to maintain indices with non-decreasing maxHeights
        for i in range(n):
            while s and maxHeights[s[-1]] &gt; maxHeights[i]:
                s.pop()  # Maintain non-decreasing order in stack
            if not s:
                pre[i] = (i+1)*maxHeights[i]  # Calculate sum from start to i if it&#39;s the smallest seen so far
            else:
                pre[i] = pre[s[-1]] + (i-s[-1]) * maxHeights[i]  # Calculate sum using previous values
            s.append(i)
        s = []
        res = 0
        for i in range(n-1, -1, -1):
            while s and maxHeights[s[-1]] &gt; maxHeights[i]:
                s.pop()
            if not s:
                post[i] = (n-i) * maxHeights[i]  # Calculate sum from i to end if it&#39;s the smallest seen so far
            else:
                post[i] = post[s[-1]] + (s[-1]-i) * maxHeights[i]  # Calculate sum using previous values
            s.append(i)
            res = max(res, pre[i] + post[i] - maxHeights[i])  # Combine pre and post subtracting current height once
        return res
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>