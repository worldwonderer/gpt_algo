<!DOCTYPE html>
<html lang="zh">
<head>
    <title>十字路口的交通</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">十字路口的交通</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">import math
from typing import List
from itertools import combinations
from functools import lru_cache


class Solution:
    def trafficCommand(self, directions: List[str]) -&gt; int:
        &#34;&#34;&#34;

        :param directions:
        :return:
        &#34;&#34;&#34;
        ll = [len(i) for i in directions]

        @lru_cache(None)
        def can_pass(e, s, w, n):

            todo = {}
            op = [0] * 16
            if e != &#39;&#39;:
                todo[&#39;e&#39;] = e.lower()
            if s != &#39;&#39;:
                todo[&#39;s&#39;] = s.lower()
            if w != &#39;&#39;:
                todo[&#39;w&#39;] = w.lower()
            if n != &#39;&#39;:
                todo[&#39;n&#39;] = n.lower()
            for i in todo:
                if i == &#39;e&#39;:
                    if todo[i] == &#39;s&#39;:
                        if op[5] == 1 or op[8] == 1 or op[10] == 1 or op[15] == 1 or op[14] == 1:
                            return False
                        op[5] = 1
                        op[8] = 1
                        op[10] = 1
                        op[15] = 1
                        op[14] = 1
                    if todo[i] == &#39;w&#39;:
                        if op[2] == 1 or op[3] == 1 or op[4] == 1 or op[5] == 1:
                            return False
                        op[2] = 1
                        op[3] = 1
                        op[4] = 1
                        op[5] = 1
                    if todo[i] == &#39;n&#39;:
                        if op[1] == 1 or op[5] == 1:
                            return False
                        op[1] = 1
                        op[5] = 1
                if i == &#39;s&#39;:
                    if todo[i] == &#39;w&#39;:
                        if op[2] == 1 or op[7] == 1 or op[11] == 1 or op[13] == 1 or op[15] == 1:
                            return False
                        op[2] = 1
                        op[7] = 1
                        op[11] = 1
                        op[13] = 1
                        op[15] = 1
                    if todo[i] == &#39;e&#39;:
                        if op[9] == 1 or op[11] == 1:
                            return False
                        op[9] = 1
                        op[11] = 1
                    if todo[i] == &#39;n&#39;:
                        if op[1] == 1 or op[4] == 1 or op[8] == 1 or op[11] == 1:
                            return False
                        op[1] = 1
                        op[4] = 1
                        op[8] = 1
                        op[11] = 1
                if i == &#39;w&#39;:
                    if todo[i] == &#39;s&#39;:
                        if op[6] == 1 or op[10] == 1:
                            return False
                        op[6] = 1
                        op[10] = 1
                    if todo[i] == &#39;e&#39;:
                        if op[6] == 1 or op[7] == 1 or op[9] == 1 or op[8] == 1:
                            return False
                        op[6] = 1
                        op[7] = 1
                        op[9] = 1
                        op[8] = 1
                    if todo[i] == &#39;n&#39;:
                        if op[1] == 1 or op[3] == 1 or op[6] == 1 or op[12] == 1 or op[13] == 1:
                            return False
                        op[1] = 1
                        op[3] = 1
                        op[6] = 1
                        op[12] = 1
                        op[13] = 1

                if i == &#39;n&#39;:
                    if todo[i] == &#39;s&#39;:
                        if op[3] == 1 or op[0] == 1 or op[10] == 1 or op[7] == 1:
                            return False
                        op[3] = 1
                        op[0] = 1
                        op[10] = 1
                        op[7] = 1

                    if todo[i] == &#39;e&#39;:
                        if op[9] == 1 or op[0] == 1 or op[4] == 1 or op[12] == 1 or op[14] == 1:
                            return False
                        op[9] = 1
                        op[0] = 1
                        op[4] = 1
                        op[12] = 1
                        op[14] = 1

                    if todo[i] == &#39;w&#39;:
                        if op[0] == 1 or op[2] == 1:
                            return False
                        op[0] = 1
                        op[2] = 1
            return True

        @lru_cache(None)
        def get_min_time(rest_idx: tuple):
            if sum(rest_idx) == 0:
                return 0
            topick = [k for k, v in enumerate(rest_idx) if v &gt; 0]
            ans = math.inf
            for i in topick:
                tp = list(rest_idx)
                tp[i] -= 1
                ans1 = 1 + get_min_time(tuple(tp))
                ans = min(ans, ans1)
            for i in range(2, len(topick) + 1):
                for j in combinations(topick, i):
                    picked = j
                    e, s, w, n = &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;
                    if 0 in picked:
                        e = directions[0][len(directions[0]) - rest_idx[0]]
                    if 1 in picked:
                        s = directions[1][len(directions[1]) - rest_idx[1]]
                    if 2 in picked:
                        w = directions[2][len(directions[2]) - rest_idx[2]]
                    if 3 in picked:
                        n = directions[3][len(directions[3]) - rest_idx[3]]
                    ret1 = can_pass(e, s, w, n)
                    if ret1:
                        tp = list(rest_idx)
                        for x in picked:
                            tp[x] -= 1
                            ans1 = 1 + get_min_time(tuple(tp))
                            ans = min(ans, ans1)
            return ans

        ret = get_min_time(tuple(ll))
        return ret


a = Solution()
print(a.trafficCommand([&#34;NN&#34;,&#34;WE&#34;,&#34;EN&#34;,&#34;EW&#34;]))
# print(a.trafficCommand([&#34;S&#34;, &#34;W&#34;, &#34;N&#34;, &#34;E&#34;]))
# # print(a.trafficCommand(directions = [&#34;W&#34;,&#34;N&#34;,&#34;ES&#34;,&#34;W&#34;]))
# print(a.trafficCommand(directions=[&#34;NS&#34;, &#34;WE&#34;, &#34;SE&#34;, &#34;EW&#34;]))
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 4296 ms</p>
                    <p class="mb-0">内存: 58.8 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>该题解采用了递归加备忘录的方法来解决问题，涉及动态规划的思路。具体思路如下：首先，对每个方向的车辆数进行统计，并定义两个缓存函数。第一个缓存函数`can_pass`用于检查在不产生冲突的情况下哪些车可以同时通过交叉口。它使用了一个16位的数组来标记可能的冲突，并对每一种行驶方向的车辆进行冲突检查。第二个缓存函数`get_min_time`是主要的递归函数，用于计算清空路口所需的最短时间。它首先考虑一个车辆通过的情况，然后尝试所有可能的车辆组合，递归地计算通过剩余车辆所需的时间。这里使用了组合生成和对每种可能的行车情况进行模拟，通过调用`can_pass`来确保没有冲突。</p>
                        <p>时间复杂度: O(2^n)</p>
                        <p>空间复杂度: O(n + 4^n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">import math
from typing import List
from itertools import combinations
from functools import lru_cache


class Solution:
    def trafficCommand(self, directions: List[str]) -&gt; int:
        # 计算每个方向的车辆数
        ll = [len(i) for i in directions]

        # 使用备忘录优化，判断是否可通行
        @lru_cache(None)
        def can_pass(e, s, w, n):
            todo = {}
            op = [0] * 16 # 标记16种可能的车辆动作组合
            # 判断每个方向是否有车并转化为小写字母表示方向
            if e != &#39;&#39;:
                todo[&#39;e&#39;] = e.lower()
            if s != &#39;&#39;:
                todo[&#39;s&#39;] = s.lower()
            if w != &#39;&#39;:
                todo[&#39;w&#39;] = w.lower()
            if n != &#39;&#39;:
                todo[&#39;n&#39;] = n.lower()
            for i in todo:
                # 根据车辆的目标方向，检查是否会产生冲突
                # 例如东边的车向南行驶需要的路径是否被其他车辆占用
                if i == &#39;e&#39;:
                    if todo[i] == &#39;s&#39;:
                        if op[5] == 1 or op[8] == 1 or op[10] == 1 or op[15] == 1 or op[14] == 1:
                            return False # 如果路径已被占用则返回不可通行
                        op[5] = 1
                        op[8] = 1
                        op[10] = 1
                        op[15] = 1
                        op[14] = 1
                    # 同样的检查逻辑应用于其他方向和目标组合
                # 下面代码块遵循同样逻辑处理南、西、北方向的车辆

        # 计算最小通过时间的函数
        @lru_cache(None)
        def get_min_time(rest_idx: tuple):
            if sum(rest_idx) == 0:
                return 0 # 所有车辆已通过时返回0
            topick = [k for k, v in enumerate(rest_idx) if v &gt; 0] # 选择还有车辆的方向
            ans = math.inf
            # 单车通过
            for i in topick:
                tp = list(rest_idx)
                tp[i] -= 1
                ans1 = 1 + get_min_time(tuple(tp))
                ans = min(ans, ans1)
            # 尝试多车同时通过的情况，保证不冲突
            for i in range(2, len(topick) + 1):
                for j in combinations(topick, i):
                    picked = j
                    e, s, w, n = &#39;&#39;, &#39;&#39;, &#39;&#39;, &#39;&#39;
                    # 获取对应方向车辆的当前行驶方向
                    if 0 in picked:
                        e = directions[0][len(directions[0]) - rest_idx[0]]
                    if 1 in picked:
                        s = directions[1][len(directions[1]) - rest_idx[1]]
                    if 2 in picked:
                        w = directions[2][len(directions[2]) - rest_idx[2]]
                    if 3 in picked:
                        n = directions[3][len(directions[3]) - rest_idx[3]]
                    ret1 = can_pass(e, s, w, n) # 检查是否冲突
                    if ret1:
                        tp = list(rest_idx)
                        for x in picked:
                            tp[x] -= 1
                        ans1 = 1 + get_min_time(tuple(tp))
                        ans = min(ans, ans1)
            return ans

        ret = get_min_time(tuple(ll))
        return ret

# 示例调用
a = Solution()
print(a.trafficCommand([&#34;NN&#34;,&#34;WE&#34;,&#34;EN&#34;,&#34;EW&#34;]))
# print(a.trafficCommand([&#34;S&#34;, &#34;W&#34;, &#34;N&#34;, &#34;E&#34;]))
# # print(a.trafficCommand(directions = [&#34;W&#34;,&#34;N&#34;,&#34;ES&#34;,&#34;W&#34;]))
# print(a.trafficCommand(directions=[&#34;NS&#34;, &#34;WE&#34;, &#34;SE&#34;, &#34;EW&#34;]))
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>