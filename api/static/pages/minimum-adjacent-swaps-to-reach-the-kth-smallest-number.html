<!DOCTYPE html>
<html lang="zh">
<head>
    <title>邻位交换的最小次数</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">邻位交换的最小次数</strong>
                标签:
                
                    <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                
                    <a href="/problems?tag=two-pointers" class="badge bg-secondary tag-link">双指针</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList


def kthNextPermutation(
    nums: List[int], k: int, inplace=False, prev=False
) -&gt; Optional[List[int]]:
    &#34;&#34;&#34;下k个字典序的排列(可以存在重复元素)

    Args:
        nums: 原排列数组.
        k (int): 后续第k个(`本身算第0个`)字典序的排列.
        inplace (bool, optional): 是否原地修改. 默认为False.
        prev (bool, optional): 使用next还是prev. 默认使用next.

    Returns:
        Optional[List[int]]: 下k个字典序的排列,如果不存在,返回None.
    &#34;&#34;&#34;
    if not nums:
        return
    counter = Counter([nums[-1]])
    sl = (
        SortedList([nums[-1]])
        if not prev
        else SortedList([nums[-1]], key=lambda x: -x)
    )

    fac = 1
    facPtr = 1
    curPerm = 0
    overlap = 1  # 重复元素的个数的乘积
    allPerm = 1  # 后缀里的所有排列个数
    for right in range(len(nums) - 2, -1, -1):
        if curPerm + k &lt; allPerm:
            break
        num = nums[right]
        counter[num] += 1
        overlap *= counter[num]

        smaller = 0
        pos = sl.bisect_left(num)
        if pos == len(sl) or sl[pos] != num:  # set去重
            sl.add(num)
        for i, pre in enumerate(sl):
            if i &gt;= pos:
                break
            # for pre in sl.islice(0, pos):
            smaller += (fac * counter[pre]) // overlap

        facPtr += 1
        fac *= facPtr
        curPerm += smaller
        allPerm = fac // overlap

    if curPerm + k &gt;= allPerm:
        return

    res = []
    fac //= facPtr
    permCount = 0
    target = curPerm + k
    while permCount != target:
        for i, pre in enumerate(sl):
            curPerm = (fac * counter[pre]) // overlap  # 以当前元素开头的排列个数
            cand = permCount + curPerm
            if cand &lt;= target:
                permCount = cand
                continue
            facPtr -= 1
            fac //= facPtr
            overlap //= counter[pre]
            res.append(pre)
            counter[pre] -= 1
            if not counter[pre]:
                sl.pop(i)
            break

    for pre in sl:
        res += [pre] * counter[pre]
    if inplace:
        nums[-len(res) :] = res
        return nums
    return nums[: len(nums) - len(res)] + res


class BIT1:
    &#34;&#34;&#34;单点修改,区间和查询&#34;&#34;&#34;

    __slots__ = &#34;size&#34;, &#34;bit&#34;, &#34;tree&#34;

    def __init__(self, n: int):
        self.size = n
        self.bit = n.bit_length()
        self.tree = [0] * (n + 1)

    def add(self, index: int, delta: int) -&gt; None:
        # index 必须大于0
        while index &lt;= self.size:
            self.tree[index] += delta
            index += index &amp; -index

    def _query(self, index: int) -&gt; int:
        res = 0
        while index &gt; 0:
            res += self.tree[index]
            index -= index &amp; -index
        return res

    def query(self, left: int, right: int) -&gt; int:
        return self._query(right) - self._query(left - 1)


class Solution:
    def getMinSwaps(self, num: str, k: int) -&gt; int:
        n = len(num)
        arr = [*map(int, num)]
        brr = arr.copy()
        brr = kthNextPermutation(brr, k)
        idx = defaultdict(list)
        for i, b in enumerate(brr, 2):
            idx[b].append(i)
        cnt = defaultdict(int)
        al = []
        for a in arr:
            al.append(idx[a][cnt[a]])
            cnt[a] += 1
        bit = BIT1(n + 10)
        res = 0
        for i in al:
            res += bit.query(i + 1, n + 5)
            bit.add(i, 1)
        return res
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 116 ms</p>
                    <p class="mb-0">内存: 17.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>解决这个问题涉及两个主要步骤：1. 找到给定数字字符串的第k个字典序更大的排列。2. 计算从原始字符串到该排列通过相邻交换得到的最小次数。首先，使用&#39;kthNextPermutation&#39;函数来获取所需的排列，此函数实现了对给定数组的下一个排列算法，并能够处理有重复数字的情况。之后，利用索引映射和树状数组（Binary Indexed Tree, BIT），来计算把原数组转换到目标排列需要的最小交换次数。树状数组用于高效计算前缀和，以此来快速得出每次交换的次数。</p>
                        <p>时间复杂度: O(n log n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from collections import Counter, defaultdict
from typing import List, Optional

class BIT1:
    &#39;&#39;&#39;单点修改,区间和查询&#39;&#39;&#39;    
    def __init__(self, n: int):
        self.size = n
        self.bit = n.bit_length()
        self.tree = [0] * (n + 1)

    def add(self, index: int, delta: int) -&gt; None:
        while index &lt;= self.size:
            self.tree[index] += delta
            index += index &amp; -index

    def _query(self, index: int) -&gt; int:
        res = 0
        while index &gt; 0:
            res += self.tree[index]
            index -= index &amp; -index
        return res

    def query(self, left: int, right: int) -&gt; int:
        return self._query(right) - self._query(left - 1)

class Solution:
    def getMinSwaps(self, num: str, k: int) -&gt; int:
        n = len(num)
        arr = [*map(int, num)]
        brr = arr.copy()
        brr = kthNextPermutation(brr, k)
        idx = defaultdict(list)
        for i, b in enumerate(brr, 2):
            idx[b].append(i)
        cnt = defaultdict(int)
        al = []
        for a in arr:
            al.append(idx[a][cnt[a]])
            cnt[a] += 1
        bit = BIT1(n + 10)
        res = 0
        for i in al:
            res += bit.query(i + 1, n + 5)
            bit.add(i, 1)
        return res
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>