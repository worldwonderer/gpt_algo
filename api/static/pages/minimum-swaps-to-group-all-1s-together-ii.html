<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最少交换次数来组合所有的 1 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>最少交换次数来组合所有的 1 II</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=sliding-window" class="badge bg-secondary tag-link">滑动窗口</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p><strong>交换</strong> 定义为选中一个数组中的两个 <strong>互不相同</strong> 的位置并交换二者的值。</p>

<p><strong>环形</strong> 数组是一个数组，可以认为 <strong>第一个</strong> 元素和 <strong>最后一个</strong> 元素 <strong>相邻</strong> 。</p>

<p>给你一个 <strong>二进制环形</strong> 数组 <code>nums</code> ，返回在 <strong>任意位置</strong> 将数组中的所有 <code>1</code> 聚集在一起需要的最少交换次数。</p>



<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>nums = [0,1,0,1,1,0,0]
<strong>输出：</strong>1
<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：
[0,<strong><em>0</em></strong>,<em><strong>1</strong></em>,1,1,0,0] 交换 1 次。
[0,1,<em><strong>1</strong></em>,1,<em><strong>0</strong></em>,0,0] 交换 1 次。
[1,1,0,0,0,0,1] 交换 2 次（利用数组的环形特性）。
无法在交换 0 次的情况下将数组中的所有 1 聚集在一起。
因此，需要的最少交换次数为 1 。
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>nums = [0,1,1,1,0,0,1,1,0]
<strong>输出：</strong>2
<strong>解释：</strong>这里列出一些能够将所有 1 聚集在一起的方案：
[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。
[1,1,1,1,1,0,0,0,0] 交换 2 次。
无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。
因此，需要的最少交换次数为 2 。
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>nums = [1,1,0,0,1]
<strong>输出：</strong>0
<strong>解释：</strong>得益于数组的环形特性，所有的 1 已经聚集在一起。
因此，需要的最少交换次数为 0 。</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>
	<li><code>nums[i]</code> 为 <code>0</code> 或者 <code>1</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 85 ms</p>
                    <p>内存: 21.0 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def minSwaps(self, nums: List[int]) -&gt; int:
        n, cnt, nums = len(nums), nums.count(1), nums * 2
        ans = cnt_ = sum(nums[:cnt])
        for i in range(n):
            if nums[i] != nums[i + cnt]:
                cnt_ += nums[i + cnt] - nums[i]
                ans = max(ans, cnt_)
        return cnt - ans
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>The solution uses a sliding window approach. First, it counts the number of 1s in the array and duplicates the array to handle the circular nature. Then, it creates a window of size equal to the number of 1s and slides it across the array to find the maximum number of 1s that can be gathered in one window. The minimum number of swaps is then calculated by subtracting this maximum from the total count of 1s.</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2">class Solution:
    def minSwaps(self, nums: List[int]) -&gt; int:
        n, cnt, nums = len(nums), nums.count(1), nums * 2  # Duplicate the array
        ans = cnt_ = sum(nums[:cnt])  # Initialize the window
        for i in range(n):
            if nums[i] != nums[i + cnt]:
                cnt_ += nums[i + cnt] - nums[i]  # Update the count of 1s in the window
                ans = max(ans, cnt_)
        return cnt - ans  # Calculate the minimum swaps</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            为什么先统计数组中`1`的数量再将数组翻倍，翻倍的目的是什么？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>首先统计数组中`1`的数量是为了确定滑动窗口的大小，这个大小等于1的总数量，因为我们的目标是尽可能地将所有的1集中到一个连续的区域中。数组翻倍是因为这个问题的数组是环形的，翻倍后可以简化环形数组边界条件的处理。通过翻倍，原本环形的结构被线性化，使得可以用常规的滑动窗口方法来处理可能跨越数组起始和结束边界的情况。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在使用滑动窗口法时，如何处理环形数组的边界条件？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在处理环形数组的边界条件时，通过将数组翻倍来模拟环形结构。这样，可以在一个长度为2倍原数组长度的线性数组上应用滑动窗口，而不必担心窗口跨越数组的起始和结束边界。滑动窗口只需在长度为原数组长度的范围内移动，从而能够覆盖所有可能的连续区域，包括那些跨越原数组边界的区域。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            在计算滑动窗口中的1的数量时，为什么通过`cnt_ += nums[i + cnt] - nums[i]`更新计数，这种更新方式的正确性如何保证？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>这种更新计数的方法是基于滑动窗口的性质。当窗口向右滑动一位时，窗口最左边的元素（nums[i]）会被移出窗口，而紧接在窗口最右边的下一个元素（nums[i + cnt]）将进入窗口。因此，更新1的数量就是简单地加上新进入窗口的元素值（nums[i + cnt]，如果是1就加1，是0就加0），并减去移出窗口的元素值（nums[i]）。这样可以快速计算出新窗口中1的总数量，而无需重新遍历整个窗口。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            请解释为什么最少交换次数是通过`cnt - ans`计算得到的？这里的`ans`代表什么？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>`ans`在此题解中代表在任意连续的由`cnt`个元素组成的窗口中，能够找到的最大的1的数量。因此，`cnt - ans`就是在最优情况下，即1已经尽可能多地聚集在一起时，窗口中还需要通过交换添加的1的数量，这也就是最少需要进行的交换次数。这是因为如果一个窗口已经包含了尽可能多的1，那么窗口外剩余的1就需要与窗口内的0进行交换，以实现所有1的聚集。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/minimum-swaps-to-group-all-1s-together-ii')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/minimum-swaps-to-group-all-1s-together-ii/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>