<!DOCTYPE html>
<html lang="zh">
<head>
    <title>查找包含给定字符的单词</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>查找包含给定字符的单词</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Easy</span></p>
                
                    <div class="problem-description">
                        <p>给你一个下标从 <strong>0</strong>&nbsp;开始的字符串数组&nbsp;<code>words</code>&nbsp;和一个字符&nbsp;<code>x</code>&nbsp;。</p>

<p>请你返回一个 <strong>下标数组</strong>&nbsp;，表示下标在数组中对应的单词包含字符 <code>x</code>&nbsp;。</p>

<p><b>注意</b>&nbsp;，返回的数组可以是&nbsp;<strong>任意</strong>&nbsp;顺序。</p>



<p><strong class="example">示例 1：</strong></p>

<pre>
<b>输入：</b>words = ["leet","code"], x = "e"
<b>输出：</b>[0,1]
<b>解释：</b>"e" 在两个单词中都出现了："l<em><strong>ee</strong></em>t" 和 "cod<em><strong>e</strong></em>" 。所以我们返回下标 0 和 1 。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<b>输入：</b>words = ["abc","bcd","aaaa","cbc"], x = "a"
<b>输出：</b>[0,2]
<b>解释：</b>"a" 在 "<em><strong>a</strong></em>bc" 和 "<em><strong>aaaa</strong></em>" 中出现了，所以我们返回下标 0 和 2 。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<b>输入：</b>words = ["abc","bcd","aaaa","cbc"], x = "z"
<b>输出：</b>[]
<b>解释：</b>"z" 没有在任何单词中出现。所以我们返回空数组。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= words.length &lt;= 50</code></li>
	<li><code>1 &lt;= words[i].length &lt;= 50</code></li>
	<li><code>x</code>&nbsp;是一个小写英文字母。</li>
	<li><code>words[i]</code>&nbsp;只包含小写英文字母。</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 20 ms</p>
                    <p>内存: 16.6 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def findWordsContaining(self, words: List[str], x: str) -&gt; List[int]:
        return [i for i in range(len(words)) if x in words[i]]</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>题解通过使用列表推导来遍历字符串数组 `words`，对于每一个索引 `i` 和对应的单词，检查字符 `x` 是否存在于该单词中。如果存在，就将索引 `i` 添加到结果列表中。这种方法直接利用了 Python 的 `in` 关键字来进行成员检查，因此非常简洁且易于理解。</p>
                                <p>时间复杂度: O(n * m)</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2">class Solution:
    def findWordsContaining(self, words: List[str], x: str) -&gt; List[int]:
        # 使用列表推导式遍历所有单词，并检查每个单词是否包含字符 x
        return [i for i in range(len(words)) if x in words[i]]</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在某些特定情况下，如数组words非常大或单词长度非常长时，使用列表推导可能会导致内存错误。是否有其他内存效率更高的方法来处理此问题？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>当处理非常大的数据时，使用列表推导可能会消耗大量内存，因为它会一次性生成一个完整的列表。为了提高内存效率，可以使用生成器表达式代替列表推导。生成器表达式不会一次性生成所有结果，而是按需生成每个结果，从而节省内存。在函数中，可以返回一个生成器对象而非列表，或者逐个处理并输出结果。例如：

python
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -&gt; Iterator[int]:
        return (i for i in range(len(words)) if x in words[i])


这样调用者可以通过迭代返回的生成器来逐个获取结果，而不是一次性加载到内存中。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            题解未考虑字符x不在任何单词中的情况，这是否会影响函数输出或应该在实现中考虑这种情况？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在当前的实现中，如果字符 `x` 不在任何单词中，列表推导式将不会找到任何匹配项，因此返回一个空列表。这本身就是一个合理的行为，因为它正确地表示没有单词包含给定的字符。通常，返回空列表是处理此类情况的有效方法，因为它既明确又能够通过返回值的长度给调用者正确的信号。因此，不需要额外的逻辑来特别处理这种情况。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            如果字符x是特殊字符或有大小写敏感的需求，题解的方法是否需要调整？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果需要处理特殊字符或考虑大小写敏感的情况，可以在检查 `x` 是否在单词中之前添加相应的处理逻辑。例如，如果需要忽视大小写，可以在比较之前将单词和字符 `x` 都转换为同样的大小写形式（全部大写或全部小写）。对于特殊字符，根据具体需求可能需要进行适当的转义或编码。示例代码如下：

python
class Solution:
    def findWordsContaining(self, words: List[str], x: str) -&gt; List[int]:
        x = x.lower()  # 将搜索字符转换为小写
        return [i for i in range(len(words)) if x in words[i].lower()]  # 同时将单词转换为小写进行比较


这种方法使函数更加灵活且适应多种情况。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/find-words-containing-character')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/find-words-containing-character/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>