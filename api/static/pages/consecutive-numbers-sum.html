<!DOCTYPE html>
<html lang="zh">
<head>
    <title>连续整数求和</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">连续整数求和</strong>
                标签:
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=enumeration" class="badge bg-secondary tag-link">枚举</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">import copy
import collections

class Solution:
    def consecutiveNumbersSum(self, n: int) -&gt; int:
        prime_factors=collections.defaultdict(int)## 字典用来存储所有质因数，key是质因数，value是质因数的次数
        K=2*n
        b=2
        while b**2&lt;=K:
            if not K % b:
                prime_factors[b]+=1
                K//=b# 若是，则把质数b从K中拿出，保证了后面的b只可能是质数
            else:
                b+=1
        prime_factors[K]+=1 #最后剩下的K是2N的最大质因数
        factors = []  ## 列表用来存储所有因数
        def traceback(component,prime_factors):
            if not prime_factors:
                factors.append(component)## 把所有的因数记录下来
            else:
                dic=copy.deepcopy(prime_factors)
                item=dic.popitem()## 从字典里取出一个质因数（一个tuple键值对）
                for i in range(item[1]+1):
                    traceback(component*item[0]**i,dic) ## 对于这个质因数，考虑其在因数中可以出现的次数，最少0次，最多item[1]次
        traceback(1,prime_factors)
        res=0
        for factor in factors:
            if factor ** 2&lt;2*n and ((2*n)//factor-factor)%2:
                res+=1
        return res

</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 51 ms</p>
                    <p class="mb-0">内存: 16.3 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解利用了数学和因数分解的方法来解决问题。首先，题解考虑了将输入的 n 扩大两倍至 2*n，并试图分解这个数字的所有因数。解题核心在于分解出所有可能的因数组合，并从中判定那些因数可以通过一个特定的公式来表示连续整数之和等于原始的 n。通过一种深度优先搜索的方式，生成 2*n 的所有因数，然后对这些因数进行检查，看它们是否能形成连续整数序列的和。具体来说，如果某个因数 x 使得 (2*n // x - x) 是奇数，那么这个 x 可以构成一个解。这是因为可以通过解方程组得出连续整数的起点和终点来检查 x 是否为有效因数。</p>
                        <p>时间复杂度: O(sqrt(K))，其中 K = 2*n</p>
                        <p>空间复杂度: O(sqrt(K) + log(K))</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">import copy
import collections

class Solution:
    def consecutiveNumbersSum(self, n: int) -&gt; int:
        prime_factors = collections.defaultdict(int)  # 存储所有质因数
        K = 2 * n
        b = 2
        while b ** 2 &lt;= K:
            if not K % b:
                prime_factors[b] += 1
                K //= b
            else:
                b += 1
        prime_factors[K] += 1  # 最后剩下的K是2N的最大质因数
        factors = []  # 存储所有因数
        def traceback(component, prime_factors):
            if not prime_factors:
                factors.append(component)  # 记录因数
            else:
                dic = copy.deepcopy(prime_factors)
                item = dic.popitem()  # 取出一个质因数
                for i in range(item[1] + 1):
                    traceback(component * item[0] ** i, dic)
        traceback(1, prime_factors)
        res = 0
        for factor in factors:
            if factor ** 2 &lt; 2 * n and ((2 * n) // factor - factor) % 2:
                res += 1
        return res
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>