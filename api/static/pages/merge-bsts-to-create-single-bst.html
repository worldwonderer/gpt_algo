<!DOCTYPE html>
<html lang="zh">
<head>
    <title>合并多棵二叉搜索树</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>合并多棵二叉搜索树</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=tree" class="badge bg-secondary tag-link">树</a>
                    
                        <a href="/problems?tag=depth-first-search" class="badge bg-secondary tag-link">深度优先搜索</a>
                    
                        <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                    
                        <a href="/problems?tag=binary-search" class="badge bg-secondary tag-link">二分查找</a>
                    
                        <a href="/problems?tag=binary-tree" class="badge bg-secondary tag-link">二叉树</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Hard</span></p>
                
                    <div class="problem-description">
                        <p>给你 <code>n</code> 个 <strong>二叉搜索树的根节点</strong> ，存储在数组 <code>trees</code> 中（<strong>下标从 0 开始</strong>），对应 <code>n</code> 棵不同的二叉搜索树。<code>trees</code> 中的每棵二叉搜索树 <strong>最多有 3 个节点</strong> ，且不存在值相同的两个根节点。在一步操作中，将会完成下述步骤：</p>

<ul>
	<li>选择两个 <strong>不同的</strong> 下标 <code>i</code> 和 <code>j</code> ，要求满足在&nbsp;<code>trees[i]</code> 中的某个 <strong>叶节点</strong> 的值等于&nbsp;<code>trees[j]</code> 的 <strong>根节点的值</strong> 。</li>
	<li>用&nbsp;<code>trees[j]</code> 替换 <code>trees[i]</code> 中的那个叶节点。</li>
	<li>从 <code>trees</code> 中移除 <code>trees[j]</code> 。</li>
</ul>

<p>如果在执行 <code>n - 1</code> 次操作后，能形成一棵有效的二叉搜索树，则返回结果二叉树的 <strong>根节点</strong> ；如果无法构造一棵有效的二叉搜索树<em>，</em>返回<em> </em><code>null</code> 。</p>

<p>二叉搜索树是一种二叉树，且树中每个节点均满足下述属性：</p>

<ul>
	<li>任意节点的左子树中的值都 <strong>严格小于</strong>&nbsp;此节点的值。</li>
	<li>任意节点的右子树中的值都 <strong>严格大于</strong>&nbsp;此节点的值。</li>
</ul>

<p>叶节点是不含子节点的节点。</p>



<p><strong>示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d1.png" />
<pre>
<strong>输入：</strong>trees = [[2,1],[3,2,5],[5,4]]
<strong>输出：</strong>[3,2,5,1,null,4]
<strong>解释：</strong>
第一步操作中，选出 i=1 和 j=0 ，并将 trees[0] 合并到 trees[1] 中。
删除 trees[0] ，trees = [[3,2,5,1],[5,4]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram.png" />
在第二步操作中，选出 i=0 和 j=1 ，将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[3,2,5,1,null,4]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-2.png" />
结果树如上图所示，为一棵有效的二叉搜索树，所以返回该树的根节点。</pre>

<p><strong>示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d2.png" />
<pre>
<strong>输入：</strong>trees = [[5,3,8],[3,2,6]]
<strong>输出：</strong>[]
<strong>解释：</strong>
选出 i=0 和 j=1 ，然后将 trees[1] 合并到 trees[0] 中。
删除 trees[1] ，trees = [[5,3,8,2,6]] 。
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/24/diagram-3.png" />
结果树如上图所示。仅能执行一次有效的操作，但结果树不是一棵有效的二叉搜索树，所以返回 null 。
</pre>

<p><strong>示例 3：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2021/06/08/d3.png" />
<pre>
<strong>输入：</strong>trees = [[5,4],[3]]
<strong>输出：</strong>[]
<strong>解释：</strong>无法执行任何操作。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>n == trees.length</code></li>
	<li><code>1 &lt;= n &lt;= 5 * 10<sup>4</sup></code></li>
	<li>每棵树中节点数目在范围 <code>[1, 3]</code> 内。</li>
	<li>输入数据的每个节点可能有子节点但不存在子节点的子节点</li>
	<li><code>trees</code> 中不存在两棵树根节点值相同的情况。</li>
	<li>输入中的所有树都是 <strong>有效的二叉树搜索树</strong> 。</li>
	<li><code>1 &lt;= TreeNode.val &lt;= 5 * 10<sup>4</sup></code>.</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 1292 ms</p>
                    <p>内存: 43.4 MB</p>
                    <pre class="bg-light p-2 code-pre"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def canMerge(self, trees: List[TreeNode]) -&gt; Optional[TreeNode]:
        # 创建一个集合，用于存储所有出现在二叉树中作为叶子的节点的值
        leaves = set()
        # 创建一个字典，用于存储以树的根节点的值为键，对应树为值的键值对
        candidates = dict()
        for tree in trees:
            # 遍历所有树，把所有的左右孩子节点的值加入叶子集合，同时记录根节点和树的映射
            if tree.left:
                leaves.add(tree.left.val)
            if tree.right:
                leaves.add(tree.right.val)
            candidates[tree.val] = tree
        
        # 这个变量用于在中序遍历过程中存储前一个节点的值，以检查二叉搜索树的有效性
        prev = float(&#34;-inf&#34;)
        
        # 定义中序遍历函数，用递归方式进行
        def dfs(tree: Optional[TreeNode]) -&gt; bool:
            
            if not tree:
                return True
            
            # 如果当前节点是叶子节点，并且在候选树中，进行合并操作
            if not tree.left and not tree.right and tree.val in candidates:
                # 合并完成后，将树丛哈希映射中移除，以便于在遍历结束后判断是否所有树都被遍历过
                merged_tree = candidates.pop(tree.val)
                tree.left = merged_tree.left
                tree.right = merged_tree.right
            
            # 递归检查左子树，如果左子树不满足条件，返回False
            if not dfs(tree.left):
                return False

            # 再遍历当前节点
            nonlocal prev

            # 检查当前节点是否满足二叉搜索树的条件
            if tree.val &lt;= prev:
                return False

            prev = tree.val
            # 递归检查右子树，如果右子树不满足条件，返回False
            return dfs(tree.right)
        
        # 从所有树中找到唯一一个可能的根节点，即它的值没有在叶子集合中出现过
        for tree in trees:
            if tree.val not in leaves:
                # 从候选树中移除根节点，避免重复合并
                candidates.pop(tree.val)
                # 如果中序遍历有严格单调性，并且所有树的根节点都被遍历到，说明可以构造二叉搜索树
                return tree if dfs(tree) and not candidates else None

        return None</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>题解的策略主要是将所有树的根节点和叶子节点分别存储，通过查找唯一的根节点，然后尝试合并其他树作为其叶子节点。利用中序遍历保证合并后的树仍为有效的二叉搜索树（BST）。具体步骤为：1. 存储所有可能的叶子节点和根节点到相应的集合和字典中。2. 通过中序遍历的方式检查并合并树，使用递归方法在遍历过程中不断尝试用其他树替换叶子节点。3. 检查最终合并后的树是否符合BST的条件并确保所有树都已合并。</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def canMerge(self, trees: List[TreeNode]) -&gt; Optional[TreeNode]:
        leaves = set()  # 存储作为叶子节点的值
        candidates = dict()  # 存储树的根节点值与树的映射
        for tree in trees:
            if tree.left:
                leaves.add(tree.left.val)
            if tree.right:
                leaves.add(tree.right.val)
            candidates[tree.val] = tree
        prev = float(&#39;-inf&#39;)  # 用于中序遍历的前一个节点值比较
        def dfs(tree: Optional[TreeNode]) -&gt; bool:
            nonlocal prev
            if not tree:
                return True
            if not tree.left and not tree.right and tree.val in candidates:
                merged_tree = candidates.pop(tree.val)
                tree.left = merged_tree.left
                tree.right = merged_tree.right
            if not dfs(tree.left):
                return False
            if tree.val &lt;= prev:
                return False
            prev = tree.val
            return dfs(tree.right)
        for tree in trees:
            if tree.val not in leaves:
                candidates.pop(tree.val)
                return tree if dfs(tree) and not candidates else None
        return None</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在解题策略中，为何需要将所有可能的叶子节点存储在一个集合中，而根节点则存储在字典中？这种数据结构的选择对算法有何影响？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在合并多棵二叉搜索树的问题中，区分根节点和叶子节点是关键。使用集合存储叶子节点的值能够快速判断一个节点是否可能被其他树合并（即判断一个值是否仅为叶子节点）。使用字典存储根节点则是为了能够快速通过根节点的值找到对应的树，这对于尝试将一棵树合并到另一棵树的指定位置是必需的。这种数据结构的选择使得算法能够迅速地进行根节点和叶子节点的查找和比对，提高了合并的效率，同时也便于在后续中序遍历过程中进行树的替换和验证。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            题解中提到使用递归方法中序遍历进行树的合并检查，为何选择中序遍历而非其他类型的遍历方式？中序遍历在这个问题中有什么特别的优势？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>中序遍历（Left, Root, Right）对于二叉搜索树（BST）特别有用，因为它可以按照升序访问所有节点。在这个问题中，使用中序遍历可以逐步访问树中的每个节点，并与之前访问的节点的值进行比较，以确保所有的节点都按照二叉搜索树的要求正确排序（即每个节点的值都应该大于前一个访问的节点的值）。这种遍历方式自然而然地验证了BST的性质，而且由于其递归的性质，易于在遍历过程中进行合并操作。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解中提到如果中序遍历过程中发现当前节点的值不大于前一个节点的值，则返回False。这个判断条件是如何保证BST属性的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在二叉搜索树（BST）中，任意节点的左子树中的所有节点的值都应小于该节点的值，而右子树中的所有节点的值都应大于该节点的值。中序遍历的特点是，对于BST，它应当输出一个严格递增的值序列。因此，在中序遍历过程中，如果发现当前节点的值不大于前一个访问的节点的值，这意味着树的这部分不满足BST的性质，因此返回False。这一判断确保了在合并过程中，合并后的树依然保持BST的所有条件。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/merge-bsts-to-create-single-bst')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/merge-bsts-to-create-single-bst/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>