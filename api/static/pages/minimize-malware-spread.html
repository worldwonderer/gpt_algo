<!DOCTYPE html>
<html lang="zh">
<head>
    <title>尽量减少恶意软件的传播</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>尽量减少恶意软件的传播</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=depth-first-search" class="badge bg-secondary tag-link">深度优先搜索</a>
                    
                        <a href="/problems?tag=breadth-first-search" class="badge bg-secondary tag-link">广度优先搜索</a>
                    
                        <a href="/problems?tag=union-find" class="badge bg-secondary tag-link">并查集</a>
                    
                        <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                    
                        <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Hard</span></p>
                
                    <div class="problem-description">
                        <p>给出了一个由 <code>n</code> 个节点组成的网络，用 <code>n × n</code> 个邻接矩阵图<meta charset="UTF-8" />&nbsp;<code>graph</code>&nbsp;表示。在节点网络中，当 <code>graph[i][j] = 1</code>&nbsp;时，表示节点&nbsp;<code>i</code>&nbsp;能够直接连接到另一个节点 <code>j</code>。&nbsp;</p>

<p>一些节点&nbsp;<code>initial</code>&nbsp;最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</p>

<p>假设 <code>M(initial)</code> 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</p>

<p>如果从&nbsp;<code>initial</code>&nbsp;中<strong>移除某一节点</strong>能够最小化 <code>M(initial)</code>， 返回该节点。如果有多个节点满足条件，就返回<strong>索引最小</strong>的节点。</p>

<p>请注意，如果某个节点已从受感染节点的列表 <code>initial</code> 中删除，它以后仍有可能因恶意软件传播而受到感染。</p>



<ol>
</ol>

<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
<strong>输出：</strong>0
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
<strong>输出：</strong>0
</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
<strong>输出：</strong>1
</pre>



<p><strong>提示：</strong></p>
<meta charset="UTF-8" />

<ul>
	<li><code>n == graph.length</code></li>
	<li><code>n == graph[i].length</code></li>
	<li><code>2 &lt;= n &lt;= 300</code></li>
	<li><code>graph[i][j]&nbsp;==&nbsp;0</code>&nbsp;或&nbsp;<code>1</code>.</li>
	<li><code>graph[i][j] == graph[j][i]</code></li>
	<li><code>graph[i][i] == 1</code></li>
	<li><code>1 &lt;= initial.length &lt;= n</code></li>
	<li><code>0 &lt;= initial[i] &lt;= n - 1</code></li>
	<li><code>initial</code>&nbsp;中所有整数均<strong>不重复</strong></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 84 ms</p>
                    <p>内存: 19.4 MB</p>
                    <pre class="bg-light p-2 code-pre">class UnionFind:
    def __init__(self,graph):
        self.root = [n for n in range(len(graph))]
        self.size = [1]*len(graph)
    
    def find(self,i):
        while(i!=self.root[i]):
            i = self.root[i]
        return self.root[i]
    def Union(self,i,j):
        root1 = self.find(i)
        root2 = self.find(j)
        if root1==root2:
            return
        self.root[root1] = root2
        self.size[root2]+=self.size[root1]
    def getsize(self,i):
        return self.size[i]
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int:
        m = len(graph)
        uf = UnionFind(graph)
        for i in range(m):
            for j in range(i):
                if graph[i][j]:
                    uf.Union(i,j)
        count = Counter(uf.find(x) for x in initial)
        res = [-1,min(initial)]
        for node in initial:
            root = uf.find(node)
            if count[root]==1:
                if uf.getsize(root)&gt;res[0]:
                    res = [uf.getsize(root),node]
                elif uf.getsize(root)==res[0] and node&lt;res[1]:
                    res[1] = node

        return res[1]
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题解使用了并查集来解决问题。首先根据图构建并查集，将所有连通的节点合并到同一个集合中。然后遍历初始感染节点列表initial，统计每个集合的感染节点数量。如果某个集合只有一个感染节点，就计算删除该节点后能减少感染的节点数，同时更新能减少最多感染节点数的节点索引。最后返回能减少最多感染节点数且索引最小的节点。</p>
                                <p>时间复杂度: O(n^2 + m)</p>
                                <p>空间复杂度: O(n + m)</p>
                                <pre class="bg-light p-2">class UnionFind:
    def __init__(self, graph):
        self.root = [n for n in range(len(graph))]  # 初始化节点的根节点为自身
        self.size = [1] * len(graph)  # 初始化每个集合的大小为1
    
    def find(self, i):
        # 查找节点i所在集合的根节点
        while i != self.root[i]:
            i = self.root[i]
        return self.root[i]

    def Union(self, i, j):
        # 合并节点i和节点j所在的集合
        root1 = self.find(i)
        root2 = self.find(j)
        if root1 == root2:
            return
        self.root[root1] = root2
        self.size[root2] += self.size[root1]

    def getsize(self, i):
        # 获取节点i所在集合的大小
        return self.size[i]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -&gt; int:
        m = len(graph)
        uf = UnionFind(graph)
        for i in range(m):
            for j in range(i):
                if graph[i][j]:
                    uf.Union(i, j)  # 将所有连通的节点合并到同一个集合
        count = Counter(uf.find(x) for x in initial)  # 统计每个集合的感染节点数量
        res = [-1, min(initial)]  # 初始化结果，第一个元素为最大减少感染节点数，第二个元素为对应的节点索引
        for node in initial:
            root = uf.find(node)
            if count[root] == 1:  # 如果该集合只有一个感染节点
                if uf.getsize(root) &gt; res[0]:  # 如果删除该节点能减少更多感染节点数
                    res = [uf.getsize(root), node]  # 更新结果
                elif uf.getsize(root) == res[0] and node &lt; res[1]:  # 如果减少相同数量的感染节点，选择索引更小的节点
                    res[1] = node
        return res[1]  # 返回能减少最多感染节点数且索引最小的节点
</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在并查集中，如何处理可能存在的多个连通分量，特别是当它们被不同数量的初始感染节点连接时？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在并查集中处理多个连通分量时，首先通过遍历图中的每条边来合并节点，将属于同一个连通分量的节点合并到同一个集合中。对于初始感染节点，我们通过遍历这些节点并使用并查集的`find`方法来确定每个节点所属的集合。然后，我们统计每个集合中初始感染节点的数量。即使集合被不同数量的初始感染节点连接，这种方法也能正确地识别并统计每个集合内的感染节点数量，从而在后续步骤中做出相应的处理决策。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            并查集中合并操作的具体实现（Union 方法）是否考虑了按秩合并，以优化性能？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中的并查集的`Union`方法没有明确实现按秩合并。在题解的实现中，当两个节点合并时，简单地将一个集合的根指向另一个集合的根，并更新大小。这种方法可能导致不平衡的树结构，从而影响操作的效率。按秩合并或路径压缩技术可以显著优化并查集操作的性能，特别是在处理大规模数据时，这两种技术能够保持树的高度较低，从而使查找操作更快。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解中提到的`统计每个集合的感染节点数量`的方法是否能准确区分不同集合中的感染节点，即如何确保计数的准确性？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中通过使用`Counter`字典来统计每个集合的感染节点数量，这种方法依赖于并查集的`find`函数来识别每个初始感染节点所属的集合。只要`find`函数能够准确地返回每个节点的根节点，就可以确保每个初始感染节点被正确归类到其所在的集合。因此，计数的准确性主要取决于并查集的正确实现和维护。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            您提到如果一个集合中只有一个感染节点，删除它将减少该集合的感染节点数。那么如果一个集合中有多个感染节点，删除任何一个是否会影响其它节点的感染状态？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果一个集合中有多个感染节点，删除其中一个感染节点通常不会影响其他节点的感染状态，因为剩余的感染节点仍然可以维持集合内的感染。在这种情况下，删除一个感染节点不会减少集合的总感染节点数，因为集合中仍然存在其他感染源。因此，在有多个感染节点的集合中，选择删除哪个节点应该基于其他标准，如节点的网络位置或节点的重要性。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/minimize-malware-spread')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/minimize-malware-spread/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>