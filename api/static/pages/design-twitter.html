<!DOCTYPE html>
<html lang="zh">
<head>
    <title>设计推特</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">设计推特</strong>
                标签:
                
                    <a href="/problems?tag=design" class="badge bg-secondary tag-link">设计</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=linked-list" class="badge bg-secondary tag-link">链表</a>
                
                    <a href="/problems?tag=heap-priority-queue" class="badge bg-secondary tag-link">堆（优先队列）</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">import time
import heapq
from collections import defaultdict


class Tweet:

    def __init__(self, _id, ts, _next=None):
        self.id = _id
        self.ts = ts
        self.next = _next


class Twitter:

    def __init__(self):
        &#34;&#34;&#34;
        Initialize your data structure here.--
        &#34;&#34;&#34;
        self.follow_relation = defaultdict(set)
        self.user_tweets = dict()

    def postTweet(self, userId: int, tweetId: int) -&gt; None:
        &#34;&#34;&#34;
        Compose a new tweet.
        &#34;&#34;&#34;
        head = self.user_tweets.get(userId)
        if head is None:
            new_head = Tweet(tweetId, time.time_ns())
        else:
            new_head = Tweet(tweetId, time.time_ns(), _next=head)
        self.user_tweets[userId] = new_head

    def getNewsFeed(self, userId: int) -&gt; List[int]:
        &#34;&#34;&#34;
        Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.
        &#34;&#34;&#34;
        h = []
        for followeeId in self.follow_relation[userId]:
            if followeeId in self.user_tweets:
                head = self.user_tweets[followeeId]
                heapq.heappush(h, (-head.ts, head))

        if userId in self.user_tweets:
            head = self.user_tweets[userId]
            heapq.heappush(h, (-head.ts, head))

        ret = []
        while h:
            _, tweet = heapq.heappop(h)
            ret.append(tweet.id)
            if len(ret) == 10:
                return ret
            if tweet.next:
                heapq.heappush(h, (-tweet.next.ts, tweet.next))
        return ret

    def follow(self, followerId: int, followeeId: int) -&gt; None:
        &#34;&#34;&#34;
        Follower follows a followee. If the operation is invalid, it should be a no-op.
        &#34;&#34;&#34;
        if followeeId == followerId:
            return

        self.follow_relation[followerId].add(followeeId)

    def unfollow(self, followerId: int, followeeId: int) -&gt; None:
        &#34;&#34;&#34;
        Follower unfollows a followee. If the operation is invalid, it should be a no-op.
        &#34;&#34;&#34;
        self.follow_relation[followerId].discard(followeeId)


# Your Twitter object will be instantiated and called as such:
# obj = Twitter()
# obj.postTweet(userId,tweetId)
# param_2 = obj.getNewsFeed(userId)
# obj.follow(followerId,followeeId)
# obj.unfollow(followerId,followeeId)
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 32 ms</p>
                    <p class="mb-0">内存: 14.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>该题解使用了哈希表和堆来实现一个简化版的推特系统。具体思路如下：
1. 用户与关注者的关系使用哈希表 follow_relation 存储，其中 key 为用户 ID，value 为该用户关注的用户 ID 集合。
2. 用户发布的推文使用哈希表 user_tweets 存储，其中 key 为用户 ID，value 为该用户发布的推文链表的头节点。
3. 发布推文时，创建一个新的推文节点，将其插入到对应用户的推文链表头部。
4. 获取用户的新闻推送时，遍历该用户关注的所有用户（包括自己），将他们的最新推文加入到一个最大堆中，堆的排序依据为推文的时间戳。
5. 从最大堆中依次取出最多 10 条最新的推文 ID，存入结果列表并返回。
6. 关注/取消关注操作通过修改 follow_relation 哈希表实现。</p>
                        <p>时间复杂度: postTweet: O(1)
getNewsFeed: O(NlogM)，其中 N 为关注人数，M 为推文总数
follow: O(1)
unfollow: O(1)</p>
                        <p>空间复杂度: O(F+T)，其中 F 为关注关系总数，T 为推文总数</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">import time
import heapq
from collections import defaultdict


class Tweet:

    def __init__(self, _id, ts, _next=None):
        self.id = _id
        self.ts = ts
        self.next = _next


class Twitter:

    def __init__(self):
        &#34;&#34;&#34;
        Initialize your data structure here.
        &#34;&#34;&#34;
        self.follow_relation = defaultdict(set)  # 用户关注关系哈希表
        self.user_tweets = dict()  # 用户推文哈希表

    def postTweet(self, userId: int, tweetId: int) -&gt; None:
        &#34;&#34;&#34;
        Compose a new tweet.
        &#34;&#34;&#34;
        head = self.user_tweets.get(userId)
        if head is None:
            new_head = Tweet(tweetId, time.time_ns())  # 创建新推文节点
        else:
            new_head = Tweet(tweetId, time.time_ns(), _next=head)  # 创建新推文节点并将其插入链表头部
        self.user_tweets[userId] = new_head  # 更新用户推文哈希表

    def getNewsFeed(self, userId: int) -&gt; List[int]:
        &#34;&#34;&#34;
        Retrieve the 10 most recent tweet ids in the user&#39;s news feed. Each item in the news feed must be posted by users who the user followed or by the user herself. Tweets must be ordered from most recent to least recent.
        &#34;&#34;&#34;
        h = []
        for followeeId in self.follow_relation[userId]:  # 遍历关注的用户
            if followeeId in self.user_tweets:
                head = self.user_tweets[followeeId]
                heapq.heappush(h, (-head.ts, head))  # 将关注用户的最新推文加入堆

        if userId in self.user_tweets:  # 将自己的最新推文也加入堆
            head = self.user_tweets[userId]
            heapq.heappush(h, (-head.ts, head))

        ret = []
        while h:
            _, tweet = heapq.heappop(h)  # 从堆中取出时间戳最大的推文
            ret.append(tweet.id)
            if len(ret) == 10:  # 最多返回 10 条推文
                return ret
            if tweet.next:  # 将下一条推文加入堆
                heapq.heappush(h, (-tweet.next.ts, tweet.next))
        return ret

    def follow(self, followerId: int, followeeId: int) -&gt; None:
        &#34;&#34;&#34;
        Follower follows a followee. If the operation is invalid, it should be a no-op.
        &#34;&#34;&#34;
        if followeeId == followerId:
            return

        self.follow_relation[followerId].add(followeeId)  # 更新关注关系哈希表

    def unfollow(self, followerId: int, followeeId: int) -&gt; None:
        &#34;&#34;&#34;
        Follower unfollows a followee. If the operation is invalid, it should be a no-op.
        &#34;&#34;&#34;
        self.follow_relation[followerId].discard(followeeId)  # 更新关注关系哈希表


# Your Twitter object will be instantiated and called as such:
# obj = Twitter()
# obj.postTweet(userId,tweetId)
# param_2 = obj.getNewsFeed(userId)
# obj.follow(followerId,followeeId)
# obj.unfollow(followerId,followeeId)
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>