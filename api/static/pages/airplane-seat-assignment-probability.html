<!DOCTYPE html>
<html lang="zh">
<head>
    <title>飞机座位分配概率</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>飞机座位分配概率</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=brainteaser" class="badge bg-secondary tag-link">脑筋急转弯</a>
                    
                        <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                    
                        <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                    
                        <a href="/problems?tag=probability-and-statistics" class="badge bg-secondary tag-link">概率与统计</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>有 <code>n</code> 位乘客即将登机，飞机正好有 <code>n</code> 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。</p>

<p>剩下的乘客将会：</p>

<ul>
	<li>
	<p>如果他们自己的座位还空着，就坐到自己的座位上，</p>
	</li>
	<li>当他们自己的座位被占用时，随机选择其他座位</li>
</ul>

<p>第 <code>n</code>&nbsp;位乘客坐在自己的座位上的概率是多少？</p>



<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>n = 1
<strong>输出：</strong>1.00000
<strong>解释：</strong>第一个人只会坐在自己的位置上。</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入:</strong> n = 2
<strong>输出:</strong> 0.50000
<strong>解释：</strong>在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= n &lt;= 10^5</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 24 ms</p>
                    <p>内存: 16.1 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def nthPersonGetsNthSeat(self, n: int) -&gt; float:
        return 1 if n==1 else .5</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>这个问题可以通过递归思维来解决，但它的美在于可以简化为一个非常直观的数学问题。考虑两种情况：

1. 当只有一位乘客时，他只能坐在自己的座位上，所以概率是 1。
2. 当有多于一位乘客时，第一个乘客随机选择一个座位，这个选择将影响最后一位乘客能否坐在自己的座位上。第一个乘客可能坐在第一个座位上，可能坐在最后一个座位上，或者坐在中间的任何一个座位上。如果第一个乘客坐在最后一个座位上，那么最后一个乘客不能坐在自己的座位上。如果第一个乘客坐在第一个座位上，那么每个人都能坐在自己的座位上。如果第一个乘客坐在中间的某个座位上，这将触发一系列随机选择，但最终结果的概率总是趋向于 0.5，因为这变成了两个等可能的结果：最后一个乘客的座位被占用或未被占用。</p>
                                <p>时间复杂度: O(1)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2"># 定义解决方案类
class Solution:
    # 定义函数，接收整数 n 作为唯一参数
    def nthPersonGetsNthSeat(self, n: int) -&gt; float:
        # 当只有一位乘客时，返回 1.0（因为他只能坐在自己的座位上）
        if n == 1:
            return 1.0
        # 当有多于一位乘客时，返回 0.5（根据上述逻辑推导结果）
        else:
            return 0.5</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            如何从数学角度详细解释当第一个乘客选择了中间任一座位时，最后一个乘客的座位被占用与未被占用的概率均为0.5的推导过程？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>当第一个乘客选择中间的座位i（非第一个也非最后一个座位），接下来的乘客会面临两种情况：他们的座位被占用或者未被占用。如果被占用，他们可能会选择其他任何未被占用的座位。这样的选择持续进行直到最后一个乘客。在这一系列的随机选择中，最终只关注两个特殊的座位：第一个乘客选择的座位i和最后的座位n。由于每次座位的选择都是随机的，分析到最后一个乘客时，他的座位n要么是被第一个乘客占据的座位i，要么是其他未被选择的座位。因此，这里有两种可能：最后一个座位是空的（未被占用），或者已被之前的某个乘客占用。这两种情况是等可能的，因此最后一个乘客的座位被占用与未被占用的概率均为0.5。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            题解中提到，如果第一个乘客坐在最后一个座位上，则最后一个乘客不能坐在自己的座位上。这里是否考虑了中间乘客的选择可能改变这一结果的情况？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中的情况考虑了中间乘客的选择，但当第一位乘客直接坐在最后一个座位上时，这个座位已经被占用，因此最后一位乘客无法坐在自己的座位上。中间的乘客虽有选择，但他们的选择不会改变最后一个座位已被占用这一事实。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            在函数中只用到了一次条件判断，这种方法是否适用于所有的输入范围，即对于非常大的n（接近10^5）值，这种解释依然成立吗？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>是的，这种方法适用于所有输入范围，包括非常大的n值。因为逻辑不依赖于具体的乘客数量，而是依赖于随机选择的性质和递归的结构。无论n的大小如何，最后一个乘客坐在自己座位的概率始终是0.5（除了n为1的特殊情况）。因此，这种方法对于大规模输入也是有效的。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            题解指出，如果n为1，则返回1.0。这里是否可以详细解释一下为什么即使第一位乘客丢了票，他仍然会100%坐在自己的座位上？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>当n为1时，即只有一位乘客，那么无论他是否记得自己的座位位置，由于飞机上只有一个座位可用，他只能坐在这个座位上。因此，无论是否丢失了票或忘记了座位号，最终他坐在自己座位上的概率仍然是100%。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/airplane-seat-assignment-probability')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/airplane-seat-assignment-probability/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>