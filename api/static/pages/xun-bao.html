<!DOCTYPE html>
<html lang="zh">
<head>
    <title>寻宝</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">寻宝</strong>
                标签:
                
                    <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                
                    <a href="/problems?tag=breadth-first-search" class="badge bg-secondary tag-link">广度优先搜索</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                    <a href="/problems?tag=bitmask" class="badge bg-secondary tag-link">状态压缩</a>
                
                    <a href="/problems?tag=matrix" class="badge bg-secondary tag-link">矩阵</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minimalSteps(self, maze: List[str]) -&gt; int:
        # 先广度优先搜索找到所有能遇到的机关，石头，记录下标
        # 如果达不到终点或者机关，返回-1
        m, n = len(maze), len(maze[0])
        st,en,mm,oo = None,None, [],[]  # 起始 结束 机关 石头
        for i,row in enumerate(maze):
            for j,v in enumerate(row):
                if v == &#39;O&#39;: oo.append((i,j))
                elif v == &#39;M&#39;: mm.append((i,j))
                elif v == &#39;S&#39;: st = (i,j)
                elif v == &#39;T&#39;: en = (i,j)
        mm = [st]+mm  # 1.编码：起点+机关点的节点列表，两两之间必须经过石堆
        size = len(mm)
        dis = [[inf]*size for _ in range(size)]  # 2.计算两两之间步数：邻接矩阵，代表两两之间经过石堆的最短路
        def bfs(x,y):  # 以x,y为起点到其它所有点的最短路
            d = [[inf]*n for _ in range(m)]
            d[x][y] = 0 
            cur = [(x,y)]
            while cur:
                pre = cur
                cur = []
                for x, y in pre:
                    c = d[x][y] + 1
                    for a,b in (x-1,y),(x+1,y),(x,y-1),(x,y+1):
                        if 0&lt;=a&lt;m and 0&lt;=b&lt;n and maze[a][b] != &#39;#&#39; and c &lt;d[a][b]:
                            d[a][b] = c 
                            cur.append((a,b))
            return d
        for x,y in oo:  # 枚举每个石堆为中间点，连接两个节点，找出每两个节点之间的最短路
            d = bfs(x,y)
            for i,(x,y) in enumerate(mm):
                for j,(a,b) in enumerate(mm):                    
                    dis[i][j] = min(dis[i][j],d[x][y]+d[a][b])

        mask = 1&lt;&lt;size 
        f = [[inf]*mask for _ in range(size)]  # 3.状压DP：f[i][j]表示状态j下，最后到达i的最短步数
        f[0][1] = 0
        for i in range(mask):  # 用刷表法转移
            if not i &amp; 1:continue  # 不含起始点的状态不用讨论
            ones,zeros = [],[]  # 从所有1转移所有0
            for j in range(size):
                if i&gt;&gt;j&amp;1: ones.append(j)
                else: zeros.append(j)
            for j in ones:  # 枚举从j
                if f[j][i] &lt; inf:  # 可达状态才需要向后转移
                    for k in zeros:  # 转移到k
                        f[k][i|(1&lt;&lt;k)] = min(f[k][i|(1&lt;&lt;k)],f[j][i]+dis[j][k])
        
        x,y = en 
        d = bfs(x,y)  # 终点到每个位置的最短路，它和每个节点都是通的
        ans = min(f[i][-1] + d[x][y] for i,(x,y) in enumerate(mm)) # 4.转移到终点：尝试从每个节点直接到达终点的最短路
        return ans if ans &lt; inf else -1






</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 1592 ms</p>
                    <p class="mb-0">内存: 46.6 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解采用了广度优先搜索（BFS）、动态规划以及状态压缩的策略。首先，通过广度优先搜索确定地图中起点、石头堆、机关和终点的位置。其次，使用 BFS 确定石头堆到每个点的最短路径，并据此建立起点和所有机关点的距离矩阵。然后，使用状态压缩的动态规划策略，记录在达到所有机关的各种状态下，到达每个机关的最小步数。最后，通过另一次 BFS 计算从终点到其他所有点的最短距离，并结合动态规划的结果确定能否拿到宝藏，并计算最小步数。</p>
                        <p>时间复杂度: O(O*M*N + 2^M * M^2 + M)</p>
                        <p>空间复杂度: O(M*N + M*2^M)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minimalSteps(self, maze: List[str]) -&gt; int:
        m, n = len(maze), len(maze[0])
        st, en, mm, oo = None, None, [], []  # 初始化起点、终点、机关和石头堆
        for i, row in enumerate(maze):
            for j, v in enumerate(row):
                if v == &#39;O&#39;: oo.append((i, j))
                elif v == &#39;M&#39;: mm.append((i, j))
                elif v == &#39;S&#39;: st = (i, j)
                elif v == &#39;T&#39;: en = (i, j)
        mm = [st] + mm  # 加入起点到机关列表
        size = len(mm)
        dis = [[inf] * size for _ in range(size)]  # 初始化距离矩阵
        def bfs(x, y):  # BFS 函数定义
            d = [[inf] * n for _ in range(m)]
            d[x][y] = 0
            cur = [(x, y)]
            while cur:
                pre = cur
                cur = []
                for x, y in pre:
                    c = d[x][y] + 1
                    for a, b in ((x-1, y), (x+1, y), (x, y-1), (x, y+1)):
                        if 0 &lt;= a &lt; m and 0 &lt;= b &lt; n and maze[a][b] != &#39;#&#39; and c &lt; d[a][b]:
                            d[a][b] = c
                            cur.append((a, b))
            return d
        for x, y in oo:  # 通过石堆优化距离矩阵
            d = bfs(x, y)
            for i, (x, y) in enumerate(mm):
                for j, (a, b) in enumerate(mm):
                    dis[i][j] = min(dis[i][j], d[x][y] + d[a][b])
        mask = 1 &lt;&lt; size
        f = [[inf] * mask for _ in range(size)]  # 初始化动态规划表
        f[0][1] = 0
        for i in range(mask):  # 状态压缩DP
            if not i &amp; 1: continue  # 忽略不包含起点的状态
            ones, zeros = [], []
            for j in range(size):
                if i &gt;&gt; j &amp; 1: ones.append(j)
                else: zeros.append(j)
            for j in ones:
                if f[j][i] &lt; inf:
                    for k in zeros:
                        f[k][i | (1 &lt;&lt; k)] = min(f[k][i | (1 &lt;&lt; k)], f[j][i] + dis[j][k])
        x, y = en
        d = bfs(x, y)  # 终点的BFS
        ans = min(f[i][-1] + d[x][y] for i, (x, y) in enumerate(mm))  # 计算最终结果
        return ans if ans &lt; inf else -1</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>