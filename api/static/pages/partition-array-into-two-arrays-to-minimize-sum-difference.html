<!DOCTYPE html>
<html lang="zh">
<head>
    <title>将数组分成两个数组并最小化数组和的差</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">将数组分成两个数组并最小化数组和的差</strong>
                标签:
                
                    <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=two-pointers" class="badge bg-secondary tag-link">双指针</a>
                
                    <a href="/problems?tag=binary-search" class="badge bg-secondary tag-link">二分查找</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                    <a href="/problems?tag=bitmask" class="badge bg-secondary tag-link">状态压缩</a>
                
                    <a href="/problems?tag=ordered-set" class="badge bg-secondary tag-link">有序集合</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python"># class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n = len(nums)//2
#         dp0, dp2 = set([0]), set()
#         for i in range(n):
#             ndp0, ndp2 = set(), set()
#             nd0, nd2 = abs(nums[2*i]-nums[2*i+1]), nums[2*i]+nums[2*i+1]
#             for d in dp0:
#                 ndp0.update([d+nd0, abs(d-nd0)])
#                 ndp2.update([nd2+d, nd2-d])
#             for d in dp2:
#                 ndp0.add(abs(nd2-d))
#                 ndp2.update([d+nd0, d-nd0])
#             dp0, dp2 = ndp0, ndp2
#         return min(dp0)

# # past 134/201
# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n = len(nums)//2
#         dp = defaultdict(set)
#         dp[0] = set([0])
#         for i in range(n):
#             nd0, nd2 = abs(nums[2*i]-nums[2*i+1]), nums[2*i]+nums[2*i+1]
#             ndp = defaultdict(set)
#             for dn, dss in dp.items():
#                 mdn = 2*min(i+1, n-(i+1))
#                 for ds in dss:
#                     if dn==0: ndp[dn].update([abs(ds+nd0), abs(ds-nd0)])
#                     elif dn&lt;=mdn: ndp[dn].update([ds+nd0, ds-nd0])
#                     if 0&lt;=dn-2&lt;=mdn: ndp[dn-2].add(abs(ds-nd2) if dn==2 else ds-nd2)
#                     if dn+2&lt;=mdn:
#                         ndp[dn+2].add(ds+nd2)
#                         if dn==0: ndp[dn+2].add(nd2-ds)
#             dp = ndp
#         return min(dp[0])

# # past 134/201
# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n = len(nums)//2
#         dp = defaultdict(set)
#         dp[0] = set([0])
#         for i in range(2*n):
#             ndp = defaultdict(set)
#             for dn, dss in dp.items():
#                 for ds in dss:
#                     if dn&gt;=1:
#                         ndp[dn-1].add(abs(ds-nums[i]) if dn==1 else ds-nums[i])
#                     if dn+1&lt;=min(i+1, 2*n-(i+1)): 
#                         ndp[dn+1].add(ds+nums[i])
#                         if dn==0: ndp[dn+1].add(nums[i]-ds)
#             dp = ndp
#         return min(dp[0])



# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n = len(nums)//2
#         dp = {0: [[0, 0], [0, 0]]}
#         def _update_n1(dn, pm, nm, nu):
#             pbit, mp = pm
#             nbit, mn = nm
#             npbit, nmp = 0, mp
#             nnbit, nmn = 0, mn
#             for i in range(mp):
#                 if pbit&amp;(1&lt;&lt;i)==0: continue
#                 nds = i-nu
#                 if dn==1 or nds&gt;=0: 
#                     npbit |= 1&lt;&lt;abs(nds)
#                     nmp = max(nmp, abs(nds))
#                 else:
#                     nnbit |= 1&lt;&lt;abs(nds)
#                     nmn = max(nmn, abs(nds))
#             for i in range(mn):
#                 if nbit&amp;(1&lt;&lt;i)==0: continue
#                 nds = -i-nu
#                 if dn==1 or nds&gt;=0: 
#                     npbit |= 1&lt;&lt;abs(nds)
#                     nmp = max(nmp, abs(nds))
#                 else:
#                     nnbit |= 1&lt;&lt;abs(nds)
#                     nmn = max(nmn, abs(nds))
#             return [npbit, nmp], [nnbit, nmn]

# #                     if dn+1&lt;=min(i+1, 2*n-(i+1)): 
# #                         ndp[dn+1].add(ds+nums[i])
# #                         if dn==0: ndp[dn+1].add(nums[i]-ds)

#         def _update_p1(dn, pm, nm, nu):
#             pbit, mp = pm
#             nbit, mn = nm
#             npbit, nmp = 0, mp
#             nnbit, nmn = 0, mn
#             for i in range(mp):
#                 if pbit&amp;(1&lt;&lt;i)==0: continue
#                 nds = i+nu
#                 if nds&gt;=0:
#                     npbit |= 1&lt;&lt;abs(nds)
#                     nmp = max(nmp, abs(nds))
#                 else:
#                     nnbit |= 1&lt;&lt;abs(nds)
#                     nmn = max(nmn, abs(nds))
#                 if dn==0:
#                     nds = nu-i


#             for i in range(mn):
#                 if nbit&amp;(1&lt;&lt;i)==0: continue

#         for i in range(2*n):
#             ndp = {}
#             for dn, bits in dp.items():
#                 pm, nm = bits



#                 if dn&gt;=1:
#                     pm, nm = ndp.get(dn-1, [0, 0])
#                     if dn==1: pm |= 1&lt;&lt;abs(ds-nums[i])
#                     else:
#                         pm, nm = _update(ds-nums[i], pm, nm)
#                     ndp[dn-1] = [pm, nm]
#                 if dn+1&lt;=min(i+1, 2*n-(i+1)): 
#                     pm, nm = ndp.get(dn+1, [0, 0])
#                     pm, nm = _update(ds+nums[i], pm, nm)
#                     if dn==0: pm, nm = _update(nums[i]-ds, pm, nm)
#                     ndp[dn+1] = [pm, nm]
#             dp = ndp
#         md = 0
#         while dp[0][0]%2==0:
#             md += 1
#             dp[0][0] //= 2
#         return md

# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n, ss = len(nums)//2, sum(nums)
#         ts = ss//2
#         dp = [[ts, ts+1] for _ in range(n+1)]
#         for l in range(1, 2*n+1):
#             for k in range(1, min(l, n)+1):
#                 ns0, ns1 = dp[k-1][0]+nums[l-1], dp[k-1][1]+nums[l-1]
#                 if dp[k][0]&lt;ns0&lt;=ts: dp[k][0] = ns0
#                 if dp[k][1]&lt;ns0&lt;=ts+1: dp[k][1] = ns1
#         return min(abs(ss-2*dp[-1][0]), abs(ss-2*dp[-1][1]))

# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n, ss = len(nums)//2, sum(nums)
#         dp = [ss for _ in range(n+1)]
#         for l in range(1, 2*n+1):
#             for k in range(1, min(l+n)+1):
#                 dp[k] = min(dp[k], abs(ss-2*(dp[k-1]+nums[l-1])))
#         return dp[-1]


# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n, ts = len(nums)//2, sum(nums)
#         lns, rns = nums[:n], nums[n:]
#         def _subset_sum(arr):
#             dp = defaultdict(set)
#             dp[0] = set([0])
#             for i in range(len(arr)):
#                 ndp = defaultdict(set)
#                 for c in range(i+1):
#                     ndp[c].update(dp[c])
#                     ndp[c+1] = set([s+arr[i] for s in dp[c]])
#                 dp = ndp
#             return dp

#         def _find_peak(a, barr):
#             # find the peak value of an array with unique numbers
#             nb = len(barr)
#             l, r = 0, nb-1
#             while l&lt;r:
#                 m = (l+r)//2
#                 s0, s1 = abs(ts-2*(a+barr[m])), abs(ts-2*(a+barr[m+1]))
#                 if s0&gt;s1: l = m+1
#                 else: r = m
#             return abs(ts-2*(a+barr[r]))

#         ldss, rdss = _subset_sum(lns), _subset_sum(rns)
#         md = sys.maxsize
#         for i in range(n+1):
#             lss, rss = ldss[i], rdss[n-i]
#             sss = lss if len(lss)&lt;len(rss) else rss
#             bss = rss if len(lss)&lt;len(rss) else lss
#             sss = sorted(sss)
#             for a in bss:
#                 md = min(md, _find_peak(a, sss))
#             del ldss[i], rdss[n-i]
#         return md

# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         n, ts = len(nums)//2, sum(nums)
#         lns, rns = nums[:n], nums[n:]
#         lts, rts = sum(lns), sum(rns)
#         def _subset_sum(arr):
#             nn, dp = len(arr), defaultdict(set)
#             dp[0] = set([0])
#             for i in range(nn):
#                 ndp = defaultdict(set)
#                 for c in range(min(i, nn//2)+1):
#                     ndp[c].update(dp[c])
#                     ndp[c+1] = set([s+arr[i] for s in dp[c]])
#                 dp = ndp
#             return dp

#         def _find_peak(a, barr, bts):
#             # find the peak value of an array with unique numbers
#             nb = len(barr)
#             l, r = 0, nb-1
#             while l&lt;r:
#                 m = (l+r)//2
#                 s0, s1 = abs(ts-2*(a+bts-barr[m])), abs(ts-2*(a+bts-barr[m+1]))
#                 if s0&gt;s1: l = m+1
#                 else: r = m
#             return abs(ts-2*(a+bts-barr[r]))

#         ldss, rdss = _subset_sum(lns), _subset_sum(rns)
#         md = abs(lts-rts)
#         for i in range(n//2+1):
#             lss, rss = ldss[i], rdss[i]
#             if len(lss)&lt;len(rss):
#                 sss, bss, sts = sorted(lss), rss, lts
#             else:
#                 sss, bss, sts = sorted(rss), lss, rts
#             for a in bss:
#                 md = min(md, _find_peak(a, sss, sts))
#             del ldss[i], rdss[i]
#         return md

class Solution:
    def minimumDifference(self, nums: List[int]) -&gt; int:
        n, ts = len(nums)//2, sum(nums)
        lns, rns = nums[:n], nums[n:]
        lts, rts = sum(lns), sum(rns)
        def _subset_sum(arr):
            nn, dp = len(arr), defaultdict(set)
            dp[0] = set([0])
            for i in range(nn):
                ndp = defaultdict(set)
                for c in range(min(i, nn//2)+1):
                    ndp[c].update(dp[c])
                    ndp[c+1] = set([s+arr[i] for s in dp[c]])
                dp = ndp
            return dp

        ldss, rdss = _subset_sum(lns), _subset_sum(rns)
        md = abs(lts-rts)
        for i in range(n//2+1):
            lss, rss = ldss[i], rdss[i]
            if len(lss)&lt;len(rss): sss, bss, sts = sorted(lss), rss, lts
            else: sss, bss, sts = sorted(rss), lss, rts
            for a in bss:
                targ_rs = sts - (ts/2 - a)
                bti = bisect_right(sss, targ_rs)
                for j in [bti-1, bti]:
                    if j&gt;=len(sss): continue
                    md = min(md, abs(ts-2*(a+sts-sss[j])))
            del ldss[i], rdss[i]
        return md


# class Solution:
#     def minimumDifference(self, nums: List[int]) -&gt; int:
#         N = len(nums) // 2 # Note this is N/2, ie no. of elements required in each.
        
#         def get_sums(nums): # generate all combinations sum of k elements
#             ans = {}
#             N = len(nums)
#             for k in range(1, N+1): # takes k element for nums
#                 sums = []
#                 for comb in combinations(nums, k):
#                     s = sum(comb)
#                     sums.append(s)
#                 ans[k] = sums
#             return ans
        
#         left_part, right_part = nums[:N], nums[N:]
#         left_sums, right_sums = get_sums(left_part), get_sums(right_part)
#         ans = abs(sum(left_part) - sum(right_part)) # the case when taking all N from left_part for left_ans, and vice versa
#         total = sum(nums) 
#         half = total // 2 # the best sum required for each, we have to find sum nearest to this
#         for k in range(1, N):
#             left = left_sums[k] # if taking k no. from left_sums
#             right = right_sums[N-k] # then we have to take remaining N-k from right_sums.
#             right.sort() # sorting, so that we can binary search the required value
#             for x in left:
#                 r = half - x # required, how much we need to add in x to bring it closer to half.
#                 p = bisect.bisect_left(right, r) # we are finding index of value closest to r, present in right, using binary search
#                 for q in [p, p-1]:
#                     if 0 &lt;= q &lt; len(right):
#                         left_ans_sum = x + right[q]
#                         right_ans_sum = total - left_ans_sum
#                         diff = abs(left_ans_sum - right_ans_sum)
#                         ans = min(ans, diff) 
#         return ans</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 1060 ms</p>
                    <p class="mb-0">内存: 0.0 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解的思路是将数组分成左右两部分,分别求出左右两部分所有可能的子集和。然后对于左边每一个可能的子集和,在右边部分通过二分查找找到最接近总和一半的子集和,两者相加即可得到最接近总和一半的一种划分方式。所有划分方式中的最小值即为答案。</p>
                        <p>时间复杂度: O(n*2^n)</p>
                        <p>空间复杂度: O(2^n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minimumDifference(self, nums: List[int]) -&gt; int:
        n, ts = len(nums)//2, sum(nums)
        lns, rns = nums[:n], nums[n:]
        lts, rts = sum(lns), sum(rns)
        # 求一个数组的所有子集和
        def _subset_sum(arr):
            nn, dp = len(arr), defaultdict(set)
            dp[0] = set([0]) 
            for i in range(nn):
                ndp = defaultdict(set)
                for c in range(min(i, nn//2)+1):
                    ndp[c].update(dp[c])
                    ndp[c+1] = set([s+arr[i] for s in dp[c]])
                dp = ndp
            return dp
        
        ldss, rdss = _subset_sum(lns), _subset_sum(rns) 
        md = abs(lts-rts) 
        for i in range(n//2+1):
            lss, rss = ldss[i], rdss[i]
            if len(lss)&lt;len(rss): sss, bss, sts = sorted(lss), rss, lts
            else: sss, bss, sts = sorted(rss), lss, rts
            for a in bss: 
                targ_rs = sts - (ts/2 - a)
                bti = bisect_right(sss, targ_rs) 
                for j in [bti-1, bti]:
                    if j&gt;=len(sss): continue
                    md = min(md, abs(ts-2*(a+sts-sss[j])))
            del ldss[i], rdss[i]
        return md</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>