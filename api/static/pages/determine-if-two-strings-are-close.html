<!DOCTYPE html>
<html lang="zh">
<head>
    <title>确定两个字符串是否接近</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>确定两个字符串是否接近</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                        <a href="/problems?tag=counting" class="badge bg-secondary tag-link">计数</a>
                    
                        <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 <strong>接近</strong> ：</p>

<ul>
	<li>操作 1：交换任意两个 <strong>现有</strong> 字符。

	<ul>
		<li>例如，<code>a<u>b</u>cd<u>e</u> -&gt; a<u>e</u>cd<u>b</u></code></li>
	</ul>
	</li>
	<li>操作 2：将一个 <strong>现有</strong> 字符的每次出现转换为另一个 <strong>现有</strong> 字符，并对另一个字符执行相同的操作。
	<ul>
		<li>例如，<code><u>aa</u>c<u>abb</u> -&gt; <u>bb</u>c<u>baa</u></code>（所有 <code>a</code> 转化为 <code>b</code> ，而所有的 <code>b</code> 转换为 <code>a</code> ）</li>
	</ul>
	</li>
</ul>

<p>你可以根据需要对任意一个字符串多次使用这两种操作。</p>

<p>给你两个字符串，<code>word1</code> 和 <code>word2</code> 。如果<em> </em><code>word1</code><em> </em>和<em> </em><code>word2</code><em> </em><strong>接近 </strong>，就返回 <code>true</code> ；否则，返回<em> </em><code>false</code><em> </em>。</p>



<p><strong>示例 1：</strong></p>

<pre>
<strong>输入：</strong>word1 = "abc", word2 = "bca"
<strong>输出：</strong>true
<strong>解释：</strong>2 次操作从 word1 获得 word2 。
执行操作 1："a<u>bc</u>" -&gt; "a<u>cb</u>"
执行操作 1："<u>a</u>c<u>b</u>" -&gt; "<u>b</u>c<u>a</u>"
</pre>

<p><strong>示例 2：</strong></p>

<pre>
<strong>输入：</strong>word1 = "a", word2 = "aa"
<strong>输出：</strong>false
<strong>解释：</strong>不管执行多少次操作，都无法从 word1 得到 word2 ，反之亦然。</pre>

<p><strong>示例 3：</strong></p>

<pre>
<strong>输入：</strong>word1 = "cabbba", word2 = "abbccc"
<strong>输出：</strong>true
<strong>解释：</strong>3 次操作从 word1 获得 word2 。
执行操作 1："ca<u>b</u>bb<u>a</u>" -&gt; "ca<u>a</u>bb<u>b</u>"
执行操作 2：<code>"</code><u>c</u>aa<u>bbb</u>" -&gt; "<u>b</u>aa<u>ccc</u>"
执行操作 2："<u>baa</u>ccc" -&gt; "<u>abb</u>ccc"
</pre>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= word1.length, word2.length &lt;= 10<sup>5</sup></code></li>
	<li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 64 ms</p>
                    <p>内存: 17.2 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def closeStrings(self, word1: str, word2: str) -&gt; bool:
        if(len(word1)!=len(word2)):
            return False
    
        set1=set(word1)
        set2=set(word2)
    
        
        if(set1!=set2):
            return False
        
        
        d1={}
        for i in set1:
            d1[i]=word1.count(i)
            
        d2={}
            
        for i in set2:
            d2[i]=word2.count(i)
            
            
    
        d1=sorted(d1.values())
        d2=sorted(d2.values())
        print(d1)
        print(d2)
            
        
        return d1==d2</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>首先，检查两个字符串长度是否相等。如果不相等，直接返回 false。然后，使用集合检查两个字符串是否包含相同的字符集。如果字符集不相同，也返回 false。接下来，计算每个字符在两个字符串中的出现次数，并将这些次数存储在两个字典中。最后，比较这两个字典中的值（已排序）是否相等。如果这些值相等，说明可以通过字符交换得到相同的字符频率，从而可以通过指定的操作使两个字符串接近。</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(m)</p>
                                <pre class="bg-light p-2">class Solution:
    def closeStrings(self, word1: str, word2: str) -&gt; bool:
        if len(word1) != len(word2):
            return False

        set1 = set(word1)
        set2 = set(word2)
        
        if set1 != set2:
            return False
        
        d1 = {}
        for char in set1:
            d1[char] = word1.count(char)
        
        d2 = {}
        for char in set2:
            d2[char] = word2.count(char)
        
        values1 = sorted(d1.values())
        values2 = sorted(d2.values())
        
        return values1 == values2</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            题解中提到，如果两个字符串的字符集不相同，则直接返回 false。请问为什么字符集必须相同才能认为两个字符串可能接近？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果两个字符串的字符集不相同，即意味着至少有一个字符在一个字符串中出现而在另一个字符串中没有出现。由于字符串接近的定义要求我们通过重新排列字符频率来使两个字符串接近，如果字符本身不存在于另一个字符串中，那么无论如何交换字符频率，也无法使两个字符串相等。因此，字符集必须完全相同，才有可能通过交换字符频率使两个字符串接近。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在使用字典存储每个字符的出现次数时，为什么选择了使用 `word1.count(char)` 和 `word2.count(char)` 方法，而不是遍历字符串一次统计所有字符的次数？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在题解中使用 `word1.count(char)` 和 `word2.count(char)` 方法的确不是最优的选择，因为每次调用 count 方法都会遍历整个字符串来计算特定字符的出现次数，这使得时间复杂度上升到 O(n^2)，其中 n 是字符串的长度。更高效的方法是遍历每个字符串一次，使用字典来统计每个字符的出现次数，这可以将时间复杂度降低到 O(n)。选择 count 方法可能是出于代码简洁性的考虑，但在性能要求较高的情况下，应该避免使用它。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解中的方法将字典的值排序后比较，这种排序是否是必需的？如果只要字符的出现次数集合相同是否也能认为两个字符串接近？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中将字典的值（字符频率）排序后比较是必需的，因为仅仅字符的出现次数集合相同并不足以确保两个字符串可以通过重新排列字符频率来接近。例如，如果字符串 `aabb` 和 `abab` 的字符频率集合相同（两个字符出现两次），但它们的具体排列顺序不同，即使字符集相同也不能通过简单的频率重新排列使两个字符串相等。正确的方法是，比较排序后的频率列表，这样可以确保每种字符频率的排列顺序也相同，从而可以通过字符交换使两个字符串接近。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/determine-if-two-strings-are-close')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/determine-if-two-strings-are-close/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>