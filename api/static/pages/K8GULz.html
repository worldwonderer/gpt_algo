<!DOCTYPE html>
<html lang="zh">
<head>
    <title>环形闯关游戏</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">环形闯关游戏</strong>
                标签:
                
                    <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                
                    <a href="/problems?tag=union-find" class="badge bg-secondary tag-link">并查集</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=heap-priority-queue" class="badge bg-secondary tag-link">堆（优先队列）</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from typing import List
from collections import defaultdict, deque
from itertools import accumulate
import heapq
import sys

&#39;&#39;&#39;
1 设n为结果 max_n/2 &lt;= n &lt;= max
2 m为去头 结果为 max_n/2 | m
3 最大 - 其它的| 必在 m 里
4 &lt;
4 dp[0][n]=s d
&#39;&#39;&#39;
class Solution:
    def log(self, *s):
        pass
    
    def ringGame(self, challenge: List[int]) -&gt; int:
        n=len(challenge)
        max_value=challenge[0]
        max_index=0
        for i in range(1,len(challenge)):
            if challenge[i]&gt;max_value:
                max_value=challenge[i]
                max_index=i
        challenge = challenge[max_index:]+challenge+challenge[:max_index+1]
        n3=len(challenge)
        def check(m) :
            i = 1
            while i &lt; n3:
                # 尝试以关卡i为起点
                if challenge[i] &gt; m :
                    i += 1
                    continue

                s, l, r = m|score_left[i]|score_right[i], idx_left[i], idx_right[i]
                while True :
                    if r-l &gt; n : 
                        return True # 已挑战完所以关卡
                    # 向两边挑战关卡，并更新积分
                    if challenge[l] &lt;= s :
                        s |= score_left[l]
                        l = idx_left[l]
                    if challenge[r] &lt;= s :
                        s |= score_right[r]
                        r = idx_right[r]
                    else : break
                i = r # 扩展经过的点都可以不必再尝试作为起点；

            return False


        # 预计算出以某个关卡为起点（也以它的挑战分为初始分），单纯向左或向右能扩展多远和扩展后的积分
        score_left, idx_left = challenge[:], [0]*n3
        for i in range(n3) :
            j = i-1
            while j &gt;= 0 and challenge[j] &lt;= score_left[i] :
                score_left[i] |= score_left[j]
                j = idx_left[j]
            idx_left[i] = j

        score_right, idx_right = challenge[:], [0]*n3
        for i in range(n3-1, -1, -1) :
            j = i+1
            while j &lt; n3 and challenge[j] &lt;= score_left[i] :
                score_right[i] |= score_right[j]
                j = idx_right[j]
            idx_right[i] = j
        # self.log(challenge)
        # self.log(score_right)
        # self.log(idx_right)
        # 从高到低确定答案的二进制位
        bit = 1 &lt;&lt; (max_value.bit_length()-1)
        res = bit
        while bit:
            bit &gt;&gt;= 1
            if not check(res | (bit-1)) : 
                res |= bit
        return res


    def baoli(self,challenge):
        def util(ret,i):
            visited=[False]*len(challenge)
            stacks=[]
            heapq.heappush(stacks,[challenge[i],i])
            while len(stacks):
                next_v,next_i=heapq.heappop(stacks)
                if next_v&gt;ret:
                    return False
                visited[next_i]=True
                ret = ret|next_v
                next_i_right=(next_i+1)%len(challenge)
                next_i_left=(next_i-1+len(challenge))%len(challenge)
                if not visited[next_i_right]:
                    heapq.heappush(stacks,[challenge[next_i_right],next_i_right])
                if not visited[next_i_left]:
                    heapq.heappush(stacks,[challenge[next_i_left],next_i_left])
            return True
        def check(ret):
            for i in range(len(challenge)):
                if challenge[i]&lt;=ret and util(ret,i):
                    return True
            return False
        while ret&lt;max_score:
            mid=(ret+max_score)//2
            self.log(ret,mid,max_score)
            if check(mid):
                max_score=mid
            else:
                ret=mid+1
        return max_score
    

    def run(self, *args):
        return self.ringGame(*args)


class SolutionDebug(Solution):
    logs = &#34;&#34;

    def log(self, *s):
        self.logs += &#34; &#34;.join([str(v) for v in s])+&#34;
&#34;

    def run(self, *args, **kw) -&gt; int:
        self.logs = &#34;&#34;
        return super().run(*args, **kw)


if __name__ == &#39;__main__&#39;:
    s = SolutionDebug()
    null=None
    true=True
    false=False
    for case in [
        [[1,180,447],266],
        [[5,4,6,2,7],4],
        [[12,7,11,3,9],8],
        [[7,7],7],
        [[1,17,1,19,1],18],
        [[1,1,1],1]
    ]:
        s.logs = &#34;&#34;
        e = s.run(*case[:-1])
        if e != case[-1]:
            print(e, case)
            print(s.logs)
            break


    </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 441 ms</p>
                    <p class="mb-0">内存: 32.2 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>此题解的核心思想是利用二分搜索和双指针技术来寻找最小的初始积分，以挑战所有关卡。首先，找到挑战值最大的关卡，并以此关卡为基点重构环形数组为线性数组，以简化问题。然后，使用二分搜索从可能的最低积分开始，使用双指针检测该积分是否足以开始并完成游戏。在二分搜索的每一步，会尝试将挑战分和数组两侧的积分合并，检查能否覆盖整个数组。这种方法有效地将环形结构转化为线性结构，从而简化了逻辑判断。</p>
                        <p>时间复杂度: O(n log(max_value))</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedList
from typing import List
from collections import defaultdict, deque
from itertools import accumulate
import heapq
import sys

class Solution:
    def log(self, *s):
        pass # 日志函数，用于调试
    
    def ringGame(self, challenge: List[int]) -&gt; int:
        n = len(challenge)
        max_value = max(challenge)
        max_index = challenge.index(max_value)
        # 重构数组使其线性化，简化问题
        challenge = challenge[max_index:] + challenge[:max_index]
        n3 = len(challenge)
        
        def check(m):
            # 检查起始积分m是否足够挑战所有关卡
            for i in range(1, n3):
                if challenge[i] &gt; m:
                    continue
                s, l, r = m | challenge[i], i - 1, i + 1
                while True:
                    if r - l &gt; n:
                        return True
                    if l &gt;= 0 and challenge[l] &lt;= s:
                        s |= challenge[l]
                        l -= 1
                    if r &lt; n3 and challenge[r] &lt;= s:
                        s |= challenge[r]
                        r += 1
                    else:
                        break
                return False
        # 二进制搜索最低有效积分
        res = 1 &lt;&lt; max_value.bit_length() - 1
        while res:
            if not check(res):
                res &lt;&lt;= 1
            else:
                res &gt;&gt;= 1
        return res
    
    def run(self, *args):
        return self.ringGame(*args)

if __name__ == &#39;__main__&#39;:
    s = Solution()
    result = s.run([5,4,6,2,7])
    print(result) # 应该输出4
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>