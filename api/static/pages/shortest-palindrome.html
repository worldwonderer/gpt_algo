<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最短回文串</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">最短回文串</strong>
                标签:
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                    <a href="/problems?tag=string-matching" class="badge bg-secondary tag-link">字符串匹配</a>
                
                    <a href="/problems?tag=hash-function" class="badge bg-secondary tag-link">哈希函数</a>
                
                    <a href="/problems?tag=rolling-hash" class="badge bg-secondary tag-link">滚动哈希</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        s1 = s[::-1]
        if s == s1:
            return s
        n = len(s)
        a, b, i = 1, n // 2, 0
        while b:
            while a &lt;= b:
                c = a + b &gt;&gt; 1
                j = s1.find(s[:c], i)
                if j &lt; 0 or j &gt; n - c * 2:
                    b = c - 1
                    i = max(i, n - c * 2 + 1)
                    continue
                m = n - j &gt;&gt; 1
                if s1[j + c:j + m] == s[c:m]:
                    return s1[:j] + s
                i = j + 1
                a = c
            a = 1
        return s1[:-1] + s</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 41 ms</p>
                    <p class="mb-0">内存: 16.2 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解采用了二分查找的思路。首先将原字符串 s 翻转得到 s1。如果 s 本身就是回文串，直接返回 s。否则，通过二分查找的方式，在 s1 中查找 s 的前缀，找到最长的能够形成回文串的前缀。查找过程中，使用双指针 a 和 b 分别指向查找范围的起始和结束位置，每次取中点 c，判断 s1 中是否存在 s[:c] 子串。如果存在，则判断 s1[j+c:j+m] 与 s[c:m] 是否相等（其中 j 为 s[:c] 在 s1 中的起始位置，m 为 s[:c] 的中点），如果相等则找到了最长的回文前缀，返回 s1[:j] + s。如果不相等，则将查找范围缩小到 [c, b]。如果 s[:c] 在 s1 中不存在，则将查找范围缩小到 [a, c-1]。最后，如果没有找到任何回文前缀，则返回 s1[:-1] + s。</p>
                        <p>时间复杂度: O(n log n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def shortestPalindrome(self, s: str) -&gt; str:
        s1 = s[::-1]  # 将字符串 s 翻转得到 s1
        if s == s1:  # 如果 s 本身是回文串，直接返回 s
            return s
        n = len(s)  # 字符串长度
        a, b, i = 1, n // 2, 0  # 二分查找的起始位置 a，结束位置 b，查找起始位置 i
        while b:
            while a &lt;= b:
                c = a + b &gt;&gt; 1  # 二分查找的中点 c
                j = s1.find(s[:c], i)  # 在 s1 中查找 s[:c] 子串的起始位置 j
                if j &lt; 0 or j &gt; n - c * 2:  # 如果 s[:c] 在 s1 中不存在或者位置不合法
                    b = c - 1  # 将查找范围缩小到 [a, c-1]
                    i = max(i, n - c * 2 + 1)  # 更新查找起始位置 i
                    continue
                m = n - j &gt;&gt; 1  # s[:c] 的中点位置 m
                if s1[j + c:j + m] == s[c:m]:  # 判断 s1[j+c:j+m] 与 s[c:m] 是否相等
                    return s1[:j] + s  # 如果相等，找到了最长的回文前缀，返回结果
                i = j + 1  # 如果不相等，将查找起始位置更新为 j+1
                a = c  # 将查找范围缩小到 [c, b]
            a = 1  # 如果当前查找范围没有找到回文前缀，将 a 重置为 1，继续查找
        return s1[:-1] + s  # 如果没有找到任何回文前缀，返回 s1[:-1] + s</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>