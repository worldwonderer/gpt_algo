<!DOCTYPE html>
<html lang="zh">
<head>
    <title>所有排列中的最大和</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">所有排列中的最大和</strong>
                标签:
                
                    <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=prefix-sum" class="badge bg-secondary tag-link">前缀和</a>
                
                    <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">MOD = 10 ** 9 + 7

class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -&gt; int:
        # 差分数组
        diff = [0] * (len(nums) + 1)
        for l, r in requests:
            diff[l] += 1
            diff[r + 1] -= 1
        diff.pop()

        times = sorted(filter(None, accumulate(diff)), reverse=True)
        nums.sort(reverse=True)
        return sum(map(mul, times, nums)) % MOD</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 148 ms</p>
                    <p class="mb-0">内存: 43.0 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The solution utilizes a difference array to efficiently calculate the frequency of each index being accessed across all requests. First, it iterates through each request and updates the difference array to track the start and end+1 of each range. Then, by taking the prefix sum of this difference array, we get the number of times each index is accessed. After sorting this &#39;times&#39; array and the &#39;nums&#39; array in descending order, the product of corresponding elements from both arrays (the highest numbers with the highest frequencies) maximizes the sum. The result is then taken modulo 109 + 7.</p>
                        <p>时间复杂度: O(n log n + m)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">MOD = 10 ** 9 + 7

from itertools import accumulate
from operator import mul

class Solution:
    def maxSumRangeQuery(self, nums: List[int], requests: List[List[int]]) -&gt; int:
        # Create a difference array to handle the range update efficiently
        diff = [0] * (len(nums) + 1)
        for l, r in requests:
            diff[l] += 1  # Start of the range
            diff[r + 1] -= 1  # End of the range (exclusive)
        diff.pop()  # Remove the last element which is extra

        # Compute the number of times each index is accessed
        times = sorted(filter(None, accumulate(diff)), reverse=True)
        # Sort nums in descending order to maximize the sum
        nums.sort(reverse=True)
        # Compute the sum of products of corresponding elements
        return sum(map(mul, times, nums)) % MOD</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>