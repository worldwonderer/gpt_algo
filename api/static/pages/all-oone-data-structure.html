<!DOCTYPE html>
<html lang="zh">
<head>
    <title>全 O(1) 的数据结构</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">全 O(1) 的数据结构</strong>
                标签:
                
                    <a href="/problems?tag=design" class="badge bg-secondary tag-link">设计</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=linked-list" class="badge bg-secondary tag-link">链表</a>
                
                    <a href="/problems?tag=doubly-linked-list" class="badge bg-secondary tag-link">双向链表</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class DListNode:

    def __init__(self, val):
        self.val = val
        self.keys = set()
        
        self.next = None
        self.prev = None
    
    def __repr__(self):
        keys = list(self.keys)
        
        return &#34;&#39;&#34; + str(self.val) + &#34; &#34; + &#34;,&#34;.join(keys) + &#34;&#39;&#34;


class AllOne:

    def __init__(self):
        &#34;&#34;&#34;
        Initialize your data structure here.
        &#34;&#34;&#34;
        self._table = dict()
        
        self._head = DListNode(0)
        self._tail = DListNode(0)
        self._head.next = self._tail
        self._tail.prev = self._head
    
    def _first_node(self):
        return self._head.next
    
    def _last_node(self):
        return self._tail.prev
    
    def _insert_front(self, node):
        node.next = self._head.next
        node.prev = self._head
        
        self._head.next.prev = node
        self._head.next = node
    
    def _insert_last(self, node):
        node.next = self._tail
        node.prev = self._tail.prev
        
        self._tail.prev.next = node
        self._tail.prev = node
    
    def _delete_node(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev

    def inc(self, key: str) -&gt; None:
        &#34;&#34;&#34;
        Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1.
        &#34;&#34;&#34;
        if key not in self._table:
            # Key not in table
            first_node = self._first_node()
            if first_node.val != 1 or first_node == self._tail:
                new_node = DListNode(1)
                new_node.keys.add(key)
                self._insert_front(new_node)
                
                self._table[key] = new_node
            else:
                self._table[key] = first_node
                first_node.keys.add(key)
        else:
            # Key in table
            prev_node = self._table[key]
            prev_val = prev_node.val
            
            if prev_node.next == self._tail or prev_node.next.val != prev_val + 1:
                # Insert new node
                new_node = DListNode(prev_val + 1)
                new_node.keys.add(key)
                
                new_node.next = prev_node.next
                new_node.prev = prev_node
                
                prev_node.next.prev = new_node
                prev_node.next = new_node
                
                # Update table
                self._table[key] = new_node
                
                # Update prev node
                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
            else:
                self._table[key] = prev_node.next
                prev_node.next.keys.add(key)
                
                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
        
        # print(&#34;inc&#34;, key)
        # self.debug()

    def dec(self, key: str) -&gt; None:
        &#34;&#34;&#34;
        Decrements an existing key by 1. If Key&#39;s value is 1, remove it from the data structure.
        &#34;&#34;&#34;
        if key not in self._table:
            return
        
        prev_node = self._table[key]
        prev_val = prev_node.val
        
        if prev_val == 1:
            del self._table[key]
            prev_node.keys.discard(key)
            if len(prev_node.keys) == 0:
                self._delete_node(prev_node)
        else:        
            if prev_node.prev == self._head or prev_node.prev.val != prev_val - 1:
                new_node = DListNode(prev_val - 1)
                new_node.keys.add(key)

                new_node.next = prev_node
                new_node.prev = prev_node.prev

                prev_node.prev.next = new_node
                prev_node.prev = new_node

                self._table[key] = new_node

                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
            else:
                self._table[key] = prev_node.prev
                prev_node.prev.keys.add(key)

                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
        
        # print(&#34;dec&#34;, key)
        # self.debug()

    def getMaxKey(self) -&gt; str:
        &#34;&#34;&#34;
        Returns one of the keys with maximal value.
        &#34;&#34;&#34;
        node = self._tail.prev
        if node == self._head:
            return &#34;&#34;
        
        keys = node.keys
        return next(iter(keys))

    def getMinKey(self) -&gt; str:
        &#34;&#34;&#34;
        Returns one of the keys with Minimal value.
        &#34;&#34;&#34;
        node = self._head.next
        if node == self._tail:
            return &#34;&#34;
        
        keys = node.keys
        return next(iter(keys))

    def debug(self):
        print(self._table)
        curr = self._head.next
        
        while curr != self._tail:
            print(curr)
            curr = curr.next
        print(&#34;======&#34;)


# Your AllOne object will be instantiated and called as such:
# obj = AllOne()
# obj.inc(key)
# obj.dec(key)
# param_3 = obj.getMaxKey()
# param_4 = obj.getMinKey()</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 96 ms</p>
                    <p class="mb-0">内存: 0.0 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解使用双向链表和哈希表来实现AllOne类的功能。链表中的每个节点包含一个计数值和一个存储对应计数值的键的集合。哈希表用于快速查找每个键所在的链表节点。在inc和dec操作中，通过更新链表节点的键集合和在链表中插入或删除节点来维护计数值的有序性。getMaxKey和getMinKey操作可以通过返回链表头尾节点的任意一个键来实现。</p>
                        <p>时间复杂度: O(1)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class DListNode:

    def __init__(self, val):
        self.val = val  # 节点的计数值
        self.keys = set()  # 存储计数值为val的键的集合
        
        self.next = None  # 指向链表的下一个节点
        self.prev = None  # 指向链表的前一个节点
    
    def __repr__(self):
        keys = list(self.keys)
        
        return &#34;&#39;&#34; + str(self.val) + &#34; &#34; + &#34;,&#34;.join(keys) + &#34;&#39;&#34;


class AllOne:

    def __init__(self):
        &#34;&#34;&#34;
        Initialize your data structure here.
        &#34;&#34;&#34;
        self._table = dict()  # 哈希表，用于快速查找键所在的链表节点
        
        self._head = DListNode(0)  # 双向链表的头节点，哨兵节点
        self._tail = DListNode(0)  # 双向链表的尾节点，哨兵节点
        self._head.next = self._tail
        self._tail.prev = self._head
    
    def _first_node(self):
        return self._head.next  # 返回链表的第一个节点（除哨兵节点外）
    
    def _last_node(self):
        return self._tail.prev  # 返回链表的最后一个节点（除哨兵节点外）
    
    def _insert_front(self, node):
        # 在链表头部插入节点
        node.next = self._head.next
        node.prev = self._head
        
        self._head.next.prev = node
        self._head.next = node
    
    def _insert_last(self, node):
        # 在链表尾部插入节点
        node.next = self._tail
        node.prev = self._tail.prev
        
        self._tail.prev.next = node
        self._tail.prev = node
    
    def _delete_node(self, node):
        # 从链表中删除节点
        node.prev.next = node.next
        node.next.prev = node.prev

    def inc(self, key: str) -&gt; None:
        &#34;&#34;&#34;
        Inserts a new key &lt;Key&gt; with value 1. Or increments an existing key by 1.
        &#34;&#34;&#34;
        if key not in self._table:
            # 如果key不在哈希表中
            first_node = self._first_node()
            if first_node.val != 1 or first_node == self._tail:
                # 如果第一个节点的计数值不为1或链表为空，创建新节点并插入链表头部
                new_node = DListNode(1)
                new_node.keys.add(key)
                self._insert_front(new_node)
                
                self._table[key] = new_node
            else:
                # 否则，将key添加到第一个节点的键集合中
                self._table[key] = first_node
                first_node.keys.add(key)
        else:
            # 如果key在哈希表中
            prev_node = self._table[key]
            prev_val = prev_node.val
            
            if prev_node.next == self._tail or prev_node.next.val != prev_val + 1:
                # 如果当前节点是最后一个节点或下一个节点的计数值不等于当前计数值+1，创建新节点并插入当前节点之后
                new_node = DListNode(prev_val + 1)
                new_node.keys.add(key)
                
                new_node.next = prev_node.next
                new_node.prev = prev_node
                
                prev_node.next.prev = new_node
                prev_node.next = new_node
                
                # 更新哈希表
                self._table[key] = new_node
                
                # 更新当前节点
                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
            else:
                # 否则，将key添加到下一个节点的键集合中
                self._table[key] = prev_node.next
                prev_node.next.keys.add(key)
                
                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)

    def dec(self, key: str) -&gt; None:
        &#34;&#34;&#34;
        Decrements an existing key by 1. If Key&#39;s value is 1, remove it from the data structure.
        &#34;&#34;&#34;
        if key not in self._table:
            return
        
        prev_node = self._table[key]
        prev_val = prev_node.val
        
        if prev_val == 1:
            # 如果当前计数值为1，从哈希表和链表中删除key
            del self._table[key]
            prev_node.keys.discard(key)
            if len(prev_node.keys) == 0:
                self._delete_node(prev_node)
        else:        
            if prev_node.prev == self._head or prev_node.prev.val != prev_val - 1:
                # 如果当前节点是第一个节点或前一个节点的计数值不等于当前计数值-1，创建新节点并插入当前节点之前
                new_node = DListNode(prev_val - 1)
                new_node.keys.add(key)

                new_node.next = prev_node
                new_node.prev = prev_node.prev

                prev_node.prev.next = new_node
                prev_node.prev = new_node

                self._table[key] = new_node

                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)
            else:
                # 否则，将key添加到前一个节点的键集合中
                self._table[key] = prev_node.prev
                prev_node.prev.keys.add(key)

                prev_node.keys.discard(key)
                if len(prev_node.keys) == 0:
                    self._delete_node(prev_node)

    def getMaxKey(self) -&gt; str:
        &#34;&#34;&#34;
        Returns one of the keys with maximal value.
        &#34;&#34;&#34;
        node = self._tail.prev
        if node == self._head:
            return &#34;&#34;  # 如果链表为空，返回空字符串
        
        keys = node.keys
        return next(iter(keys))  # 返回最后一个节点的任意一个键

    def getMinKey(self) -&gt; str:
        &#34;&#34;&#34;
        Returns one of the keys with Minimal value.
        &#34;&#34;&#34;
        node = self._head.next
        if node == self._tail:
            return &#34;&#34;  # 如果链表为空，返回空字符串
        
        keys = node.keys
        return next(iter(keys))  # 返回第一个节点的任意一个键</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>