<!DOCTYPE html>
<html lang="zh">
<head>
    <title>设计内存文件系统</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">设计内存文件系统</strong>
                标签:
                
                    <a href="/problems?tag=design" class="badge bg-secondary tag-link">设计</a>
                
                    <a href="/problems?tag=trie" class="badge bg-secondary tag-link">字典树</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class TrieNode:    
    def __init__(self):
        self.child = collections.defaultdict(TrieNode)
        self.contents = &#34;&#34; # save file&#39;s contents eg hello in &#34;d&#34; file of &#34;/a/b/c/d&#34;

class FileSystem:
    def __init__(self):
        self.root = TrieNode()
               
    def _insert(self, path, content=&#34;&#34;):
        cur = self.root
        for c in path.split(&#34;/&#34;)[1:]:
            cur = cur.child[c]
        cur.contents += content # save &#34;hello&#34; in d or it can be &#34;&#34;. 1 file only store 1 content. &#39;&#39;means directory
            
    def _search(self, path):    # search for path and return node at the end of path
        cur = self.root
        for c in path.split(&#34;/&#34;)[1:]:
            if c in cur.child:
                cur = cur.child[c]
        return cur # correspond to the last file name or dir name
    
    # 给定路径字符串，若对应一个目录，则输出其中包含的目录和文件（字典序）；若对应一个文件，则只输出该文件名
    def ls(self, path: str) -&gt; List[str]:
        node = self._search(path)
        if node.contents: # if node corresponds to a file
            # return [node.contents] # wrong
            return [path.split(&#39;/&#39;)[-1]]    # 这里只输出一个[file name]
        else: # node is a folder. node.child.keys() is the next level files within the folder
            # the **list of file and directory names** in this directory.
            return sorted(node.child.keys())    # lexicographic order
        
    # 创建目录，若目录不存在，则递归创建缺少的目录
    def mkdir(self, path: str) -&gt; None:
        self._insert(path)
        
    # 在文件中追加内容，若文件不存在，则新建
    def addContentToFile(self, filePath: str, content: str) -&gt; None:
        self._insert(filePath, content)
        
    # 从文件中读取内容并返回
    def readContentFromFile(self, filePath: str) -&gt; str:
        node = self._search(filePath)
        return node.contents


# [(&#39;FileSystem&#39;, [], None), 
# (&#39;mkdir&#39;, [&#39;/goowmfn&#39;], None),
#  (&#39;ls&#39;, [&#39;/goowmfn&#39;], []), 
#  (&#39;ls&#39;, [&#39;/&#39;], [&#39;goowmfn&#39;]), 
#  (&#39;mkdir&#39;, [&#39;/z&#39;], None), 
#  (&#39;ls&#39;, [&#39;/&#39;], [&#39;goowmfn&#39;, &#39;z&#39;]),
#   (&#39;ls&#39;, [&#39;/&#39;], [&#39;goowmfn&#39;, &#39;z&#39;]), 
#   (&#39;addContentToFile&#39;,[&#39;/goowmfn/c&#39;, &#39;shetopcy&#39;], None), 
#   (&#39;ls&#39;, [&#39;/z&#39;], []), 
#   (&#39;ls&#39;, [&#39;/goowmfn/c&#39;], [&#39;c&#39;]), 
#   (&#39;ls&#39;, [&#39;/goowmfn&#39;], [&#39;c&#39;])]

&#34;&#34;&#34;
Trie solution: search/add/insert都是O(L)的时间复杂度，L是filePath的长度. 
像这种method里面函数很多的情况，不需要额外写一些helper funciton, 最好直接把Trie的实现在已经给定的class里面
path = &#34;/a/b&#34;
print(path.split(&#34;/&#34;)) -&gt; [&#39;&#39;, &#39;a&#39;, &#39;b&#39;]


Use Trie!

Initiate a root hashmap (work as a trie).
For folder name in the path:
The folder name is the key of the current level hashmap, the value is another hashmap.
For operation &#34;addContentToFile&#34; and &#34;readContentFile&#34;:
The last variable in the path is the file name, the file name is the key of the current level hashmap, the value is a string.

Note that for operation &#34;ls&#34;:
the last variable in the path could be a folder or a filename, so we need to do a check.

Time:
Operation &#34;ls&#34;:
O(n + klgk), n is the length of the input string, k is the length of keys in the last folder
Operation &#34;mkdir&#34;:
O(n)
Operation &#34;addContentToFile&#34; and &#34;readContentFromFile&#34;:
O(n)

Space:
O(n)
https://leetcode.com/problems/design-in-memory-file-system/discuss/2013879/Clearly-Explained-Solution-Using-Trie-in-Python-Easy-to-Understand!
&#34;&#34;&#34;


# Your FileSystem object will be instantiated and called as such:
# obj = FileSystem()
# param_1 = obj.ls(path)
# obj.mkdir(path)
# obj.addContentToFile(filePath,content)
# param_4 = obj.readContentFromFile(filePath)

&#34;&#34;&#34;
Design an in-memory file system to simulate the following functions:

ls: Given a path in string format. If it is a file path, return a list that only contains this file’s name. If it is a directory path, return the list of file and directory names in this directory. Your output (file and directory names together) should in lexicographic order.

mkdir: Given a directory path that does not exist, you should make a new directory according to the path. If the middle directories in the path don’t exist either, you should create them as well. This function has void return type.

addContentToFile: Given a file path and file content in string format. If the file doesn’t exist, you need to create that file containing given content. If the file already exists, you need to append given content to original content. This function has void return type.

readContentFromFile: Given a file path, return its content in string format.

https://www.jasonjson.com/archivers/design-in-memory-file-system.html
https://leetcode.com/problems/design-in-memory-file-system/discuss/103359/Python-Straightforward-with-Explanation

http://bookshadow.com/weblog/2017/05/21/leetcode-design-in-memory-file-system/
https://grandyang.com/leetcode/588/

&#34;&#34;&#34;



# Your FileSystem object will be instantiated and called as such:
# obj = FileSystem()
# param_1 = obj.ls(path)
# obj.mkdir(path)
# obj.addContentToFile(filePath,content)
# param_4 = obj.readContentFromFile(filePath)</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 31 ms</p>
                    <p class="mb-0">内存: 16.5 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这道题使用前缀树 (Trie) 来实现一个内存文件系统。思路是：
1. 用一个 TrieNode 类来表示前缀树的节点，包含一个 defaultdict 类型的 child 字段存储子节点，一个 contents 字段存储文件内容。
2. FileSystem 类表示整个文件系统，包含一个 TrieNode 类型的 root 字段作为前缀树的根节点。
3. 对于不同的操作：
   - ls：从根节点开始，沿着给定路径逐层搜索对应的节点。如果该节点是文件，则返回文件名；如果是目录，则返回目录下的所有文件和子目录名，并按字典序排序。
   - mkdir：从根节点开始，沿着给定路径逐层插入对应的节点，缺失的中间目录也会被创建。
   - addContentToFile：类似 mkdir，但如果最后的节点已经存在则追加内容，否则创建新文件并写入内容。 
   - readContentFromFile：从根节点开始搜索给定路径对应的节点，返回其 contents 字段的内容。</p>
                        <p>时间复杂度: ls: O(L + klogk)，其中 L 是路径长度，k 是目录下子节点数量
mkdir、addContentToFile、readContentFromFile: O(L)，其中 L 是路径长度</p>
                        <p>空间复杂度: O(N)，其中 N 是文件系统中的总节点数</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class TrieNode:    
    def __init__(self):
        self.child = collections.defaultdict(TrieNode)  # 存储子节点的字典
        self.contents = &#34;&#34; # 存储文件内容，空字符串表示目录

class FileSystem:
    def __init__(self):
        self.root = TrieNode()  # 文件系统的根节点
               
    def _insert(self, path, content=&#34;&#34;):
        cur = self.root
        for c in path.split(&#34;/&#34;)[1:]:  # 沿路径逐层插入节点
            cur = cur.child[c]
        cur.contents += content # 更新文件内容
            
    def _search(self, path):   # 搜索给定路径对应的节点 
        cur = self.root
        for c in path.split(&#34;/&#34;)[1:]:
            if c in cur.child:
                cur = cur.child[c]
        return cur # 返回路径最后对应的节点
    
    def ls(self, path: str) -&gt; List[str]:  
        node = self._search(path)
        if node.contents: # 如果节点是文件，则返回文件名
            return [path.split(&#39;/&#39;)[-1]]    
        else: # 如果是目录，返回目录下的所有文件和子目录名
            return sorted(node.child.keys())    # 按字典序排序
        
    def mkdir(self, path: str) -&gt; None:  # 创建目录
        self._insert(path)
        
    def addContentToFile(self, filePath: str, content: str) -&gt; None:  # 追加或创建文件内容
        self._insert(filePath, content)
        
    def readContentFromFile(self, filePath: str) -&gt; str:  # 读取文件内容
        node = self._search(filePath)
        return node.contents
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>