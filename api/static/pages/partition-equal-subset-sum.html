<!DOCTYPE html>
<html lang="zh">
<head>
    <title>分割等和子集</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">分割等和子集</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        # n = len(nums)
        # total = sum(nums)
        # if total &amp; 1:
        #     return False
        # target = total // 2
        # # dp[i][j] 截止到索引i能否和为j
        # # dp[i][j] = dp[i - 1][j - nums[i]] or dp[i - 1][j]
        # dp = [[False] * (target + 1) for _ in range(n)]
        # for i in range(n):
        #     dp[i][0] = True
        # if nums[0] &lt;= target:
        #     dp[0][nums[0]] = True
        # for i in range(1, n):
        #     for j in range(1, target + 1):
        #         if j - nums[i] &gt;= 0:
        #             dp[i][j] = dp[i - 1][j - nums[i]] or dp[i - 1][j]
        #         else:
        #             dp[i][j] = dp[i - 1][j]
        # return dp[n - 1][target]

        
        #巧妙解法，记录每一次x求和结果
        s = sum(nums)
        if s &amp; 1:
            return False
        target = s &gt;&gt; 1
        # dp的二进制数中，从左往右数，从0开始，第i位表示能否组成和为i的集合
        dp = 1 &lt;&lt; target
        for x in nums:
            dp |= dp &gt;&gt; x
            # 提前返回答案
            if dp &amp; 1:
                return True
        return False


</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 30 ms</p>
                    <p class="mb-0">内存: 16.0 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解使用了动态规划的思路。首先判断数组的总和是否为奇数，如果是则不可能平分成两个等和子集。然后将目标和设为总和的一半。接下来使用一个整数dp作为状态，其二进制表示中从右往左第i位表示是否存在一个和为i的子集。通过遍历数组中的每个数x，将dp中所有已经置为1的位向右移动x位，再与原dp取或，这样就在dp中记录了当前数组前缀中所有可能的子集和。如果右移后dp的最低位变为1，说明存在一个子集的和等于目标和，直接返回True。遍历结束后，如果dp最低位仍为0，说明不存在符合条件的子集划分，返回False。</p>
                        <p>时间复杂度: O(n * target)</p>
                        <p>空间复杂度: O(1)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def canPartition(self, nums: List[int]) -&gt; bool:
        s = sum(nums)
        if s &amp; 1:
            return False
        target = s &gt;&gt; 1
        # dp的二进制数中，从右往左数，第i位表示是否存在一个和为i的子集
        dp = 1 &lt;&lt; target
        for x in nums:
            # 将dp中所有已经置为1的位向右移动x位，再与原dp取或
            dp |= dp &gt;&gt; x 
            # 如果右移后dp的最低位变为1，说明存在一个子集的和等于目标和，直接返回True
            if dp &amp; 1:
                return True
        # 遍历结束后，如果dp最低位仍为0，说明不存在符合条件的子集划分，返回False
        return False
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>