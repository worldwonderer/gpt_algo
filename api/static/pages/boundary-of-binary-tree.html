<!DOCTYPE html>
<html lang="zh">
<head>
    <title>二叉树的边界</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">二叉树的边界</strong>
                标签:
                
                    <a href="/problems?tag=tree" class="badge bg-secondary tag-link">树</a>
                
                    <a href="/problems?tag=depth-first-search" class="badge bg-secondary tag-link">深度优先搜索</a>
                
                    <a href="/problems?tag=binary-tree" class="badge bg-secondary tag-link">二叉树</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -&gt; List[int]:
        if not root: 
            return []   
        if not root.left and not root.right:
            return [root.val]
       
        def leftBoundary(root): # preorder
            if not root or (not root.left and not root.right): # exclude leaf
                return            
            res.append(root.val)           
            if root.left: # 如果有left substree, 描left as boundary
                leftBoundary(root.left)
            else: # if no substree, then use right as boundary
                leftBoundary(root.right)
           
        def rightBoundary(root): # postorder (so reversed order)
            if not root or (not root.left and not root.right):
                return
            if root.right: # 如果有right substree, 描right as boundary
                rightBoundary(root.right)
            else:
                rightBoundary(root.left)
            res.append(root.val)
       
        def leaves(node): # postorder
            if not node: 
                return
            if not node.left and not node.right:
                res.append(node.val)
            leaves(node.left)
            leaves(node.right)
        # eg 2
        # step 0
        res = [root.val]   # [1]
        # step 1: preorder to get the left boundary node value
        leftBoundary(root.left) # [2] # must use root.left, otherwise will add root twice
        # step 2: use dfs to find the leaves node value and append to the left boundary node value.  
        leaves(root) # [4, 7, 8, 9, 10]
         # step 3: use postorder to find the right boundary and append to the previous node values.   
        rightBoundary(root.right) # [6, 3]
        return res
        
        
     
        
        
&#34;&#34;&#34;   
Gist: 二叉树的 边界 是由 根节点 、左边界 、按从左到右顺序的 叶节点 和 逆序的右边界 ，按顺序依次连接组成。

This question can be solved by Depth First Search.

This question applied various of knowledge of tree. To solve this question, we first use preorder to get the left boundary node value, then we use dfs to find the leaves node value and append to the left boundary node value. At last, we use postorder to find the right boundary and append to the previous node values.

https://zhenyu0519.github.io/2020/03/13/lc545/
&#34;&#34;&#34;   </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 27 ms</p>
                    <p class="mb-0">内存: 17.5 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题目可以通过深度优先搜索（DFS）来解决。解题思路如下：
1. 先将根节点的值加入结果列表。
2. 通过先序遍历（preorder）得到左边界节点的值，并加入结果列表。注意要排除叶子节点。
3. 通过DFS找到所有叶子节点的值，按从左到右的顺序加入结果列表。
4. 通过后序遍历（postorder）得到右边界节点的值，并以逆序的方式加入结果列表。注意要排除叶子节点。</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def boundaryOfBinaryTree(self, root: Optional[TreeNode]) -&gt; List[int]:
        if not root: 
            return []   
        if not root.left and not root.right:
            return [root.val]
       
        def leftBoundary(root): # 先序遍历得到左边界节点值
            if not root or (not root.left and not root.right): # 排除叶子节点
                return            
            res.append(root.val)           
            if root.left: # 如果有左子树，以左子树为边界  
                leftBoundary(root.left)
            else: # 如果没有左子树，以右子树为边界
                leftBoundary(root.right)
           
        def rightBoundary(root): # 后序遍历得到右边界节点值（逆序） 
            if not root or (not root.left and not root.right): # 排除叶子节点
                return
            if root.right: # 如果有右子树，以右子树为边界
                rightBoundary(root.right)
            else: # 如果没有右子树，以左子树为边界
                rightBoundary(root.left)
            res.append(root.val)
       
        def leaves(node): # DFS寻找所有叶子节点
            if not node: 
                return
            if not node.left and not node.right:
                res.append(node.val)
            leaves(node.left)
            leaves(node.right)
        
        res = [root.val]   # 步骤1：加入根节点值
        leftBoundary(root.left) # 步骤2：先序遍历得到左边界节点值
        leaves(root) # 步骤3：DFS寻找叶子节点值，加入到结果列表
        rightBoundary(root.right) # 步骤4：后序遍历得到右边界节点值，逆序加入结果列表
        return res
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>