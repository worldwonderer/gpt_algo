<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最大二叉树 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>最大二叉树 II</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=tree" class="badge bg-secondary tag-link">树</a>
                    
                        <a href="/problems?tag=binary-tree" class="badge bg-secondary tag-link">二叉树</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p><strong>最大树</strong> 定义：一棵树，并满足：其中每个节点的值都大于其子树中的任何其他值。</p>

<p>给你最大树的根节点 <code>root</code> 和一个整数 <code>val</code> 。</p>

<p>就像 <a href="https://leetcode.cn/problems/maximum-binary-tree/" target="_blank">之前的问题</a> 那样，给定的树是利用 <code>Construct(a)</code>&nbsp;例程从列表&nbsp;<code>a</code>（<code>root = Construct(a)</code>）递归地构建的：</p>

<ul>
	<li>如果 <code>a</code> 为空，返回&nbsp;<code>null</code> 。</li>
	<li>否则，令&nbsp;<code>a[i]</code> 作为 <code>a</code> 的最大元素。创建一个值为&nbsp;<code>a[i]</code>&nbsp;的根节点 <code>root</code> 。</li>
	<li><code>root</code>&nbsp;的左子树将被构建为&nbsp;<code>Construct([a[0], a[1], ..., a[i - 1]])</code> 。</li>
	<li><code>root</code>&nbsp;的右子树将被构建为&nbsp;<code>Construct([a[i + 1], a[i + 2], ..., a[a.length - 1]])</code> 。</li>
	<li>返回&nbsp;<code>root</code> 。</li>
</ul>

<p>请注意，题目没有直接给出 <code>a</code> ，只是给出一个根节点&nbsp;<code>root = Construct(a)</code> 。</p>

<p>假设 <code>b</code> 是 <code>a</code> 的副本，并在末尾附加值 <code>val</code>。题目数据保证 <code>b</code> 中的值互不相同。</p>

<p>返回&nbsp;<code>Construct(b)</code> 。</p>



<p><strong>示例 1：</strong></p>

<p><strong><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-1.png" style="height: 160px; width: 159px;" /><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-1-2.png" style="height: 160px; width: 169px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [4,1,3,null,null,2], val = 5
<strong>输出：</strong>[5,4,null,1,3,null,null,2]
<strong>解释：</strong>a = [1,4,2,3], b = [1,4,2,3,5]</pre>

<p><strong>示例 2：<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-1.png" style="height: 160px; width: 180px;" /><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-2-2.png" style="height: 160px; width: 214px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [5,2,4,null,1], val = 3
<strong>输出：</strong>[5,2,4,null,1,null,3]
<strong>解释：</strong>a = [2,1,5,4], b = [2,1,5,4,3]</pre>

<p><strong>示例 3：<br />
<img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-1.png" style="height: 160px; width: 180px;" /><img alt="" src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/23/maximum-binary-tree-3-2.png" style="height: 160px; width: 201px;" /></strong></p>

<pre>
<strong>输入：</strong>root = [5,2,3,null,1], val = 4
<strong>输出：</strong>[5,2,4,null,1,3]
<strong>解释：</strong>a = [2,1,5,3], b = [2,1,5,3,4]
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li>树中节点数目在范围 <code>[1, 100]</code> 内</li>
	<li><code>1 &lt;= Node.val &lt;= 100</code></li>
	<li>树中的所有值 <strong>互不相同</strong></li>
	<li><code>1 &lt;= val &lt;= 100</code></li>
</ul>



                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 24 ms</p>
                    <p>内存: 16.0 MB</p>
                    <pre class="bg-light p-2 code-pre"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:
        if root is None:
            return TreeNode(val)
        elif val &gt; root.val:
            return TreeNode(val, left=root)
        else:
            root.right = self.insertIntoMaxTree(root.right, val)
            return root</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题解采用递归的方式插入新值到最大二叉树中。如果当前根节点为空，则直接返回新建立的节点；如果插入的值大于当前根节点的值，则新值将成为新的根节点，并且原来的树作为新根节点的左子树；如果插入的值小于或等于当前根节点的值，则递归地将新值插入到当前根节点的右子树中。</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def insertIntoMaxTree(self, root: Optional[TreeNode], val: int) -&gt; Optional[TreeNode]:
        # 如果当前节点为空，新值成为新的节点
        if root is None:
            return TreeNode(val)
        # 如果新值大于当前根节点值，新值成为新的根节点，原树为其左子树
        elif val &gt; root.val:
            return TreeNode(val, left=root)
        # 否则，递归地将新值插入到右子树
        else:
            root.right = self.insertIntoMaxTree(root.right, val)
            return root</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在插入操作中，如果插入的值小于或等于当前根节点的值，新值是如何保证一直保持最大二叉树的特性的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在最大二叉树中，每个节点的值都是其子树中最大的。当插入的值小于或等于当前根节点时，按照题解逻辑，该值会被递归地插入到右子树中。这种方法保持了最大二叉树的定义，因为新插入的值会被放在一个位置，使得它不会成为任何已存在的较大值的父节点。通过递归保证每个子树仍然维持最大二叉树的性质，新值会被逐层向下比较，直至找到合适的位置。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            如果新值需要插入到树的最右侧，会不会影响到树的平衡性？如果是，这个问题如何解决？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果新值需要不断地插入到树的最右侧，树会逐渐变得向右倾斜，这的确会影响到树的平衡性，使得树的高度逐渐增加，可能导致操作的效率下降。解决这一问题的方法通常包括使用平衡二叉树，如AVL树或红黑树，这些树结构可以在插入和删除操作后自动调整，保持树的高度尽可能低。然而，针对最大二叉树的特定属性，一种可能的方法是在必要时重构树，或者改变插入策略，尽量保持树的左右平衡。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            为什么插入一个新值时，新值大于根节点的值就必须使得新值成为新的根节点，并且把原树作为左子树？这样的操作有什么特定的优势吗？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>这种插入策略是由最大二叉树的定义决定的：树中的每个节点都是其子树中的最大值。当新值大于当前的根节点值时，为了保持这一性质，新值必须成为新的根节点。将原有的整个树变为新根节点的左子树是一个保持所有现有节点顺序和层级的简单方法，而且确保了新根节点是最大的，符合最大二叉树的定义。这样的操作有助于保持树结构的整体性和操作的简便性。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
                <aside class="related-problems-section">
                    <h2>Related Problems</h2>
                    <div class="list-group">
                        
                            <a href="/problem/maximum-binary-tree" class="list-group-item list-group-item-action">
                                最大二叉树
                            </a>
                        
                    </div>
                </aside>
            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/maximum-binary-tree-ii')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/maximum-binary-tree-ii/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>