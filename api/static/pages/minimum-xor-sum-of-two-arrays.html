<!DOCTYPE html>
<html lang="zh">
<head>
    <title>两个数组最小的异或值之和</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">两个数组最小的异或值之和</strong>
                标签:
                
                    <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                    <a href="/problems?tag=bitmask" class="badge bg-secondary tag-link">状态压缩</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">INF = 10**8

class Edge:
    def __init__(self, from_vertex: int, to_vertex: int, capacity: int, cost: int, flow: int) -&gt; None:
        self.from_vertex = from_vertex
        self.to_vertex = to_vertex
        self.capacity = capacity
        self.cost = cost
        self.flow = flow

class MinCostMaxFlow:
    def __init__(self, total_vertices: int, source: int, sink: int):
        self.total_vertices = total_vertices
        self.source = source
        self.sink = sink
        self.edges = []
        self.graph = [[] for _ in range(total_vertices)]
        self.distances = [INF] * total_vertices
        self.flow_values = [0] * total_vertices
        self.previous = [-1] * total_vertices

    def add_edge(self, from_vertex: int, to_vertex: int, capacity: int, cost: int) -&gt; None:
        self.edges.append(Edge(from_vertex, to_vertex, capacity, cost, 0))
        self.edges.append(Edge(to_vertex, from_vertex, 0, -cost, 0))
        self.graph[from_vertex].append(len(self.edges) - 2)
        self.graph[to_vertex].append(len(self.edges) - 1)

    def find_augmenting_path(self) -&gt; bool:
        self.flow_values = [0] * self.total_vertices
        self.previous = [-1] * self.total_vertices
        self.distances = [INF] * self.total_vertices
        self.distances[self.source] = 0
        self.flow_values[self.source] = INF

        priority_queue = [(0, self.source)]  # (distance, vertex)

        while priority_queue:
            dist_u, u = heappop(priority_queue)
            if dist_u &gt; self.distances[u]:  # Ignore outdated distances
                continue
            for edge_index in self.graph[u]:
                edge = self.edges[edge_index]
                v = edge.to_vertex
                if edge.capacity - edge.flow &gt; 0:
                    new_distance = self.distances[u] + edge.cost
                    if new_distance &lt; self.distances[v]:
                        self.distances[v] = new_distance
                        self.previous[v] = edge_index
                        self.flow_values[v] = min(self.flow_values[u], edge.capacity - edge.flow)
                        heappush(priority_queue, (self.distances[v], v))

        return self.previous[self.sink] != -1

    def compute(self) -&gt; Tuple[int, int]:
        max_flow, min_cost = 0, 0
        while self.find_augmenting_path():
            flow = self.flow_values[self.sink]
            max_flow += flow
            min_cost += flow * self.distances[self.sink]
            current_vertex = self.sink
            while current_vertex != self.source:
                edge_index = self.previous[current_vertex]
                self.edges[edge_index].flow += flow
                self.edges[edge_index ^ 1].flow -= flow
                current_vertex = self.edges[edge_index].from_vertex
        return max_flow, min_cost

class Solution:
    def minimumXORSum(self, nums1: List[int], nums2: List[int]) -&gt; int:
        n = len(nums1)
        source = 2 * n
        sink = source + 1
        network = MinCostMaxFlow(2 * n + 2, source, sink)
        
        # Connect source to all vertices in nums1
        for i in range(n):
            network.add_edge(source, i, 1, 0)
        
        # Connect all pairs of vertices between nums1 and nums2 with cost as their XOR value
        for i in range(n):
            for j in range(n):
                cost = nums1[i] ^ nums2[j]
                network.add_edge(i, j + n, 1, cost)
        
        # Connect all vertices in nums2 to sink
        for i in range(n):
            network.add_edge(i + n, sink, 1, 0)
        
        _, min_cost = network.compute()
        return min_cost</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 53 ms</p>
                    <p class="mb-0">内存: 16.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>该题解采用了最小费用最大流算法来求解最小的异或值之和。首先，定义一个流网络，其中源节点连接到数组 nums1 的每个节点，每个 nums1 的节点又与 nums2 的每个节点通过一条代表两数异或值的有向边相连，这些节点进一步连接到汇点。通过求解此网络的最小费用最大流，可以得到重新排列 nums2 后的最小异或值之和。</p>
                        <p>时间复杂度: O(n^2 * n * log n)</p>
                        <p>空间复杂度: O(n^2)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">import heapq

class Edge:
    def __init__(self, from_vertex, to_vertex, capacity, cost, flow):
        # 初始化边的基本属性
        self.from_vertex = from_vertex
        self.to_vertex = to_vertex
        self.capacity = capacity
        self.cost = cost
        self.flow = flow

class MinCostMaxFlow:
    def __init__(self, total_vertices, source, sink):
        # 初始化网络流图
        self.total_vertices = total_vertices
        self.source = source
        self.sink = sink
        self.edges = []
        self.graph = [[] for _ in range(total_vertices)]
        self.distances = [float(&#39;inf&#39;)] * total_vertices
        self.flow_values = [0] * total_vertices
        self.previous = [-1] * total_vertices

    def add_edge(self, from_vertex, to_vertex, capacity, cost):
        # 向图中添加边和反向边
        self.edges.append(Edge(from_vertex, to_vertex, capacity, cost, 0))
        self.edges.append(Edge(to_vertex, from_vertex, 0, -cost, 0))
        self.graph[from_vertex].append(len(self.edges) - 2)
        self.graph[to_vertex].append(len(self.edges) - 1)

    def find_augmenting_path(self):
        # 使用优先队列实现的 Dijkstra 算法找到增广路径
        self.flow_values = [0] * self.total_vertices
        self.previous = [-1] * self.total_vertices
        self.distances = [float(&#39;inf&#39;)] * self.total_vertices
        self.distances[self.source] = 0
        self.flow_values[self.source] = float(&#39;inf&#39;)
        priority_queue = [(0, self.source)]

        while priority_queue:
            dist_u, u = heapq.heappop(priority_queue)
            if dist_u &gt; self.distances[u]:
                continue
            for edge_index in self.graph[u]:
                edge = self.edges[edge_index]
                v = edge.to_vertex
                if edge.capacity - edge.flow &gt; 0:
                    new_distance = self.distances[u] + edge.cost
                    if new_distance &lt; self.distances[v]:
                        self.distances[v] = new_distance
                        self.previous[v] = edge_index
                        self.flow_values[v] = min(self.flow_values[u], edge.capacity - edge.flow)
                        heapq.heappush(priority_queue, (self.distances[v], v))

        return self.previous[self.sink] != -1

    def compute(self):
        # 计算最小费用最大流
        max_flow, min_cost = 0, 0
        while self.find_augmenting_path():
            flow = self.flow_values[self.sink]
            max_flow += flow
            min_cost += flow * self.distances[self.sink]
            current_vertex = self.sink
            while current_vertex != self.source:
                edge_index = self.previous[current_vertex]
                self.edges[edge_index].flow += flow
                self.edges[edge_index ^ 1].flow -= flow
                current_vertex = self.edges[edge_index].from_vertex
        return max_flow, min_cost

class Solution:
    def minimumXORSum(self, nums1, nums2):
        n = len(nums1)
        source = 2 * n
        sink = source + 1
        network = MinCostMaxFlow(2 * n + 2, source, sink)
        # 连接源点到 nums1 的每个顶点
        for i in range(n):
            network.add_edge(source, i, 1, 0)
        # 连接 nums1 和 nums2 的每对顶点，代价为它们的异或值
        for i in range(n):
            for j in range(n):
                cost = nums1[i] ^ nums2[j]
                network.add_edge(i, j + n, 1, cost)
        # 连接 nums2 的每个顶点到汇点
        for i in range(n):
            network.add_edge(i + n, sink, 1, 0)

        _, min_cost = network.compute()
        return min_cost</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>