<!DOCTYPE html>
<html lang="zh">
<head>
    <title>参加会议的最多员工数</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">参加会议的最多员工数</strong>
                标签:
                
                    <a href="/problems?tag=depth-first-search" class="badge bg-secondary tag-link">深度优先搜索</a>
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=topological-sort" class="badge bg-secondary tag-link">拓扑排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maximumInvitations(self, favorite: List[int]) -&gt; int:
        n = len(favorite)
        deg = [0] * n
        for f in favorite:
            deg[f] += 1  # 统计基环树每个节点的入度

        max_depth = [1] * n
        q = deque(i for i, d in enumerate(deg) if d == 0)
        while q:  # 拓扑排序，剪掉图上所有树枝
            x = q.popleft()
            y = favorite[x]  # x 只有一条出边
            max_depth[y] = max_depth[x] + 1
            deg[y] -= 1
            if deg[y] == 0:
                q.append(y)

        max_ring_size = sum_chain_size = 0
        for i, d in enumerate(deg):
            if d == 0: continue

            # 遍历基环上的点
            deg[i] = 0  # 将基环上的点的入度标记为 0，避免重复访问
            ring_size = 1  # 基环长度
            x = favorite[i]
            while x != i:
                deg[x] = 0  # 将基环上的点的入度标记为 0，避免重复访问
                ring_size += 1
                x = favorite[x]

            if ring_size == 2:  # 基环长度为 2
                sum_chain_size += max_depth[i] + max_depth[favorite[i]]  # 累加两条最长链的长度
            else:
                max_ring_size = max(max_ring_size, ring_size)  # 取所有基环长度的最大值
        return max(max_ring_size, sum_chain_size)
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 163 ms</p>
                    <p class="mb-0">内存: 28.8 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解利用了图论中基环树（cactus）的概念，将问题转化为在有向图中找到最大的基环树的大小。首先，通过计算每个员工被喜欢的次数（即入度），可以识别并删除所有的树枝，这是通过拓扑排序实现的。在拓扑排序过程中，我们也计算了从每个树叶到其树根的最长路径长度。其次，对于残留在图中的环，我们需要特别处理长度为2的环，因为这种环可以利用其外部的链条来增加参与会议的人数。最后，比较由长度为2的环构成的链和最大环的大小，返回最大值，即为最多可能参加会议的员工数。</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def maximumInvitations(self, favorite: List[int]) -&gt; int:
        n = len(favorite)
        deg = [0] * n  # 统计每个节点的入度
        for f in favorite:
            deg[f] += 1

        max_depth = [1] * n
        q = deque(i for i, d in enumerate(deg) if d == 0)  # 入度为0的节点入队
        while q:  # 拓扑排序处理
            x = q.popleft()
            y = favorite[x]
            max_depth[y] = max(max_depth[x] + 1, max_depth[y])
            deg[y] -= 1
            if deg[y] == 0:
                q.append(y)

        max_ring_size = sum_chain_size = 0
        for i in range(n):
            if deg[i] == 0: continue  # 跳过已处理的节点

            # 处理环
            ring_size = 1
            x = i
            y = favorite[x]
            while y != i:
                x = y
                y = favorite[x]
                ring_size += 1
                deg[x] = 0  # 标记节点已访问

            if ring_size == 2:
                sum_chain_size += max_depth[i] + max_depth[favorite[i]]
            else:
                max_ring_size = max(max_ring_size, ring_size)

        return max(max_ring_size, sum_chain_size)  # 返回最大值</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>