<!DOCTYPE html>
<html lang="zh">
<head>
    <title>环形数组是否存在循环</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">环形数组是否存在循环</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=two-pointers" class="badge bg-secondary tag-link">双指针</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
        # Get the length of the input list
        length = len(nums)

        # Define a function to find the next index in a circular manner
        def get_next_index(current_index):
            # Calculate the next index considering wrapping around
            return (current_index + nums[current_index]) % length

        # Iterate over all elements in the array
        for i in range(length):
            # Skip if the current element is already marked as 0, indicating it&#39;s not part of a loop
            if nums[i] == 0:
                continue
          
            # Initialize the slow and fast pointers for cycle detection
            slow_pointer = i
            fast_pointer = get_next_index(i)
          
            # Continue moving pointers while the signs of the elements indicate a potential loop
            # This also ensures that we are not mixing cycles of different directions
            while nums[slow_pointer] * nums[fast_pointer] &gt; 0 and nums[slow_pointer] * nums[get_next_index(fast_pointer)] &gt; 0:
                # If the slow and fast pointers meet, a cycle is detected
                if slow_pointer == fast_pointer:
                    # Check to ensure the loop is longer than 1 element
                    if slow_pointer != get_next_index(slow_pointer):
                        return True
                    # If the loop is just one element, break and mark it as non-looping
                    break
              
                # Move slow pointer by one step and fast pointer by two steps
                slow_pointer = get_next_index(slow_pointer)
                fast_pointer = get_next_index(get_next_index(fast_pointer))
          
            # Mark all visited elements as 0 to avoid revisiting and repeated calculations
            # This process will also ensure elimination of non-loop elements
            index = i
            while nums[index] * nums[get_next_index(index)] &gt; 0:
                next_index = get_next_index(index)
                nums[index] = 0
                index = next_index

        # If no loop is found, return False
        return False


# Intuition

# To address this problem, we need to consider that a cycle can only exist if we&#39;re moving consistently in one direction and eventually end up where we started. This naturally brings the &#34;fast and slow pointers&#34; technique to mind, which is often used for cycle detection in linked lists.

# The fast and slow pointers method involves two pointers moving at different speeds, and if there is a cycle, they will eventually meet. We apply the same principle here:

# The slow pointer moves one step at a time.
# The fast pointer moves two steps at a time.
# If slow and fast meet at the same index, and this index is not the same as the next step (to prevent single-element loops, which aren&#39;t considered valid cycles), we have found a cycle.

# At each step, we also verify that the direction does not change. If the product of nums[slow] and nums[fast] is positive, they are either both positive or both negative, thus maintaining a consistent direction. If this product is negative or if we reach an element that is already marked as visited (a value of 0), we do not have a valid cycle from that start point.

# For each element, if it does not lead to a cycle, we mark the visited elements as 0 to avoid re-checking them in the future, thereby optimizing our algorithm. This marking also helps to invalidate any non-cycle paths swiftly.

# Overall, the algorithm is to iterate over each element and use the fast and slow pointer method to detect a cycle. If any cycle is found, return true. After checking all possibilities, if no cycle is found, return false.

# Solution Approach
# The implementation of the solution for detecting a cycle in the circular array follows these main steps:

# Array Length Extraction: We start by obtaining the length n of the input array nums. This is crucial since we need to calculate the next index correctly within the circular context:

# n = len(nums)
# Helper Function for Index Calculation: Since the array is circular, we define a function named next() that takes an index i and returns the next index we should move to, according to nums[i], and wraps around the array if necessary:

# def next(i):
#     return (i + nums[i]) % n
# We ensure that the result of the movement remains within the bounds of the array indices by taking the modulo with n.

# Main Loop to Check for Cycles: We iterate through each element in the array to check for cycles starting from that index:

# for i in range(n):
#     if nums[i] == 0:  # Skip already marked elements (no cycle from this point)
#         continue
# Fast and Slow Pointers Initialization: For each starting index, we initiate slow and fast pointers, which represent the current position of each pointer:

# slow, fast = i, next(i)
# Cycle Detection Loop: Next, we loop to detect cycles using the following conditions:

# The product of nums[slow] and nums[fast] must be positive, indicating they move in the same direction.
# The product of nums[slow] and nums[next(fast)] must also be positive, ensuring that the fast pointer also continues in the same direction after two moves.
# while nums[slow] * nums[fast] &gt; 0 and nums[slow] * nums[next(fast)] &gt; 0:
#     if slow == fast:  # Pointers meet, indicating a potential cycle
#         if slow != next(slow):  # Check to avoid single-length cycle
#             return True
#         break
# Marking Elements: If not a valid cycle, we need to mark elements associated with the failed attempt to find a cycle to prevent re-processing them in future iterations. This is achieved by setting each involved element to 0:

# j = i
# while nums[j] * nums[next(j)] &gt; 0:
#     nums[j] = 0  # Marking the element
#     j = next(j)
# Final Return: After exhaustively checking all indices, if no cycle is found, the function returns false.

# This solution leverages the cyclical two-pointer technique to identify cycles and uses in-place marking to improve efficiency by reducing redundant checks. The use of the modulo operator ensures proper index wrapping within the circular array boundaries, and thorough condition checks maintain consistency in direction for cycle validation.

</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 23 ms</p>
                    <p class="mb-0">内存: 16.1 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题的解决方案采用了快慢指针的思想。通过快慢两个指针在环形数组中移动，如果存在循环，它们最终会相遇。同时，在移动过程中也要检查移动的方向是否一致，只有方向一致的情况下才可能形成循环。对于非循环的元素，将其标记为0，避免重复访问。最后，如果遍历完整个数组都没有发现循环，则返回 false。</p>
                        <p>时间复杂度: O(n^2)</p>
                        <p>空间复杂度: O(1)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def circularArrayLoop(self, nums: List[int]) -&gt; bool:
        length = len(nums)

        def get_next_index(current_index):
            # 计算考虑环形数组的下一个索引
            return (current_index + nums[current_index]) % length

        for i in range(length):
            # 如果当前元素已标记为0，说明无法形成循环，跳过
            if nums[i] == 0:
                continue
          
            # 初始化快慢指针
            slow_pointer = i
            fast_pointer = get_next_index(i)
          
            # 当快慢指针移动方向一致且未到达已访问过的元素时，继续移动指针
            while nums[slow_pointer] * nums[fast_pointer] &gt; 0 and nums[slow_pointer] * nums[get_next_index(fast_pointer)] &gt; 0:
                # 如果快慢指针相遇，说明存在循环
                if slow_pointer == fast_pointer:
                    # 进一步检查循环长度是否大于1
                    if slow_pointer != get_next_index(slow_pointer):
                        return True
                    # 如果循环长度为1，跳出循环并标记该元素
                    break
              
                # 慢指针移动一步，快指针移动两步
                slow_pointer = get_next_index(slow_pointer)
                fast_pointer = get_next_index(get_next_index(fast_pointer))
          
            # 标记所有访问过的非循环元素为0，避免重复访问
            index = i
            while nums[index] * nums[get_next_index(index)] &gt; 0:
                next_index = get_next_index(index)
                nums[index] = 0
                index = next_index

        # 如果遍历完数组未发现循环，返回 False
        return False
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>