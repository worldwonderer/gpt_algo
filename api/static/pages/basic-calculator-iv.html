<!DOCTYPE html>
<html lang="zh">
<head>
    <title>基本计算器 IV</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">基本计算器 IV</strong>
                标签:
                
                    <a href="/problems?tag=stack" class="badge bg-secondary tag-link">栈</a>
                
                    <a href="/problems?tag=recursion" class="badge bg-secondary tag-link">递归</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Poly(collections.Counter):
    def __add__(self, other):
        self.update(other)
        return self

    def __sub__(self, other):
        self.update({k: -v for k, v in other.items()})
        return self

    def __mul__(self, other):
        ans = Poly()
        for k1, v1 in self.items():
            for k2, v2 in other.items():
                ans.update({tuple(sorted(k1 + k2)): v1 * v2})
        return ans

    def evaluate(self, evalmap):
        ans = Poly()
        for k, c in self.items():
            free = []
            for token in k:
                if token in evalmap:
                    c *= evalmap[token]
                else:
                    free.append(token)
            ans[tuple(free)] += c
        return ans

    def to_list(self):
        p = sorted(self.items(), key=lambda kv: (-len(kv[0]), kv[0], kv[1]))
        return [&#39;*&#39;.join((str(v),) + k) for k, v in p if v]

class Solution(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):
        evalmap = dict(zip(evalvars, evalints))

        def combine(left, right, symbol):
            if symbol == &#39;+&#39;: return left + right
            if symbol == &#39;-&#39;: return left - right
            if symbol == &#39;*&#39;: return left * right
            raise

        def make(expr):
            ans = Poly()
            if expr.isdigit():
                ans.update({(): int(expr)})
            else:
                ans[(expr,)] += 1
            return ans

        def parse(expr):
            bucket = []
            symbols = []
            i = 0
            while i &lt; len(expr):
                if expr[i] == &#39;(&#39;:
                    bal = 0
                    for j in range(i, len(expr)):
                        if expr[j] == &#39;(&#39;: bal += 1
                        if expr[j] == &#39;)&#39;: bal -= 1
                        if bal == 0: break
                    bucket.append(parse(expr[i+1:j]))
                    i = j
                elif expr[i].isalnum():
                    for j in range(i, len(expr)):
                        if expr[j] == &#39; &#39;:
                            bucket.append(make(expr[i:j]))
                            break
                    else:
                        bucket.append(make(expr[i:]))
                    i = j
                elif expr[i] in &#39;+-*&#39;:
                    symbols.append(expr[i])
                i += 1

            for i in range(len(symbols) - 1, -1, -1):
                if symbols[i] == &#39;*&#39;:
                    bucket[i] = combine(bucket[i], bucket.pop(i+1),
                                        symbols.pop(i))

            if not bucket: return Poly()
            ans = bucket[0]
            for i, symbol in enumerate(symbols, 1):
                ans = combine(ans, bucket[i], symbol)

            return ans

        P = parse(expression).evaluate(evalmap)
        return P.to_list()</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 34 ms</p>
                    <p class="mb-0">内存: 16.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>题解使用了一种多项式处理方法，通过自定义的Poly类（基于collections.Counter），来表示和操作多项式。每个Poly实例表示一个多项式，其中键是变量组合的元组，值是相应的系数。

1. __add__ 和 __sub__ 方法重载了加法和减法运算符来合并和减去多项式。
2. __mul__ 方法通过嵌套循环计算两个多项式的乘积，组合项的所有可能的变量组合，并更新结果多项式。
3. evaluate 方法通过给定的变量映射替换变量值，并合并多项式中相同的项。
4. to_list 方法用于将多项式转换为规定格式的字符串列表，按照项的次数（降序）、变量的字典序排列。

解析表达式的过程(parse)使用递归来处理括号和操作符，生成相应的多项式对象。该方法首先分离出各个组成部分（数字、变量或括号内的表达式），并根据运算符适当组合它们。</p>
                        <p>时间复杂度: O(n + m^2)，其中n是表达式的长度，m是操作数中项的数量</p>
                        <p>空间复杂度: O(m^2)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Poly(collections.Counter):
    # 初始化多项式，继承Counter以方便统计和操作
    def __add__(self, other):
        # 加法操作，更新当前多项式的每个项
        self.update(other)
        return self

    def __sub__(self, other):
        # 减法操作，更新当前多项式，为other的每个项系数取反
        self.update({k: -v for k, v in other.items()})
        return self

    def __mul__(self, other):
        # 乘法操作，计算当前多项式与另一多项式的所有项的乘积
        ans = Poly()
        for k1, v1 in self.items():
            for k2, v2 in other.items():
                ans.update({tuple(sorted(k1 + k2)): v1 * v2})
        return ans

    def evaluate(self, evalmap):
        # 计算多项式的值，替换变量为具体数值
        ans = Poly()
        for k, c in self.items():
            free = []
            for token in k:
                if token in evalmap:
                    c *= evalmap[token]
                else:
                    free.append(token)
            ans[tuple(free)] += c
        return ans

    def to_list(self):
        # 转换多项式为规定格式的字符串列表
        p = sorted(self.items(), key=lambda kv: (-len(kv[0]), kv[0], kv[1]))
        return [&#39;*&#39;.join((str(v),) + k) for k, v in p if v]

class Solution(object):
    def basicCalculatorIV(self, expression, evalvars, evalints):
        evalmap = dict(zip(evalvars, evalints))

        def combine(left, right, symbol):
            # 根据符号执行相应的多项式运算
            if symbol == &#39;+&#39;: return left + right
            if symbol == &#39;-&#39;: return left - right
            if symbol == &#39;*&#39;: return left * right
            raise

        def make(expr):
            # 生成多项式对象，将表达式转换为多项式
            ans = Poly()
            if expr.isdigit():
                ans.update({(): int(expr)})
            else:
                ans[(expr,)] += 1
            return ans

        def parse(expr):
            # 解析表达式，处理括号和操作符，递归构造多项式
            bucket = []
            symbols = []
            i = 0
            while i &lt; len(expr):
                if expr[i] == &#39;(&#39;: 
                    bal = 0
                    for j in range(i, len(expr)):
                        if expr[j] == &#39;(&#39;: bal += 1
                        if expr[j] == &#39;)&#39;: bal -= 1
                        if bal == 0: break
                    bucket.append(parse(expr[i+1:j]))
                    i = j
                elif expr[i].isalnum():
                    for j in range(i, len(expr)):
                        if expr[j] == &#39; &#39;:
                            bucket.append(make(expr[i:j]))
                            break
                    else:
                        bucket.append(make(expr[i:]))
                    i = j
                elif expr[i] in &#39;+-*&#39;:
                    symbols.append(expr[i])
                i += 1

            for i in range(len(symbols) - 1, -1, -1):
                if symbols[i] == &#39;*&#39;:
                    bucket[i] = combine(bucket[i], bucket.pop(i+1),
                                        symbols.pop(i))

            if not bucket: return Poly()
            ans = bucket[0]
            for i, symbol in enumerate(symbols, 1):
                ans = combine(ans, bucket[i], symbol)

            return ans

        P = parse(expression).evaluate(evalmap)
        return P.to_list()
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>