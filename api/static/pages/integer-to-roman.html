<!DOCTYPE html>
<html lang="zh">
<head>
    <title>整数转罗马数字</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>整数转罗马数字</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                    
                        <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>罗马数字包含以下七种字符： <code>I</code>， <code>V</code>， <code>X</code>， <code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p>

<pre>
<strong>字符</strong>          <strong>数值</strong>
I             1
V             5
X             10
L             50
C             100
D             500
M             1000</pre>

<p>例如， 罗马数字 2 写做 <code>II</code> ，即为两个并列的 1。12 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 27 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p>

<p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p>

<ul>
	<li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li>
	<li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li>
	<li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。</li>
</ul>

<p>给你一个整数，将其转为罗马数字。</p>

<p> </p>

<p><strong>示例 1:</strong></p>

<pre>
<strong>输入:</strong> num = 3
<strong>输出:</strong> "III"</pre>

<p><strong>示例 2:</strong></p>

<pre>
<strong>输入:</strong> num = 4
<strong>输出:</strong> "IV"</pre>

<p><strong>示例 3:</strong></p>

<pre>
<strong>输入:</strong> num = 9
<strong>输出:</strong> "IX"</pre>

<p><strong>示例 4:</strong></p>

<pre>
<strong>输入:</strong> num = 58
<strong>输出:</strong> "LVIII"
<strong>解释:</strong> L = 50, V = 5, III = 3.
</pre>

<p><strong>示例 5:</strong></p>

<pre>
<strong>输入:</strong> num = 1994
<strong>输出:</strong> "MCMXCIV"
<strong>解释:</strong> M = 1000, CM = 900, XC = 90, IV = 4.</pre>

<p> </p>

<p><strong>提示：</strong></p>

<ul>
	<li><code>1 <= num <= 3999</code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 52 ms</p>
                    <p>内存: 14.7 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def intToRoman(self, num: int) -&gt; str:
        values = [1000,900,500,400,100,90,50,40,10,9,5,4,1]
        reps = [&#34;M&#34;,&#34;CM&#34;,&#34;D&#34;,&#34;CD&#34;,&#34;C&#34;,&#34;XC&#34;,&#34;L&#34;,&#34;XL&#34;,&#34;X&#34;,&#34;IX&#34;,&#34;V&#34;,&#34;IV&#34;,&#34;I&#34;]

        ans = &#34;&#34;
        for i, value in enumerate(values):
            while num &gt;= value:
                ans += reps[i]
                num -= value
        return ans
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>此题解采用了贪心算法的思想。首先定义两个列表，values和reps，分别存储罗马数字的数值和对应的字符表示。然后从大到小遍历values列表中的每个数值，对于每个数值，如果输入的整数num大于等于该数值，则将对应的罗马数字字符添加到答案字符串中，并从num中减去该数值。这个过程重复进行，直到num减到0为止。这样，就可以保证每次都是用尽可能大的罗马数字来表示输入的整数，符合罗马数字的表示规则。</p>
                                <p>时间复杂度: O(1)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2">class Solution:
    def intToRoman(self, num: int) -&gt; str:
        values = [1000,900,500,400,100,90,50,40,10,9,5,4,1]  # 罗马数字的数值列表
        reps = [&#39;M&#39;,&#39;CM&#39;,&#39;D&#39;,&#39;CD&#39;,&#39;C&#39;,&#39;XC&#39;,&#39;L&#39;,&#39;XL&#39;,&#39;X&#39;,&#39;IX&#39;,&#39;V&#39;,&#39;IV&#39;,&#39;I&#39;]  # 罗马数字的字符表示列表

        ans = &#39;&#39;  # 初始化结果字符串
        for i, value in enumerate(values):  # 遍历数值列表
            while num &gt;= value:  # 如果输入的整数大于等于当前的数值
                ans += reps[i]  # 添加对应的罗马数字字符到结果字符串
                num -= value  # 从输入的整数中减去当前的数值
        return ans  # 返回结果字符串</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            贪心算法如何确保每次选择都是最优的，以得到正确的罗马数字表示？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>贪心算法通过每次选择当前可用的最大值来确保选择最优。在罗马数字转换的场景中，从最大的罗马数字开始逐一尝试，并从数值中减去相应的罗马数字数值，确保每一步都尽可能使用最大数值的罗马数字。这种方法符合罗马数字构造规则，确保了每一步的选择都是局部最优，从而实现整体上的最优解。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在算法中遍历values列表的顺序为何是从大到小，这种顺序的选择对算法的效率有何影响？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>遍历values列表的顺序从大到小是为了尽快减少num的值，这样可以减少循环的次数，从而提高算法的效率。如果从小到大遍历，可能会增加循环的次数，因为需要多次添加较小的罗马数字来组成同一个数值，这会导致效率降低。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            你是如何确定values和reps列表的具体内容和顺序的，这些元素是如何与罗马数字的规则相匹配的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>values和reps列表的内容和顺序是基于罗马数字的标准表示法以及特殊规则确定的。列表中不仅包含单一字符如&#39;I&#39;, &#39;V&#39;等，还包括特殊组合如&#39;IV&#39;, &#39;IX&#39;等，这些组合代表特定的数值（如4和9），这样的排列顺序使得算法能直接利用这些组合来精确表示任何数值，遵循了罗马数字的构造规则。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            在这个算法中，如果num初始值非常小，例如接近1，这种情况下算法的性能如何？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果num的初始值非常小，算法的性能非常高效。因为values列表是从大到小排序的，算法会快速跳过所有大于num的值，直接找到与num相匹配的最小罗马数字。由于不需要多次减法和循环迭代，这种情况下的时间复杂度接近常数时间。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader5">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse5" aria-expanded="false" aria-controls="exploreCollapse5">
                                            题解提到时间复杂度主要取决于values列表的长度，那么具体是如何估计这个算法的时间复杂度的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse5" class="collapse" aria-labelledby="exploreHeader5" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>时间复杂度的估计基于values列表的长度和对每个数值的减法操作的次数。虽然num的大小和减法操作次数有关，但因为values列表长度固定，所以最坏情况下的循环次数也是固定的。由于列表长度为13，每次循环检查num是否大于等于当前values中的元素，这种固定长度的列表使得算法时间复杂度可视为O(1)，即常数时间复杂度。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader6">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse6" aria-expanded="false" aria-controls="exploreCollapse6">
                                            空间复杂度是常量级别的，这是否意味着算法对内存的使用非常少，有没有可能进一步优化？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse6" class="collapse" aria-labelledby="exploreHeader6" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>空间复杂度为常量级意味着算法对内存的使用确实非常少，主要是因为使用了固定大小的values和reps列表及一个字符串来存储结果。由于这些结构的大小与输入的整数无关，因此算法的内存使用非常高效。进一步的优化可能不是很必要，但如果需要，可以考虑使用更加高效的数据结构或方法来存储结果，例如使用字符数组代替字符串操作以减少在字符串操作时可能发生的内存重新分配。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
                <aside class="related-problems-section">
                    <h2>Related Problems</h2>
                    <div class="list-group">
                        
                            <a href="/problem/roman-to-integer" class="list-group-item list-group-item-action">
                                罗马数字转整数
                            </a>
                        
                            <a href="/problem/integer-to-english-words" class="list-group-item list-group-item-action">
                                整数转换英文表示
                            </a>
                        
                    </div>
                </aside>
            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/integer-to-roman')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/integer-to-roman/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>