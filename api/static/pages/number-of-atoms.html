<!DOCTYPE html>
<html lang="zh">
<head>
    <title>原子的数量</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">原子的数量</strong>
                标签:
                
                    <a href="/problems?tag=stack" class="badge bg-secondary tag-link">栈</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                    <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def countOfAtoms(self, formula: str) -&gt; str:
        stack = []
        last_atom = &#34;&#34;
        coef = 1
        for i in range(len(formula)):
            s = formula[i]
            if s == &#34;(&#34;:
                if last_atom != &#34;&#34;:
                    stack.append((last_atom, 1))
                    last_atom = &#34;&#34;
                stack.append(&#34;(&#34;)
            elif s == &#34;)&#34;:
                if last_atom != &#34;&#34;:
                    stack.append((last_atom, 1))
                    last_atom = &#34;&#34;
            elif s.isnumeric():
                if formula[i-1].isnumeric():
                    continue
                j = i + 1
                while j &lt; len(formula) and formula[j].isnumeric():
                    j += 1
                n = int(formula[i:j])
                if formula[i-1] != &#34;)&#34;:
                    stack.append((last_atom, n))
                    last_atom = &#34;&#34;
                else:
                    coef = n
                    temp_stack = []
                    curr_pair = stack.pop()
                    while curr_pair != &#34;(&#34;:
                        temp_stack.append((curr_pair[0], curr_pair[1] * coef))
                        curr_pair = stack.pop()
                    for k in range(len(temp_stack)-1, -1, -1):
                        stack.append(temp_stack[k])
            else:
                if s.islower():
                    last_atom += s
                    if i == len(formula)-1:
                        stack.append((last_atom, 1))
                else:
                    if last_atom == &#34;&#34;:
                        last_atom = s
                        if i == len(formula)-1:
                            stack.append((last_atom, 1))
                    else:
                        stack.append((last_atom, 1))
                        last_atom = s
        counter = {}
        for pair in stack:
            if pair != &#34;(&#34;:
                if pair[0] not in counter:
                    counter[pair[0]] = pair[1]
                else:
                    counter[pair[0]] += pair[1]
        res = []
        for atom, count in sorted(counter.items()):
            if count == 1:
                res.append(atom)
            else:
                res.append(atom+str(count))
        return &#34;&#34;.join(res)
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 29 ms</p>
                    <p class="mb-0">内存: 0.0 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解使用了栈的数据结构来解决问题。它从左到右遍历化学式字符串，对于每个字符进行分情况讨论：
1. 如果是左括号，将当前原子入栈，并清空当前原子。
2. 如果是右括号，将当前原子入栈，并清空当前原子。
3. 如果是数字，判断前一个字符是否也是数字，如果是则继续遍历；否则将当前原子和数字作为一个元组入栈，并清空当前原子。如果前一个字符是右括号，则将数字作为括号内原子的系数，将括号内的所有原子依次出栈并乘以系数后重新入栈。
4. 如果是小写字母，将其加入当前原子的名称中。
5. 如果是大写字母，将当前原子入栈，并将该大写字母作为新的当前原子。

遍历完成后，将栈中的所有原子及其数量存入哈希表中，最后按照字典序将哈希表中的原子拼接成字符串返回。</p>
                        <p>时间复杂度: O(nlogn)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def countOfAtoms(self, formula: str) -&gt; str:
        stack = []
        last_atom = &#34;&#34;
        coef = 1
        for i in range(len(formula)):
            s = formula[i]
            if s == &#34;(&#34;:
                if last_atom != &#34;&#34;:  # 将当前原子入栈
                    stack.append((last_atom, 1))
                    last_atom = &#34;&#34;
                stack.append(&#34;(&#34;)  # 将左括号入栈
            elif s == &#34;)&#34;:
                if last_atom != &#34;&#34;:  # 将当前原子入栈
                    stack.append((last_atom, 1))
                    last_atom = &#34;&#34;
            elif s.isnumeric():
                if formula[i-1].isnumeric():  # 如果前一个字符也是数字，则继续遍历
                    continue
                j = i + 1
                while j &lt; len(formula) and formula[j].isnumeric():  # 找到完整的数字
                    j += 1
                n = int(formula[i:j])
                if formula[i-1] != &#34;)&#34;: # 如果前一个字符不是右括号，将当前原子和数字作为一个元组入栈
                    stack.append((last_atom, n))
                    last_atom = &#34;&#34;
                else:  # 如果前一个字符是右括号，将数字作为括号内原子的系数
                    coef = n
                    temp_stack = []
                    curr_pair = stack.pop()
                    while curr_pair != &#34;(&#34;:  # 将括号内的所有原子依次出栈并乘以系数
                        temp_stack.append((curr_pair[0], curr_pair[1] * coef))
                        curr_pair = stack.pop()
                    for k in range(len(temp_stack)-1, -1, -1):  # 将括号内的所有原子重新入栈
                        stack.append(temp_stack[k])
            else:
                if s.islower():  # 如果是小写字母，将其加入当前原子的名称中
                    last_atom += s
                    if i == len(formula)-1:  # 如果是最后一个字符，将当前原子入栈
                        stack.append((last_atom, 1))
                else:
                    if last_atom == &#34;&#34;:  # 如果是大写字母，将其作为新的当前原子
                        last_atom = s
                        if i == len(formula)-1:  # 如果是最后一个字符，将当前原子入栈
                            stack.append((last_atom, 1))
                    else:  # 如果当前原子不为空，将其入栈，并将该大写字母作为新的当前原子
                        stack.append((last_atom, 1))
                        last_atom = s
        counter = {}
        for pair in stack:
            if pair != &#34;(&#34;:  # 将栈中的所有原子及其数量存入哈希表中
                if pair[0] not in counter:
                    counter[pair[0]] = pair[1]
                else:
                    counter[pair[0]] += pair[1]
        res = []
        for atom, count in sorted(counter.items()):  # 按照字典序将哈希表中的原子拼接成字符串
            if count == 1:
                res.append(atom)
            else:
                res.append(atom+str(count))
        return &#34;&#34;.join(res)
</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>