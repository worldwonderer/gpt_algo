<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最大公约数遍历</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">最大公约数遍历</strong>
                标签:
                
                    <a href="/problems?tag=union-find" class="badge bg-secondary tag-link">并查集</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=number-theory" class="badge bg-secondary tag-link">数论</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -&gt; bool:
        length = len(nums)
        if length == 1 : return True
        if 1 in nums: return False
        nums = sorted(set(nums), reverse = True)

        if ( length:=len(nums)) == 1: return True
        
        for i in range(length - 1):
            for j in range(i+1, length):
                if gcd(nums[i],nums[j]) - 1:
                    nums[j] *= nums[i]
                    break
            else:
                return False        
        
        return True</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 70 ms</p>
                    <p class="mb-0">内存: 29.7 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The given solution tries to determine if any pair of indices in the array can be traversed using the greatest common divisor (gcd) condition. It first checks trivial cases such as single-element arrays and arrays containing the number &#39;1&#39;. Afterwards, it removes duplicates and sorts the array in descending order. The code then attempts to check if, for each element, there exists another element with a gcd greater than 1. If it finds such a pair, it modifies the second element by multiplying it with the first, presumably to increase future gcd values artificially. If it cannot find any such pair for any element, it returns False, otherwise True if all elements can be paired up successfully.</p>
                        <p>时间复杂度: O(n^2)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def canTraverseAllPairs(self, nums: List[int]) -&gt; bool:
        length = len(nums)
        if length == 1 : return True  # If there&#39;s only one element, traversal is trivially possible
        if 1 in nums: return False  # &#39;1&#39; cannot have gcd greater than 1 with any number
        nums = sorted(set(nums), reverse = True)  # Remove duplicates and sort in descending order

        if ( length:=len(nums)) == 1: return True  # Check again in case of single unique element

        for i in range(length - 1):
            for j in range(i+1, length):
                if gcd(nums[i],nums[j]) &gt; 1:  # Check if gcd is greater than 1
                    nums[j] *= nums[i]  # Modify the number to potentially increase future gcd calculations
                    break
            else:  # No valid gcd found for current element &#39;i&#39;
                return False  # Not all pairs can be traversed
        return True  # All pairs can be traversed if the loop completes</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>