<!DOCTYPE html>
<html lang="zh">
<head>
    <title>最小跳跃次数</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">最小跳跃次数</strong>
                标签:
                
                    <a href="/problems?tag=breadth-first-search" class="badge bg-secondary tag-link">广度优先搜索</a>
                
                    <a href="/problems?tag=segment-tree" class="badge bg-secondary tag-link">线段树</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minJump(self, jump: List[int]) -&gt; int:
        left_max_vis_idx = 0
        visited_status = set()
        queue = [0]
        n = len(jump)
        ans  = 0
        if n == 1:
            return 0
        while queue:
            tmp = queue
            queue = []
            ans += 1
            for item in tmp:
                next_item = item + jump[item]
                if next_item &gt;= n:
                    return ans
                if next_item not in visited_status and next_item &gt; left_max_vis_idx:
                    queue.append(next_item)
                    visited_status.add(next_item)
                if item &gt; left_max_vis_idx:
                    for j in range(left_max_vis_idx + 1, item):
                        queue.append(j)
                    left_max_vis_idx = item
        return ans
                </code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 244 ms</p>
                    <p class="mb-0">内存: 79.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The solution uses a breadth-first search (BFS) strategy, where each position on the springboard array &#39;jump&#39; is treated as a node in a graph, and the possible jumps from each node define the edges. Starting from the first spring (index 0), the algorithm explores all possible jumps (both forward to &#39;i + jump[i]&#39; and backward to any index less than &#39;i&#39;). A queue is used to keep track of the next indices to visit. The &#39;visited_status&#39; set ensures each index is only added once to the queue to prevent infinite loops. The BFS approach guarantees that the first time the algorithm reaches beyond the last index (N), the minimum number of moves has been found.</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def minJump(self, jump: List[int]) -&gt; int:
        left_max_vis_idx = 0 # Tracks the furthest left index visited
        visited_status = set() # Keeps track of which indices have been visited
        queue = [0] # BFS queue starting from the first index
        n = len(jump) # Length of the jump array
        ans = 0 # Counter for the minimum number of jumps
        if n == 1:
            return 0 # If there&#39;s only one element, no jumps are needed
        while queue:
            tmp = queue
            queue = []
            ans += 1
            for item in tmp:
                next_item = item + jump[item] # Calculate next index using jump
                if next_item &gt;= n:
                    return ans # Return answer if next index is out of bounds
                if next_item not in visited_status and next_item &gt; left_max_vis_idx:
                    queue.append(next_item) # Enqueue valid, unvisited index
                    visited_status.add(next_item)
                if item &gt; left_max_vis_idx:
                    for j in range(left_max_vis_idx + 1, item):
                        if j not in visited_status: # Enqueue all unvisited indices between last max visited index and current
                            queue.append(j)
                            visited_status.add(j)
                    left_max_vis_idx = item # Update the furthest left visited index
        return ans # Return the number of jumps needed if loop exits normally</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>