<!DOCTYPE html>
<html lang="zh">
<head>
    <title>检查边长度限制的路径是否存在 II</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">检查边长度限制的路径是否存在 II</strong>
                标签:
                
                    <a href="/problems?tag=union-find" class="badge bg-secondary tag-link">并查集</a>
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=minimum-spanning-tree" class="badge bg-secondary tag-link">最小生成树</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class DistanceLimitedPathsExist:

    def find(self, i, d):
        if self.fa[i] == i or self.dists[i] &gt;= d:
            return i 
        return self.find(self.fa[i], d)

    def union(self, u, v, d):
        fu, fv = self.find(u, inf), self.find(v, inf)
        if fu != fv:
            if self.levels[fu] &gt; self.levels[fv]:
                self.fa[fv] = fu 
                self.dists[fv] = d 
            else:
                self.fa[fu] = fv 
                self.dists[fu] = d 
                if self.levels[fu] == self.levels[fv]:
                    self.levels[fv] += 1
    


    def __init__(self, n: int, edgeList: List[List[int]]):
        self.dists = [inf] * n 
        self.levels = [0] * n 
        self.fa = list(range(n))

        for u, v, d in sorted(edgeList, key=lambda e:e[2]):
            self.union(u, v, d)


    def query(self, p: int, q: int, limit: int) -&gt; bool:
        return self.find(p, limit) == self.find(q, limit)



# Your DistanceLimitedPathsExist object will be instantiated and called as such:
# obj = DistanceLimitedPathsExist(n, edgeList)
# param_1 = obj.query(p,q,limit)</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 284 ms</p>
                    <p class="mb-0">内存: 26.3 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这道题目使用了Union-Find数据结构来解决边长度限制的路径查询问题。Union-Find通常用于处理动态连通性问题。在这个问题中，我们对边按照长度进行排序，并逐步将它们加入到一个并查集中。每个操作都会更新节点的连接关系和边界限制。这使得我们可以对于每个查询有效地判断两个节点是否可以通过一条边长限制在指定值以下的路径相连。

具体来说，初始化时，对所有边按照长度升序排序，并逐一合并节点。节点合并时，会更新根节点之间的最大边界。查询时，我们检查两个节点是否可以通过小于限制的边连接起来。</p>
                        <p>时间复杂度: O(E log E + Eα(n) + Qα(n))</p>
                        <p>空间复杂度: O(n + E)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class DistanceLimitedPathsExist:

    def find(self, i, d):
        # 寻找节点i的根节点，并应用路径压缩，同时根据距离d更新根节点
        if self.fa[i] == i or self.dists[i] &gt;= d:
            return i 
        return self.find(self.fa[i], d)

    def union(self, u, v, d):
        # 合并节点u和v，设置它们的根节点，并根据它们的等级更新树的高度
        fu, fv = self.find(u, inf), self.find(v, inf)
        if fu != fv:
            if self.levels[fu] &gt; self.levels[fv]:
                self.fa[fv] = fu 
                self.dists[fv] = d 
            else:
                self.fa[fu] = fv 
                self.dists[fu] = d 
                if self.levels[fu] == self.levels[fv]:
                    self.levels[fv] += 1

    def __init__(self, n: int, edgeList: List[List[int]]):
        # 初始化并查集和边界数组
        self.dists = [inf] * n 
        self.levels = [0] * n 
        self.fa = list(range(n))

        # 对边按距离排序并逐个合并
        for u, v, d in sorted(edgeList, key=lambda e:e[2]):
            self.union(u, v, d)


    def query(self, p: int, q: int, limit: int) -&gt; bool:
        # 查询两个节点是否可以通过距离小于limit的路径连接
        return self.find(p, limit) == self.find(q, limit)</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>