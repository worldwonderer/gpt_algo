<!DOCTYPE html>
<html lang="zh">
<head>
    <title>统计整数数目</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">统计整数数目</strong>
                标签:
                
                    <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                    <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -&gt; int:
        n=len(num2)
        num1=str(int(num1)-1)
        num1=&#39;0&#39;*(n-len(num1))+num1
        num1,num2=tuple(map(int,num1)),tuple(map(int,num2))
        MOD=1_000_000_007
        @cache
        def ndn(n,dsum):
            if dsum&lt;0:
                return 0
            if n==0:
                return 1
            res=0
            for cd in range(10):
                res=(res+ndn(n-1,dsum-cd))%MOD
            return res
        def ddn(num,max_sum):
            if max_sum&lt;0:
                return 0
            if len(num)==0:
                return 1
            res=0
            for cd in range(num[0]):
                res=(res+ndn(len(num)-1,max_sum-cd))%MOD
            return (res+ddn(num[1:],max_sum-num[0]))%MOD
        return ((ddn(num2,max_sum)-ddn(num2,min_sum-1))-(ddn(num1,max_sum)-ddn(num1,min_sum-1)))%MOD



@cache
def free_digits(N, limit):
    if limit &lt; 0:
        return 0
    if N == 0:
        return 1
    return sum(free_digits(N - 1, limit - i) for i in range(10)) % 1000000007


class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -&gt; int:

        def total(num, max_sum):
            if max_sum &lt; 0:
                return 0
            if not num:
                return 1
            ans = 0
            for i in range(ord(num[0]) - ord(&#39;0&#39;)):
                ans += free_digits(len(num) - 1, max_sum - i)
            ans += total(num[1:], max_sum - (ord(num[0]) - ord(&#39;0&#39;)))
            #print(&#34;total&#34;, num, max_sum, ans)
            return ans % 1000000007
        num1d = str(int(num1) - 1)
        return ((total(num2, max_sum) - total(num2, min_sum - 1)) - (total(num1d, max_sum) - total(num1d, min_sum - 1))) % 1000000007</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 44 ms</p>
                    <p class="mb-0">内存: 17.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The solution uses a digit dynamic programming approach to efficiently count numbers within a specific range whose digit sum falls between given bounds. It considers two main functions: 1) &#39;ndn(n, dsum)&#39;, which calculates how many n-digit numbers have a digit sum exactly equal to &#39;dsum&#39;. 2) &#39;ddn(num, max_sum)&#39;, which calculates the count of numbers up to &#39;num&#39; that have a digit sum of at most &#39;max_sum&#39;. The main idea is to count the numbers satisfying the conditions up to &#39;num2&#39; and subtract the count of numbers up to &#39;num1&#39; - 1 (thus counting numbers between &#39;num1&#39; and &#39;num2&#39;), and adjust this for the specified digit sum range.</p>
                        <p>时间复杂度: O(D^2 * 10 * max_sum) where D is the number of digits in &#39;num2&#39;. This complexity stems from the iteration over all possible first digits and recursive processing for each subsequent digit.</p>
                        <p>空间复杂度: O(D * max_sum), which accounts for the maximum depth of recursion multiplied by the range of digit sums cached.</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def count(self, num1: str, num2: str, min_sum: int, max_sum: int) -&gt; int:
        MOD = 1_000_000_007
        num1 = str(int(num1) - 1) # Convert num1 to one less to include it in range during subtraction
        n = len(num2)
        num1 = &#39;0&#39; * (n - len(num1)) + num1 # Pad num1 to match the length of num2
        num1, num2 = tuple(map(int, num1)), tuple(map(int, num2)) # Convert strings to tuple of digits
        @cache
        def ndn(n, dsum): # Count of n-digit numbers with digit sum exactly &#39;dsum&#39;
            if dsum &lt; 0: return 0
            if n == 0: return 1 # Base case: one way (the number 0)
            res = 0
            for cd in range(10): # Loop through each digit from 0 to 9
                res = (res + ndn(n-1, dsum-cd)) % MOD
            return res
        def ddn(num, max_sum): # Dynamic digit sum calculation up to &#39;num&#39;
            if max_sum &lt; 0: return 0
            if not num: return 1 # Base case: one way if no digits left
            res = 0
            for cd in range(num[0]): # Try all digits less than the first digit of num
                res = (res + ndn(len(num)-1, max_sum-cd)) % MOD
            return (res + ddn(num[1:], max_sum-num[0])) % MOD # Include the case where first digit is num[0]
        return ((ddn(num2, max_sum) - ddn(num2, min_sum-1)) - (ddn(num1, max_sum) - ddn(num1, min_sum-1))) % MOD</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>