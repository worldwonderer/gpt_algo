<!DOCTYPE html>
<html lang="zh">
<head>
    <title>重新安排行程</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">重新安排行程</strong>
                标签:
                
                    <a href="/problems?tag=depth-first-search" class="badge bg-secondary tag-link">深度优先搜索</a>
                
                    <a href="/problems?tag=graph" class="badge bg-secondary tag-link">图</a>
                
                    <a href="/problems?tag=eulerian-circuit" class="badge bg-secondary tag-link">欧拉回路</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        import collections 
        self.ans=None
        maps=collections.defaultdict(list)
        for a,b in tickets:
            if a not in maps:
                maps[a]=[b]
            else:
                maps[a].append(b)
        for k in maps:
            heapq.heapify(maps[k])
        
        def dfs(cur):
            while maps[cur]:
                tmp=heapq.heappop(maps[cur])
                dfs(tmp)
            stack.append(cur)
        stack=[]
        dfs(&#34;JFK&#34;)
        return stack[::-1]
        


</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 21 ms</p>
                    <p class="mb-0">内存: 16.5 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The solution uses a depth-first search (DFS) combined with a min-heap for lexical order and a stack to build the itinerary. Initially, it constructs a graph with directed edges from each ticket&#39;s departure to its destination, using a defaultdict of lists. Each list is then converted into a min-heap to ensure that the next destination selected is the lexicographically smallest available. Starting from &#39;JFK&#39;, the DFS explores as far as possible along each branch, pushing the airports to the stack once all possible paths from that airport are exhausted. After the DFS completes, the stack holds the itinerary in reverse order, which is then reversed to produce the final itinerary order. This approach inherently handles the backtracking by exploring all possible routes using each ticket exactly once.</p>
                        <p>时间复杂度: O(E log m)</p>
                        <p>空间复杂度: O(V + E)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def findItinerary(self, tickets: List[List[str]]) -&gt; List[str]:
        import collections
        import heapq  # Used for maintaining a min-heap
        self.ans = None  # Not used, can be removed
        maps = collections.defaultdict(list)  # Graph representation
        for a, b in tickets:
            maps[a].append(b)  # Fill adjacency list
        for k in maps:
            heapq.heapify(maps[k])  # Heapify each destination list
        
        def dfs(cur):
            while maps[cur]:
                tmp = heapq.heappop(maps[cur])  # Always choose lexicographically smallest airport
                dfs(tmp)  # Recursively travel to the next airport
            stack.append(cur)  # Add airport to stack after visiting all possible next airports
        
        stack = []
        dfs(&#39;JFK&#39;)  # Start DFS from &#39;JFK&#39;
        return stack[::-1]  # Return reversed stack as the final itinerary</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>