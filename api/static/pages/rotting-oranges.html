<!DOCTYPE html>
<html lang="zh">
<head>
    <title>腐烂的橘子</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">腐烂的橘子</strong>
                标签:
                
                    <a href="/problems?tag=breadth-first-search" class="badge bg-secondary tag-link">广度优先搜索</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=matrix" class="badge bg-secondary tag-link">矩阵</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def orangesRotting(self, grid: List[List[int]]) -&gt; int:
        M = len(grid)
        N = len(grid[0])
        queue = []
        
        count = 0
        for r in range(M):
            for c in range(N):
                if grid[r][c] == 1:
                    count += 1
                elif grid[r][c] == 2:
                    queue.append((r, c))
        def valid(x, y):
            return 0&lt;=x&lt;M and 0&lt;=y&lt;N
                    
        round = 0 # round 表示腐烂的轮数，或者分钟数
        while count &gt; 0 and len(queue) &gt; 0:
            round += 1 
            n = len(queue)
            for i in range(n):
                r, c = queue.pop(0)
                for [x, y] in [[0,1], [0,-1], [1,0], [-1,0]]:
                    new_x, new_y = r+x, c+y
                    if valid(new_x, new_y) and grid[new_x][new_y] == 1:
                        grid[new_x][new_y] = 2
                        count -= 1
                        queue.append((new_x, new_y))
        
        if count &gt; 0:
            return -1
        else:
            return round
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 18 ms</p>
                    <p class="mb-0">内存: 16.1 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>This solution uses the Breadth-First Search (BFS) algorithm to simulate the rotting process of oranges. It starts by identifying all initially rotten oranges and counting fresh oranges. It enqueues all rotten oranges&#39; positions. Using BFS, it iteratively infects fresh oranges adjacent to rotten ones each minute, marking them rotten and decreasing the fresh count. This continues until no fresh oranges are left or there are no more adjacent fresh oranges to infect, at which point the process stops. If any fresh oranges remain unreachable, it returns -1, otherwise, it returns the number of minutes passed.</p>
                        <p>时间复杂度: O(M * N)</p>
                        <p>空间复杂度: O(M * N)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python"># Class definition for the rotting oranges problem
class Solution:
    def orangesRotting(self, grid: List[List[int]]) -&gt; int:
        M = len(grid) # Number of rows in the grid
        N = len(grid[0]) # Number of columns in the grid
        queue = [] # Queue to store positions of rotten oranges
        
        count = 0 # Count of fresh oranges
        for r in range(M):
            for c in range(N):
                if grid[r][c] == 1: # Count fresh oranges
                    count += 1
                elif grid[r][c] == 2: # Initialize queue with all rotten oranges
                    queue.append((r, c))
        def valid(x, y):
            return 0&lt;=x&lt;M and 0&lt;=y&lt;N # Helper function to check boundaries
                    
        round = 0 # round represents the number of minutes passed
        while count &gt; 0 and len(queue) &gt; 0: # While there are fresh oranges and rotten ones to process
            round += 1
            n = len(queue) # Number of oranges to process this round
            for i in range(n):
                r, c = queue.pop(0) # Pop the first rotten orange from the queue
                for [x, y] in [[0,1], [0,-1], [1,0], [-1,0]]: # Check all 4 adjacent cells
                    new_x, new_y = r+x, c+y
                    if valid(new_x, new_y) and grid[new_x][new_y] == 1: # If adjacent cell is fresh
                        grid[new_x][new_y] = 2 # It rots
                        count -= 1 # Decrease count of fresh oranges
                        queue.append((new_x, new_y)) # Enqueue the newly rotten orange
        
        if count &gt; 0: # If there are still fresh oranges left
            return -1 # It&#39;s impossible to rot all oranges
        else:
            return round # Return the total minutes required</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>