<!DOCTYPE html>
<html lang="zh">
<head>
    <title>你可以安排的最多任务数目</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>你可以安排的最多任务数目</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                    
                        <a href="/problems?tag=queue" class="badge bg-secondary tag-link">队列</a>
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=binary-search" class="badge bg-secondary tag-link">二分查找</a>
                    
                        <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                    
                        <a href="/problems?tag=monotonic-queue" class="badge bg-secondary tag-link">单调队列</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Hard</span></p>
                
                    <div class="problem-description">
                        <p>给你&nbsp;<code>n</code>&nbsp;个任务和&nbsp;<code>m</code>&nbsp;个工人。每个任务需要一定的力量值才能完成，需要的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>tasks</code>&nbsp;中，第 <code>i</code>&nbsp;个任务需要&nbsp;<code>tasks[i]</code>&nbsp;的力量才能完成。每个工人的力量值保存在下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>workers</code>&nbsp;中，第&nbsp;<code>j</code>&nbsp;个工人的力量值为&nbsp;<code>workers[j]</code>&nbsp;。每个工人只能完成 <strong>一个</strong>&nbsp;任务，且力量值需要 <strong>大于等于</strong>&nbsp;该任务的力量要求值（即&nbsp;<code>workers[j] &gt;= tasks[i]</code>&nbsp;）。</p>

<p>除此以外，你还有&nbsp;<code>pills</code>&nbsp;个神奇药丸，可以给 <strong>一个工人的力量值</strong>&nbsp;增加&nbsp;<code>strength</code>&nbsp;。你可以决定给哪些工人使用药丸，但每个工人&nbsp;<strong>最多</strong>&nbsp;只能使用&nbsp;<strong>一片</strong>&nbsp;药丸。</p>

<p>给你下标从 <strong>0</strong>&nbsp;开始的整数数组<code>tasks</code> 和&nbsp;<code>workers</code>&nbsp;以及两个整数&nbsp;<code>pills</code> 和&nbsp;<code>strength</code>&nbsp;，请你返回 <strong>最多</strong>&nbsp;有多少个任务可以被完成。</p>



<p><strong>示例 1：</strong></p>

<pre><b>输入：</b>tasks = [<em><strong>3</strong></em>,<em><strong>2</strong></em>,<em><strong>1</strong></em>], workers = [<em><strong>0</strong></em>,<em><strong>3</strong></em>,<em><strong>3</strong></em>], pills = 1, strength = 1
<b>输出：</b>3
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 2（0 + 1 &gt;= 1）
- 1 号工人完成任务 1（3 &gt;= 2）
- 2 号工人完成任务 0（3 &gt;= 3）
</pre>

<p><strong>示例 2：</strong></p>

<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,4], workers = [<em><strong>0</strong></em>,0,0], pills = 1, strength = 5
<b>输出：</b>1
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号工人药丸。
- 0 号工人完成任务 0（0 + 5 &gt;= 5）
</pre>

<p><strong>示例 3：</strong></p>

<pre><b>输入：</b>tasks = [<em><strong>10</strong></em>,<em><strong>15</strong></em>,30], workers = [<em><strong>0</strong></em>,<em><strong>10</strong></em>,10,10,10], pills = 3, strength = 10
<b>输出：</b>2
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 0 号和 1 号工人药丸。
- 0 号工人完成任务 0（0 + 10 &gt;= 10）
- 1 号工人完成任务 1（10 + 10 &gt;= 15）
</pre>

<p><strong>示例 4：</strong></p>

<pre><b>输入：</b>tasks = [<em><strong>5</strong></em>,9,<em><strong>8</strong></em>,<em><strong>5</strong></em>,9], workers = [1,<em><strong>6</strong></em>,<em><strong>4</strong></em>,2,<em><strong>6</strong></em>], pills = 1, strength = 5
<b>输出：</b>3
<strong>解释：</strong>
我们可以按照如下方案安排药丸：
- 给 2 号工人药丸。
- 1 号工人完成任务 0（6 &gt;= 5）
- 2 号工人完成任务 2（4 + 5 &gt;= 8）
- 4 号工人完成任务 3（6 &gt;= 5）
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>n == tasks.length</code></li>
	<li><code>m == workers.length</code></li>
	<li><code>1 &lt;= n, m &lt;= 5 * 10<sup>4</sup></code></li>
	<li><code>0 &lt;= pills &lt;= m</code></li>
	<li><code>0 &lt;= tasks[i], workers[j], strength &lt;= 10<sup>9</sup></code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 430 ms</p>
                    <p>内存: 24.4 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -&gt; int:
        tl, wl = len(tasks), len(workers)
        tasks.sort()
        workers.sort()
        

        # def check(wsIndex: int) -&gt; bool:
        #     heap = [(w,1) for w in workers[wsIndex:]]
        #     unstrQueue = deque()
        #     total = pills
        #     tlIndex = 0
        #     while heap:
        #         worker, strenged = heappop(heap)
        #         task = tasks[tlIndex]
        #         if task &gt; worker:
                    
        #             if total == 0: return False
        #             total -= 1

        #             if strenged == 1:
        #                 heappush(heap, (worker + strength, 0))
        #                 continue
        #             else:
        #                 while unstrQueue and unstrQueue[0] + strength &lt; task:
        #                     unstrQueue.popleft()
        #                 if unstrQueue: unstrQueue.popleft()
        #                 else: return False

        #         if strenged == 1:
        #             unstrQueue.append(worker)

        #         tlIndex += 1

        #     return True

        def check(wsIndex: int) -&gt; bool:
            stredQueue = deque()
            unstrQueue = deque()
            total = pills
            tlIndex = 0
            while stredQueue or wsIndex &lt; wl:
                worker = -1
                strenged = False
                if wsIndex == wl or (stredQueue and stredQueue[0] &lt;= workers[wsIndex]):
                    strenged = True
                    worker = stredQueue.popleft()
                else:
                    strenged = False
                    worker = workers[wsIndex]
                    wsIndex += 1


                task = tasks[tlIndex]
                if task &gt; worker:
                    
                    if total == 0: return False
                    total -= 1

                    if strenged:
                        while unstrQueue and unstrQueue[0] + strength &lt; task:
                            unstrQueue.popleft()
                        if unstrQueue: unstrQueue.popleft()
                        else: return False
                    else:
                        stredQueue.append(worker + strength)
                        continue
                        

                if not strenged:
                    unstrQueue.append(worker)

                tlIndex += 1

            return True


        left, right = max(0, wl - tl), wl
        while left &lt; right:
            mid = (left + right) &gt;&gt; 1
            if check(mid): right = mid
            else: left = mid + 1

        return wl - right
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>此题解使用二分搜索和贪心算法的组合来解决问题。首先，对任务和工人的力量数组进行排序。利用二分搜索尝试找到最大数量的任务可以被完成。对于二分搜索的每个中点，使用check函数来验证是否可以完成至少这么多任务。check函数通过维护两个队列（一个用于已使用药丸增强的工人，一个用于未使用药丸的工人）来尝试分配工人以完成任务，如果任务的力量要求高于当前工人（包括加强后的工人）的力量，就尝试使用药丸。如果不能使用更多的药丸且没有足够力量的工人，则返回失败。通过这种方式，check函数可以判断出在当前二分搜索的中间值下，能否完成任务。最终，二分搜索确定可以完成任务的最大数量。</p>
                                <p>时间复杂度: O(m log m + n log n)</p>
                                <p>空间复杂度: O(m)</p>
                                <pre class="bg-light p-2">class Solution:
    def maxTaskAssign(self, tasks: List[int], workers: List[int], pills: int, strength: int) -&gt; int:
        tl, wl = len(tasks), len(workers)
        tasks.sort()
        workers.sort()
        def check(wsIndex: int) -&gt; bool:
            stredQueue = deque() # 增强工人队列
            unstrQueue = deque() # 未增强工人队列
            total = pills # 剩余药丸数
            tlIndex = 0 # 当前尝试分配的任务索引
            while stredQueue or wsIndex &lt; wl:
                worker = -1
                strenged = False
                if wsIndex == wl or (stredQueue and stredQueue[0] &lt;= workers[wsIndex]):
                    strenged = True
                    worker = stredQueue.popleft()
                else:
                    strenged = False
                    worker = workers[wsIndex]
                    wsIndex += 1
                task = tasks[tlIndex]
                if task &gt; worker:
                    if total == 0: return False # 无药丸且无法完成任务
                    total -= 1
                    if strenged:
                        while unstrQueue and unstrQueue[0] + strength &lt; task:
                            unstrQueue.popleft()
                        if unstrQueue: unstrQueue.popleft()
                        else: return False # 即使使用药丸也无法完成任务
                    else:
                        stredQueue.append(worker + strength)
                        continue
                if not strenged:
                    unstrQueue.append(worker) # 添加到未增强工人队列
                tlIndex += 1
            return True # 成功完成所有任务
        left, right = max(0, wl - tl), wl # 二分搜索范围初始化
        while left &lt; right:
            mid = (left + right) &gt;&gt; 1
            if check(mid): right = mid
            else: left = mid + 1
        return wl - right # 返回最大可能完成的任务数</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            为什么需要将任务和工人的力量数组进行排序？这对算法的效率和结果有什么影响？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>任务和工人的力量数组进行排序是为了利用贪心算法的策略，即尽可能地使用最弱的工人来完成最轻的任务，从而最大化完成任务的数量。这种排序确保在分配任务时，可以直接比较任务和工人的力量，简化逻辑并提高效率。排序还有助于在使用二分搜索时，快速确定哪些任务可以被哪些工人完成，以及如何有效地使用药丸。总的来说，排序是实现高效匹配和正确实施贪心策略的关键步骤。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在二分搜索中，中间值mid代表什么含义？如何根据mid值在check函数中进行任务分配？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在二分搜索中，中间值mid代表当前尝试分配任务的工人的起始偏移量。这意味着从数组中的mid位置开始，向后的所有工人都可能被用来完成任务。在check函数中，使用这个起始偏移量来确定哪些工人可用，从而根据任务的难度和工人的能力（包括是否使用药丸增强）来决定任务是否可以被完成。如果从mid开始的所有工人配合药丸的使用可以完成任务列表中的足够多任务，则认为这个mid是有效的，二分搜索会尝试更小的mid值以寻找可能的最大任务完成数。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            check函数中如何决定使用或不使用药丸？具体的逻辑是怎样的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在check函数中，决定是否使用药丸的逻辑基于当前工人的力量与所分配任务的力量需求之间的比较。如果当前工人的力量（即使是已经使用药丸增强过的工人）不足以完成当前任务，且还有剩余的药丸，则会考虑使用一粒药丸。药丸的使用会将工人的力量临时增加一定数值（strength），然后重新评估是否能完成任务。如果使用了药丸后仍不能完成任务或者没有剩余药丸，算法会判断为这个mid值不可行。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            当一个工人使用了药丸后，他的力量值增加了strength，但如果这仍不足以完成当前的任务，算法是如何处理的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>如果工人使用药丸后力量增加了strength，但增加后的力量仍不足以完成当前任务，则该任务实际上是无法被当前的工人完成的。在这种情况下，算法会继续寻找下一个可用的工人或继续使用其他药丸增强的工人尝试完成该任务。如果没有更多的工人或药丸可用，这将导致当前的mid值失败，表示从mid开始的工人数无法完成足够多的任务，二分搜索会调整范围尝试一个更大的mid值。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/maximum-number-of-tasks-you-can-assign')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/maximum-number-of-tasks-you-can-assign/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>