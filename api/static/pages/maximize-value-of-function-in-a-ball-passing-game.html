<!DOCTYPE html>
<html lang="zh">
<head>
    <title>在传球游戏中最大化函数值</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>在传球游戏中最大化函数值</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=dynamic-programming" class="badge bg-secondary tag-link">动态规划</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Hard</span></p>
                
                    <div class="problem-description">
                        <p>给你一个长度为 <code>n</code>&nbsp;下标从 <strong>0</strong>&nbsp;开始的整数数组&nbsp;<code>receiver</code>&nbsp;和一个整数&nbsp;<code>k</code>&nbsp;。</p>

<p>总共有&nbsp;<code>n</code>&nbsp;名玩家，玩家 <strong>编号</strong>&nbsp;互不相同，且为&nbsp;<code>[0, n - 1]</code>&nbsp;中的整数。这些玩家玩一个传球游戏，<code>receiver[i]</code>&nbsp;表示编号为 <code>i</code>&nbsp;的玩家会传球给编号为 <code>receiver[i]</code>&nbsp;的玩家。玩家可以传球给自己，也就是说&nbsp;<code>receiver[i]</code>&nbsp;可能等于&nbsp;<code>i</code>&nbsp;。</p>

<p>你需要从 <code>n</code>&nbsp;名玩家中选择一名玩家作为游戏开始时唯一手中有球的玩家，球会被传 <strong>恰好</strong>&nbsp;<code>k</code>&nbsp;次。</p>

<p>如果选择编号为 <code>x</code>&nbsp;的玩家作为开始玩家，定义函数&nbsp;<code>f(x)</code>&nbsp;表示从编号为&nbsp;<code>x</code>&nbsp;的玩家开始，<code>k</code>&nbsp;次传球内所有接触过球玩家的编号之&nbsp;<strong>和</strong>&nbsp;，如果有玩家多次触球，则 <strong>累加多次</strong>&nbsp;。换句话说，&nbsp;<code>f(x) = x + receiver[x] + receiver[receiver[x]] + ... + receiver<sup>(k)</sup>[x]</code>&nbsp;。</p>

<p>你的任务时选择开始玩家 <code>x</code>&nbsp;，目的是<strong>&nbsp;最大化</strong>&nbsp;<code>f(x)</code>&nbsp;。</p>

<p>请你返回函数的 <strong>最大值</strong>&nbsp;。</p>

<p><strong>注意：</strong><code>receiver</code>&nbsp;可能含有重复元素。</p>



<p><strong class="example">示例 1：</strong></p>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<th style="padding: 5px; border: 1px solid black;">传递次数</th>
			<th style="padding: 5px; border: 1px solid black;">传球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">接球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">x + 所有接球者编号</th>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">0</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">0</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">5</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">4</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">6</td>
		</tr>
	</tbody>
</table>



<pre>
<b>输入：</b>receiver = [2,0,1], k = 4
<b>输出：</b>6
<b>解释：</b>上表展示了从编号为 x = 2 开始的游戏过程。
从表中可知，f(2) 等于 6 。
6 是能得到最大的函数值。
所以输出为 6 。
</pre>

<p><strong class="example">示例 2：</strong></p>

<table border="1" cellspacing="3" style="border-collapse: separate; text-align: center;">
	<tbody>
		<tr>
			<th style="padding: 5px; border: 1px solid black;">传递次数</th>
			<th style="padding: 5px; border: 1px solid black;">传球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">接球者编号</th>
			<th style="padding: 5px; border: 1px solid black;">x + 所有接球者编号</th>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">&nbsp;</td>
			<td style="padding: 5px; border: 1px solid black;">4</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">4</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">7</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">9</td>
		</tr>
		<tr>
			<td style="padding: 5px; border: 1px solid black;">3</td>
			<td style="padding: 5px; border: 1px solid black;">2</td>
			<td style="padding: 5px; border: 1px solid black;">1</td>
			<td style="padding: 5px; border: 1px solid black;">10</td>
		</tr>
	</tbody>
</table>



<pre>
<b>输入：</b>receiver = [1,1,1,2,3], k = 3
<b>输出：</b>10
<b>解释：</b>上表展示了从编号为 x = 4 开始的游戏过程。
从表中可知，f(4) 等于 10 。
10 是能得到最大的函数值。
所以输出为 10 。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= receiver.length == n &lt;= 10<sup>5</sup></code></li>
	<li><code>0 &lt;= receiver[i] &lt;= n - 1</code></li>
	<li><code>1 &lt;= k &lt;= 10<sup>10</sup></code></li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 333 ms</p>
                    <p>内存: 58.4 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -&gt; int:
        n = len(receiver)
        prevs = [[] for _ in range(n)]
        res = [-1]*n
        offMap = {}
        for i, ri in enumerate(receiver):
            prevs[ri].append(i)
        it1 = (i for i, (lst, v) in enumerate(zip(prevs, res)) if not lst and v &lt; 0)
        it2 = (i for i, v in enumerate(res) if v &lt; 0)
        class FillNode:
            def __init__(self, i, accu=0, _next=None):
                self.i = i
                self.accu = accu
                self.next = _next
                self.pursue, self.pursueAccu = -1, 0
                self.q = deque()
        def iterNode(head):
            node = head.next
            while node:
                yield node
                node = node.next
        def fill(prev, circleLen, circleSum, off, accus):
            # print(&#39;fill&#39;, prev, circleLen, off, accus)
            head = FillNode(-1)
            head.next = FillNode(prev, prev)
            head.next.prev = head
            circles, r = divmod(k+1, circleLen)
            circles *= circleSum
            for rnd in count(1):
                if not head.next: break
                if rnd &lt; k+1:
                    r -= 1
                    if r &lt; 0:
                        circles -= circleSum
                        r += circleLen
                    delta = circles + accus[off+r] - accus[off]
                    for node in iterNode(head):
                        res[node.i] = node.accu + delta
                        #print(&#39;delta&#39;, circles, r, off, delta, node.i, node.accu)
                elif rnd == k + 1:
                    for node in iterNode(head):
                        node.pursue = node.pursueAccu = prev
                        res[node.i] = node.accu
                        #print(&#39;purs&#39;, rnd, node.i, node.pursue)
                else:
                    for node in iterNode(head):
                        res[node.i] = node.accu - node.pursueAccu
                        #print(node.q, prevs[node.pursue], node.i)
                        node.pursue = node.q.popleft() if len(prevs[node.pursue]) &gt; 1 else prevs[node.pursue][0]
                        node.pursueAccu += node.pursue
                for node in iterNode(head):
                    ps = prevs[node.i]
                    if len(ps) == 1:
                        node.i = ps[0]
                        node.accu += node.i
                    else:
                        node.prev.next = node.next
                        if node.next:
                            node.next.prev = node.prev
                        for p in ps:
                            # print(&#39;spilt&#39;, rnd, node.i, p)
                            new = FillNode(p, node.accu + p, head.next)
                            if head.next:
                                head.next.prev = new
                            head.next = new
                            new.prev = head
                            new.q = deque(node.q)
                            new.q.append(p)
                            new.pursue = node.pursue
                            new.pursueAccu = node.pursueAccu
                
        for i in chain(it1, it2):
            # print(&#39;i&#39;, i)
            offMap.clear()
            accus = [0]
            while offMap.get(i) is None:
                offMap[i] = len(offMap)
                accus.append(accus[-1]+i)
                last, i = i, receiver[i]
            circleLen = len(offMap) - offMap[i]
            circles, r = divmod(k + 1, circleLen)
            startOff = offMap[i]
            circleSum = accus[-1] - accus[startOff]
            circleTotal = circleSum * circles
            #print(&#39;circle&#39;, circleSum, circles, circleTotal)
            for off in range(startOff, len(offMap)):
                accus.append(accus[-1] + i)
                res[i] = circleTotal + accus[off+r] - accus[off]
                # print(&#39;resi&#39;, i, res[i])
                for prev in prevs[i]:
                    if prev != last:
                        fill(prev, circleLen, circleSum, off, accus)
                last, i = i, receiver[i]
        #print(res) 
        return max(res)
        # x y 
        # off = 0... (x+y-1)
        # off + k-1</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题解采用复杂的方法处理球传递游戏问题。首先，创建一个数据结构记录每个玩家作为接球者的所有前驱，用于处理球的传递链。通过定义 FillNode 类来追踪传球过程中的累积分数以及其他元数据，然后实现一个 iterNode 函数来遍历传球链。主要的处理逻辑在 fill 函数中，该函数利用循环找到传球序列的开始和结束，并计算序列长度以及累积和，从而能够模拟整个传球过程并更新每个玩家的最终得分。最后，通过遍历所有可能的传球起始玩家来找到可以获得最大分数的起始玩家。</p>
                                <p>时间复杂度: O(n * k)</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2">class Solution:
    def getMaxFunctionValue(self, receiver: List[int], k: int) -&gt; int:
        n = len(receiver)
        # 初始化每个玩家的前驱列表和初始分数数组
        prevs = [[] for _ in range(n)]
        res = [-1]*n
        # 字典用于存储传球链的偏移量映射
        offMap = {}
        for i, ri in enumerate(receiver):
            prevs[ri].append(i)
        it1 = (i for i, (lst, v) in enumerate(zip(prevs, res)) if not lst and v &lt; 0)
        it2 = (i for i, v in enumerate(res) if v &lt; 0)
        class FillNode:
            def __init__(self, i, accu=0, _next=None):
                self.i = i
                self.accu = accu
                self.next = _next
                self.pursue, self.pursueAccu = -1, 0
                self.q = deque()
        def iterNode(head):
            node = head.next
            while node:
                yield node
                node = node.next
        def fill(prev, circleLen, circleSum, off, accus):
            head = FillNode(-1)
            head.next = FillNode(prev, prev)
            head.next.prev = head
            circles, r = divmod(k+1, circleLen)
            circles *= circleSum
            for rnd in count(1):
                if not head.next: break
                if rnd &lt; k+1:
                    r -= 1
                    if r &lt; 0:
                        circles -= circleSum
                        r += circleLen
                    delta = circles + accus[off+r] - accus[off]
                    for node in iterNode(head):
                        res[node.i] = node.accu + delta
                elif rnd == k + 1:
                    for node in iterNode(head):
                        node.pursue = node.pursueAccu = prev
                        res[node.i] = node.accu
                else:
                    for node in iterNode(head):
                        res[node.i] = node.accu - node.pursueAccu
                        node.pursue = node.q.popleft() if len(prevs[node.pursue]) &gt; 1 else prevs[node.pursue][0]
                        node.pursueAccu += node.pursue
                for node in iterNode(head):
                    ps = prevs[node.i]
                    if len(ps) == 1:
                        node.i = ps[0]
                        node.accu += node.i
                    else:
                        node.prev.next = node.next
                        if node.next:
                            node.next.prev = node.prev
                        for p in ps:
                            new = FillNode(p, node.accu + p, head.next)
                            if head.next:
                                head.next.prev = new
                            head.next = new
                            new.prev = head
                            new.q = deque(node.q)
                            new.q.append(p)
                            new.pursue = node.pursue
                            new.pursueAccu = node.pursueAccu
        
        for i in chain(it1, it2):
            offMap.clear()
            accus = [0]
            while offMap.get(i) is None:
                offMap[i] = len(offMap)
                accus.append(accus[-1]+i)
                last, i = i, receiver[i]
            circleLen = len(offMap) - offMap[i]
            circles, r = divmod(k + 1, circleLen)
            startOff = offMap[i]
            circleSum = accus[-1] - accus[startOff]
            circleTotal = circleSum * circles
            for off in range(startOff, len(offMap)):
                accus.append(accus[-1] + i)
                res[i] = circleTotal + accus[off+r] - accus[off]
                for prev in prevs[i]:
                    if prev != last:
                        fill(prev, circleLen, circleSum, off, accus)
                last, i = i, receiver[i]
        return max(res)</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在算法中，为什么选择使用一个复杂的数据结构来记录每个玩家作为接球者的所有前驱而不是直接模拟传球过程？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>使用复杂的数据结构记录每个玩家作为接球者的所有前驱主要是为了高效地处理问题中的循环依赖和重复计算。这种方法可以快速确定传球链中的环形结构和环外部分，从而避免在模拟传球过程中重复遍历同一路径或节点，尤其是在长传球链和环形链中更为有效。此外，这种数据结构还有助于快速更新和查询每个玩家的累积得分，尤其是在有多个前驱的情况下，可以更灵活地处理分支和合并的情况。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            请问在 iterNode 函数中，yield node 的作用是什么，它如何影响传球链的遍历过程？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在 iterNode 函数中，`yield node` 的作用是创建一个生成器，它逐一返回传球链中的节点。这种方式允许函数的调用者在每次迭代时获得当前节点并对其执行操作，而不需要一次性获取全部节点。这样的延迟计算（按需计算）可以提高内存利用率，同时使得处理每个节点的逻辑更加灵活和可控。通过生成器，可以在遍历过程中更容易地插入或删除节点，或在遍历时动态调整遍历策略，这对于处理复杂的传球链尤为重要。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            在 fill 函数中，circleLen 和 circleSum 分别代表什么，它们是如何计算的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在 fill 函数中，`circleLen` 代表在传球链中检测到的环的长度，即环中包含的节点数。`circleSum` 则代表这个环中所有节点的索引值的累积和。环的检测是通过记录节点在遍历过程中的出现位置来完成的，一旦发现某个节点重新被访问，即确认存在环。此时，`circleLen` 计算为当前节点位置与该节点首次出现位置之间的差值。`circleSum` 是从环开始的位置到环结束的位置节点值的累积和。这两个参数对于计算在环中进行多圈后每个节点的累积得分非常关键，它们使得可以快速计算多次遍历环时的得分增加量。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader4">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse4" aria-expanded="false" aria-controls="exploreCollapse4">
                                            算法在处理传球链是环形的情况时，如何确保不会出现无限循环的问题，并且如何处理环上的节点计分？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse4" class="collapse" aria-labelledby="exploreHeader4" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>算法通过映射每个节点第一次被访问的位置来识别环，并使用环的长度和累积和来计算环上的节点得分。一旦检测到环，算法计算传球次数与环长度的商和余数，利用这些信息来确定遍历环的完整圈数和额外部分。通过这种方式，算法可以精确地计算在规定的传球次数内每个节点的得分，而无需实际模拟每一次传球，从而避免了无限循环的问题。对于环上的节点，算法计算多圈后的累积得分加上在最后一部分环内的得分，以此确保每个节点得分的正确性。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/maximize-value-of-function-in-a-ball-passing-game')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/maximize-value-of-function-in-a-ball-passing-game/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>