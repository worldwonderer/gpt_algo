<!DOCTYPE html>
<html lang="zh">
<head>
    <title>使二进制字符串变美丽的最少修改次数</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>使二进制字符串变美丽的最少修改次数</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>给你一个长度为偶数下标从 <strong>0</strong>&nbsp;开始的二进制字符串&nbsp;<code>s</code>&nbsp;。</p>

<p>如果可以将一个字符串分割成一个或者更多满足以下条件的子字符串，那么我们称这个字符串是 <strong>美丽的</strong>&nbsp;：</p>

<ul>
	<li>每个子字符串的长度都是 <strong>偶数</strong>&nbsp;。</li>
	<li>每个子字符串都 <strong>只</strong>&nbsp;包含 <code>1</code>&nbsp;或 <strong>只</strong>&nbsp;包含 <code>0</code>&nbsp;。</li>
</ul>

<p>你可以将 <code>s</code>&nbsp;中任一字符改成&nbsp;<code>0</code>&nbsp;或者&nbsp;<code>1</code>&nbsp;。</p>

<p>请你返回让字符串 <code>s</code>&nbsp;美丽的<strong>&nbsp;最少</strong>&nbsp;字符修改次数。</p>



<p><strong class="example">示例 1：</strong></p>

<pre>
<b>输入：</b>s = "1001"
<b>输出：</b>2
<b>解释：</b>我们将 s[1] 改为 1 ，且将 s[3] 改为 0 ，得到字符串 "1100" 。
字符串 "1100" 是美丽的，因为我们可以将它分割成 "11|00" 。
将字符串变美丽最少需要 2 次修改。
</pre>

<p><strong class="example">示例 2：</strong></p>

<pre>
<b>输入：</b>s = "10"
<b>输出：</b>1
<b>解释：</b>我们将 s[1] 改为 1 ，得到字符串 "11" 。
字符串 "11" 是美丽的，因为它已经是美丽的。
将字符串变美丽最少需要 1 次修改。
</pre>

<p><strong class="example">示例 3：</strong></p>

<pre>
<b>输入：</b>s = "0000"
<b>输出：</b>0
<b>解释：</b>不需要进行任何修改，字符串 "0000" 已经是美丽字符串。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>2 &lt;= s.length &lt;= 10<sup>5</sup></code></li>
	<li><code>s</code>&nbsp;的长度为偶数。</li>
	<li><code>s[i]</code>&nbsp;要么是&nbsp;<code>'0'</code>&nbsp;，要么是&nbsp;<code>'1'</code> 。</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 38 ms</p>
                    <p>内存: 16.2 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def minChanges(self, s: str) -&gt; int:
        n = len(s)
        ans = 0
        for i in range(1,n,2):
            if s[i] != s[i-1]:
                ans += 1
        return ans</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题解的核心思路是检查字符串中相邻的字符是否相同。由于要求每个美丽子字符串只包含相同的字符且长度是偶数，我们可以将字符串视为由多个两个字符组成的子串来检查。对于每一个从索引1开始的奇数索引，如果它与前一个字符（偶数索引）不同，那么至少需要更改其中一个字符来确保这两个字符相同，从而使得从这个偶数索引开始的两个字符长的子串成为美丽的。通过这种方式，我们可以计算出整个字符串中需要修改的最小字符数，从而使整个字符串变为美丽的。</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2">class Solution:
    def minChanges(self, s: str) -&gt; int:
        n = len(s)  # 获取字符串的长度
        ans = 0  # 初始化修改次数为0
        for i in range(1, n, 2):  # 从索引1开始每隔一个元素检查，即检查所有奇数索引
            if s[i] != s[i-1]:  # 如果当前字符与前一个字符不同
                ans += 1  # 需要修改次数加1
        return ans  # 返回总的修改次数</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            为什么选择从索引1开始，并且每隔一个元素进行检查，这种方法有什么特别的原因吗？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>选择从索引1开始，并每隔一个元素进行检查（即检查所有奇数索引），是因为我们的目标是确保每两个相邻的字符组成的子串都只包含相同的字符。在二进制字符串中，每两个字符可以形成一个长度为2的子串，对于从索引0开始的偶数索引和其后的奇数索引（如0和1，2和3）这种配对方式，需要检查这两个字符是否相同。通过这种方式，我们能够确保所有的字符对都满足条件，从而使整个字符串变得美丽。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            在这种解法中，如果遇到连续的奇数个相同字符如何处理？例如字符串 &#39;111&#39; 应该如何修改以满足题目要求？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在提出的解法中，我们是按每两个字符为一组进行检查和修改的。对于如 &#39;111&#39; 这样的字符串，我们按照索引检查（0和1，1和2），首先检查0和1时发现它们相同，不需要修改。然后检查1和2也发现它们相同，不需要修改。然而，根据题目要求，每个子字符串的长度必须是偶数，所以不能有长度为3的子字符串。在这种情况下，可以选择修改任何一个字符（比如中间的字符1改为0），使得字符串分割成两个长度为2的子字符串（如&#39;10&#39;和&#39;01&#39;），这样的修改次数最少。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            解法中只考虑每两个相邻字符是否相同，那么整个字符串的长度是否一定会是偶数，如果是奇数长度的字符串该如何处理？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题目已明确指出给定的二进制字符串长度为偶数，因此在这种情况下我们不需要考虑字符串长度为奇数的情况。如果在其他情况下遇到奇数长度的字符串，我们需要在设计算法时考虑如何处理最后一个无法配对的字符。可能的处理方法包括增加一个字符使其长度变为偶数，或者在某个位置上做出修改，使得所有子字符串的长度都为偶数。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/minimum-number-of-changes-to-make-binary-string-beautiful')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/minimum-number-of-changes-to-make-binary-string-beautiful/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>