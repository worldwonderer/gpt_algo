<!DOCTYPE html>
<html lang="zh">
<head>
    <title>保证文件名唯一</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>保证文件名唯一</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                    
                        <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Medium</span></p>
                
                    <div class="problem-description">
                        <p>给你一个长度为 <code>n</code> 的字符串数组 <code>names</code> 。你将会在文件系统中创建 <code>n</code> 个文件夹：在第 <code>i</code> 分钟，新建名为 <code>names[i]</code> 的文件夹。</p>

<p>由于两个文件 <strong>不能</strong> 共享相同的文件名，因此如果新建文件夹使用的文件名已经被占用，系统会以 <code>(k)</code> 的形式为新文件夹的文件名添加后缀，其中 <code>k</code> 是能保证文件名唯一的 <strong>最小正整数</strong> 。</p>

<p>返回长度为<em> <code>n</code></em> 的字符串数组，其中 <code>ans[i]</code> 是创建第 <code>i</code> 个文件夹时系统分配给该文件夹的实际名称。</p>



<p><strong>示例 1：</strong></p>

<pre><strong>输入：</strong>names = [&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]
<strong>输出：</strong>[&quot;pes&quot;,&quot;fifa&quot;,&quot;gta&quot;,&quot;pes(2019)&quot;]
<strong>解释：</strong>文件系统将会这样创建文件名：
&quot;pes&quot; --&gt; 之前未分配，仍为 &quot;pes&quot;
&quot;fifa&quot; --&gt; 之前未分配，仍为 &quot;fifa&quot;
&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;
&quot;pes(2019)&quot; --&gt; 之前未分配，仍为 &quot;pes(2019)&quot;
</pre>

<p><strong>示例 2：</strong></p>

<pre><strong>输入：</strong>names = [&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta&quot;,&quot;avalon&quot;]
<strong>输出：</strong>[&quot;gta&quot;,&quot;gta(1)&quot;,&quot;gta(2)&quot;,&quot;avalon&quot;]
<strong>解释：</strong>文件系统将会这样创建文件名：
&quot;gta&quot; --&gt; 之前未分配，仍为 &quot;gta&quot;
&quot;gta(1)&quot; --&gt; 之前未分配，仍为 &quot;gta(1)&quot;
&quot;gta&quot; --&gt; 文件名被占用，系统为该名称添加后缀 (k)，由于 &quot;gta(1)&quot; 也被占用，所以 k = 2 。实际创建的文件名为 &quot;gta(2)&quot; 。
&quot;avalon&quot; --&gt; 之前未分配，仍为 &quot;avalon&quot;
</pre>

<p><strong>示例 3：</strong></p>

<pre><strong>输入：</strong>names = [&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece&quot;]
<strong>输出：</strong>[&quot;onepiece&quot;,&quot;onepiece(1)&quot;,&quot;onepiece(2)&quot;,&quot;onepiece(3)&quot;,&quot;onepiece(4)&quot;]
<strong>解释：</strong>当创建最后一个文件夹时，最小的正有效 k 为 4 ，文件名变为 &quot;onepiece(4)&quot;。
</pre>

<p><strong>示例 4：</strong></p>

<pre><strong>输入：</strong>names = [&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;,&quot;wano&quot;]
<strong>输出：</strong>[&quot;wano&quot;,&quot;wano(1)&quot;,&quot;wano(2)&quot;,&quot;wano(3)&quot;]
<strong>解释：</strong>每次创建文件夹 &quot;wano&quot; 时，只需增加后缀中 k 的值即可。</pre>

<p><strong>示例 5：</strong></p>

<pre><strong>输入：</strong>names = [&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido&quot;,&quot;kaido(1)&quot;]
<strong>输出：</strong>[&quot;kaido&quot;,&quot;kaido(1)&quot;,&quot;kaido(2)&quot;,&quot;kaido(1)(1)&quot;]
<strong>解释：</strong>注意，如果含后缀文件名被占用，那么系统也会按规则在名称后添加新的后缀 (k) 。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= names.length &lt;= 5 * 10^4</code></li>
	<li><code>1 &lt;= names[i].length &lt;= 20</code></li>
	<li><code>names[i]</code> 由小写英文字母、数字和/或圆括号组成。</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 75 ms</p>
                    <p>内存: 30.4 MB</p>
                    <pre class="bg-light p-2 code-pre">from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 用于跟踪已经使用过的文件名及其后缀版本的数量
        result = []
        
        for name in names:
            if name not in used_names or used_names[name] == 0:
                # 如果文件名尚未使用，或者其原始版本（没有后缀）尚未使用，则直接使用它
                result.append(name)
                used_names[name] += 1  # 增加该名称的使用计数
            else:
                # 如果文件名已经被使用，我们需要找到一个未被使用的后缀版本
                k = used_names[name]
                while True:
                    new_name = f&#34;{name}({k})&#34;
                    if new_name not in used_names:
                        result.append(new_name)
                        used_names[name] += 1  # 增加原始名称的使用计数（为下一个可能的重复做准备）
                        used_names[new_name] = 1  # 标记这个新的后缀版本为已使用
                        break
                    k += 1
                    
        return result

from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        def get_unique_name(name, count):
            if count == 0:
                return name
            return get_unique_name(f&#34;{name}({count})&#34;, count - 1)

        used_names = defaultdict(int)  # 字典用于跟踪已使用的名称及其“下一个可用后缀”的计数
        result = []
        
        for name in names:
            if name not in used_names:
                # 如果名称尚未使用，将其添加到结果中并设置计数为1（表示下一个重复需要后缀）
                result.append(name)
                used_names[name] = 1
            else:
                # 如果名称已使用，获取其“下一个可用后缀”的计数，并使用辅助函数生成唯一的名称
                count = used_names[name]
                unique_name = get_unique_name(name, count)
                result.append(unique_name)
                used_names[name] = count + 1  # 更新下一个重复需要的后缀计数
                used_names[unique_name] = 0  # 标记这个新的唯一名称为“尚未使用”，但实际上我们不会再次使用它，这只是一个占位符。
                
        return result

from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 字典用于跟踪已使用的名称及其后缀计数
        result = []
        
        for name in names:
            if not used_names[name]:
                # 如果名称尚未使用，将其添加到结果中并设置计数为1
                result.append(name)
                used_names[name] = 1
            else:
                # 如果名称已使用，增加后缀计数直到找到一个未使用的名称
                count = used_names[name]
                while True:
                    new_name = f&#34;{name}({count})&#34;
                    if new_name not in used_names or used_names[new_name] == 0:
                        result.append(new_name)
                        used_names[name] = count + 1  # 更新原始名称的后缀计数
                        used_names[new_name] = 1  # 标记新名称为已使用（对于可能的进一步重复）
                        break
                    count += 1
                    
        return result
</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>此题解使用一个哈希表（defaultdict）来跟踪每个文件名以及其后缀形式的使用情况。对于每个输入的文件名，如果它尚未被使用过，直接使用它并在哈希表中做标记。如果已被使用，则通过循环增加后缀的编号，生成一个新的唯一文件名。使用格式&#39;name(k)&#39;，其中k是最小未被使用的正整数，确保文件名的唯一性。通过不断检查新生成的文件名是否被占用，直到找到一个未被使用的为止。</p>
                                <p>时间复杂度: O(n) 在平均情况下; O(n*k) 在最坏情况下，其中k是某个文件名的最大重复次数</p>
                                <p>空间复杂度: O(n)</p>
                                <pre class="bg-light p-2">from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 记录每个文件名及其后缀的使用次数
        result = []
        
        for name in names:
            if used_names[name] == 0:
                # 如果文件名未使用，直接添加到结果中
                result.append(name)
                used_names[name] += 1  # 标记为已使用
            else:
                # 文件名已使用，寻找新的未使用后缀
                count = used_names[name]
                while True:
                    new_name = f&#34;{name}({count})&#34;
                    if used_names[new_name] == 0:
                        result.append(new_name)
                        used_names[new_name] = 1  # 标记新名称为已使用
                        used_names[name] = count + 1  # 更新原名称后缀计数
                        break
                    count += 1
        
        return result</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在哈希表中，您是如何处理文件名和后缀形式的映射关系？是否存在一种情况下，可能会误将原始文件名和修改后的文件名视为不同的两个键？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在此题解中，每个文件名（无论是原始的还是带后缀的）都作为哈希表的键。例如，&#39;file&#39;和&#39;file(1)&#39;在哈希表中是不同的键。这种设计可以避免将原始文件名和修改后的文件名混淆。因此不存在将它们视为同一个键的情况。当检查一个新文件名是否已使用时，会分别检查其作为原始名称和作为修改后名称的情况。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            代码中使用了defaultdict(int)，具体是如何初始化每个文件名的计数的？例如，当一个全新的文件名首次出现时，其值是如何被设置的？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>在Python中，使用`defaultdict`时可以通过传递一个类型（如`int`），默认将每个新键的值初始化为该类型的默认值。对于`int`类型，其默认值是`0`。因此，在`used_names`哈希表中，当首次引用一个文件名时，如果它之前未出现过，其计数自动初始化为`0`。这便于检查一个文件名是否首次使用，并在首次使用时将其计数设为`1`。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            题解中未详细解释如何处理输入中已存在形如&#39;name(k)&#39;的文件名。如果输入中包含&#39;pes(1)&#39;，而后又出现&#39;pes&#39;，处理逻辑会有何不同？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>题解中的逻辑首先会将&#39;pes(1)&#39;作为一个独立的文件名处理并存储，此时&#39;pes(1)&#39;在哈希表中计数为1。当后续出现&#39;pes&#39;时，代码会检查&#39;pes&#39;是否已使用。如果&#39;pes&#39;未被使用，则直接添加&#39;pes&#39;并将其计数设为1。如果&#39;pes&#39;已使用，代码会尝试生成新的文件名，如&#39;pes(1)&#39;，&#39;pes(2)&#39;等。在这个例子中，由于&#39;pes(1)&#39;已经存在，代码会检测到这一点并尝试更高的后缀，比如&#39;pes(2)&#39;。这种处理确保了即使输入中包含形如&#39;name(k)&#39;的文件名，生成的文件名依然是唯一的。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/making-file-names-unique')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/making-file-names-unique/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>