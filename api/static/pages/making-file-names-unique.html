<!DOCTYPE html>
<html lang="zh">
<head>
    <title>保证文件名唯一</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">保证文件名唯一</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 用于跟踪已经使用过的文件名及其后缀版本的数量
        result = []
        
        for name in names:
            if name not in used_names or used_names[name] == 0:
                # 如果文件名尚未使用，或者其原始版本（没有后缀）尚未使用，则直接使用它
                result.append(name)
                used_names[name] += 1  # 增加该名称的使用计数
            else:
                # 如果文件名已经被使用，我们需要找到一个未被使用的后缀版本
                k = used_names[name]
                while True:
                    new_name = f&#34;{name}({k})&#34;
                    if new_name not in used_names:
                        result.append(new_name)
                        used_names[name] += 1  # 增加原始名称的使用计数（为下一个可能的重复做准备）
                        used_names[new_name] = 1  # 标记这个新的后缀版本为已使用
                        break
                    k += 1
                    
        return result

from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        def get_unique_name(name, count):
            if count == 0:
                return name
            return get_unique_name(f&#34;{name}({count})&#34;, count - 1)

        used_names = defaultdict(int)  # 字典用于跟踪已使用的名称及其“下一个可用后缀”的计数
        result = []
        
        for name in names:
            if name not in used_names:
                # 如果名称尚未使用，将其添加到结果中并设置计数为1（表示下一个重复需要后缀）
                result.append(name)
                used_names[name] = 1
            else:
                # 如果名称已使用，获取其“下一个可用后缀”的计数，并使用辅助函数生成唯一的名称
                count = used_names[name]
                unique_name = get_unique_name(name, count)
                result.append(unique_name)
                used_names[name] = count + 1  # 更新下一个重复需要的后缀计数
                used_names[unique_name] = 0  # 标记这个新的唯一名称为“尚未使用”，但实际上我们不会再次使用它，这只是一个占位符。
                
        return result

from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 字典用于跟踪已使用的名称及其后缀计数
        result = []
        
        for name in names:
            if not used_names[name]:
                # 如果名称尚未使用，将其添加到结果中并设置计数为1
                result.append(name)
                used_names[name] = 1
            else:
                # 如果名称已使用，增加后缀计数直到找到一个未使用的名称
                count = used_names[name]
                while True:
                    new_name = f&#34;{name}({count})&#34;
                    if new_name not in used_names or used_names[new_name] == 0:
                        result.append(new_name)
                        used_names[name] = count + 1  # 更新原始名称的后缀计数
                        used_names[new_name] = 1  # 标记新名称为已使用（对于可能的进一步重复）
                        break
                    count += 1
                    
        return result
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 75 ms</p>
                    <p class="mb-0">内存: 30.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>此题解使用一个哈希表（defaultdict）来跟踪每个文件名以及其后缀形式的使用情况。对于每个输入的文件名，如果它尚未被使用过，直接使用它并在哈希表中做标记。如果已被使用，则通过循环增加后缀的编号，生成一个新的唯一文件名。使用格式&#39;name(k)&#39;，其中k是最小未被使用的正整数，确保文件名的唯一性。通过不断检查新生成的文件名是否被占用，直到找到一个未被使用的为止。</p>
                        <p>时间复杂度: O(n) 在平均情况下; O(n*k) 在最坏情况下，其中k是某个文件名的最大重复次数</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from collections import defaultdict
from typing import List

class Solution:
    def getFolderNames(self, names: List[str]) -&gt; List[str]:
        used_names = defaultdict(int)  # 记录每个文件名及其后缀的使用次数
        result = []
        
        for name in names:
            if used_names[name] == 0:
                # 如果文件名未使用，直接添加到结果中
                result.append(name)
                used_names[name] += 1  # 标记为已使用
            else:
                # 文件名已使用，寻找新的未使用后缀
                count = used_names[name]
                while True:
                    new_name = f&#34;{name}({count})&#34;
                    if used_names[new_name] == 0:
                        result.append(new_name)
                        used_names[new_name] = 1  # 标记新名称为已使用
                        used_names[name] = count + 1  # 更新原名称后缀计数
                        break
                    count += 1
        
        return result</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>