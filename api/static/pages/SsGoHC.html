<!DOCTYPE html>
<html lang="zh">
<head>
    <title>合并区间</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">合并区间</strong>
                标签:
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        # 先将区间按照其左端点排序
        n = len(intervals)
        if n==1: return intervals
        intervals.sort(key=lambda x:x[0])
        ans = []
        begin, end = intervals[0]
        for i in range(1,n):
            a,b = intervals[i]
            if a&lt;=end:
                if b&gt;end: end = b
            else: # a&gt;end
                ans.append([begin, end])
                begin, end = a, b
        # 把最后一组 begin,end 加到答案中
        ans.append([begin, end])
        return ans</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 26 ms</p>
                    <p class="mb-0">内存: 17.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>The solution involves sorting the list of intervals based on the start time of each interval to ensure that any potentially overlapping intervals are next to each other. After sorting, the algorithm initializes the first interval as the current range to merge other intervals into. For each subsequent interval, it checks if there is an overlap with the current range (i.e., the start of the next interval is less than or equal to the end of the current interval). If they overlap, the end of the current merged interval is updated if necessary. If there is no overlap, the current merged interval is complete and added to the results list, and a new current interval is started with the non-overlapping interval. This process is repeated for all intervals. Finally, the last merged interval is added to the results list.</p>
                        <p>时间复杂度: O(n log n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def merge(self, intervals: List[List[int]]) -&gt; List[List[int]]:
        # Check if there&#39;s only one interval, return it directly
        n = len(intervals)
        if n == 1: return intervals
        # Sort intervals based on the start of each interval
        intervals.sort(key=lambda x: x[0])
        ans = []
        begin, end = intervals[0]
        # Iterate through each interval to merge
        for i in range(1, n):
            a, b = intervals[i]
            if a &lt;= end:
                # There is an overlap, so merge the intervals
                if b &gt; end: end = b
            else:
                # No overlap, add the current interval to the answer
                ans.append([begin, end])
                begin, end = a, b
        # Add the last processed interval to the list
        ans.append([begin, end])
        return ans</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>