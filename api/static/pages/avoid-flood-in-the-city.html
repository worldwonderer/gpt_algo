<!DOCTYPE html>
<html lang="zh">
<head>
    <title>避免洪水泛滥</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">避免洪水泛滥</strong>
                标签:
                
                    <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=binary-search" class="badge bg-secondary tag-link">二分查找</a>
                
                    <a href="/problems?tag=heap-priority-queue" class="badge bg-secondary tag-link">堆（优先队列）</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def avoidFlood(self, rains: List[int]) -&gt; List[int]:
        # counter=Counter(rains)
        # pool_cnt=len(counter)-1
        # tot_days=len(rains)
        # no_rain_days=counter[0]
        # rain_days=tot_days-no_rain_days
        # if rain_days-pool_cnt&gt;no_rain_days:
        #     return []
        
        full_pools={}
        can_removed=deque()
        ret=[-1]*len(rains)

        for i,p in enumerate(rains):
            if p==0:
                if len(full_pools)==0:
                    ret[i]=1
                elif len(full_pools)==1:
                    k,_=full_pools.popitem()
                    ret[i]=k
                    continue
                can_removed.append([i,True])
                continue
            if p in full_pools:
                while can_removed and can_removed[0][1]==False:
                    can_removed.popleft()
                for entry in can_removed:
                    if entry[1]==False:
                        continue
                    if entry[0]&gt;full_pools[p]:                        
                        ret[entry[0]]=p
                        entry[1]=False
                        break
                else:
                    return []
            full_pools[p]=i
        for idx,flag in can_removed:
            if not flag:
                continue
            ret[idx]=1
        return ret
            
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 113 ms</p>
                    <p class="mb-0">内存: 32.4 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>此题解的核心思路是使用散列表（字典）来跟踪当前哪些湖泊已经满了，以及它们最后一次被填满的时间。此外，使用一个双端队列（deque）来记录可以抽水的日子，并在需要时找到最近的、合适的日子来抽水，以避免洪水。遍历输入数组，对于每一天：1) 如果是晴天（rains[i] == 0），记录这一天可以抽水；2) 如果是下雨天（rains[i] &gt; 0），检查该湖泊是否已经满了。如果已满，则需要在之前记录的可以抽水的日子中找到一个合适的日子来抽水；如果找不到合适的日子，直接返回空数组。如果湖泊未满，则标记为已满，并记录其下雨的时间。最后，对于所有未使用的晴天，可以随意抽干任何湖泊（避免特殊情况，通常抽干湖泊1）。</p>
                        <p>时间复杂度: O(n)</p>
                        <p>空间复杂度: O(n)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Solution:
    def avoidFlood(self, rains: List[int]) -&gt; List[int]:
        full_pools = {}  # 记录湖泊填满的状态和最近一次下雨的天数
        can_removed = deque()  # 可以抽水的日子列表
        ret = [-1] * len(rains)  # 初始化返回数组，下雨天为-1

        for i, p in enumerate(rains):
            if p == 0:  # 晴天，记录可以抽水
                can_removed.append([i, True])
                continue
            if p in full_pools:  # 如果湖泊已满，需要抽水
                while can_removed and can_removed[0][1] == False:  # 移除无效的抽水日子
                    can_removed.popleft()
                for entry in can_removed:  # 在有效的抽水日子中找到合适的一天
                    if entry[1] == False:  # 已经使用过的抽水日子
                        continue
                    if entry[0] &gt; full_pools[p]:  # 找到了合适的抽水日子
                        ret[entry[0]] = p
                        entry[1] = False  # 标记为已使用
                        break
                else:  # 如果没有找到可用的抽水日子，返回空数组
                    return []
            full_pools[p] = i  # 标记湖泊为已满
        for idx, flag in can_removed:  # 处理剩余的未使用的晴天
            if not flag:
                continue
            ret[idx] = 1  # 默认抽干湖泊1
        return ret</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>