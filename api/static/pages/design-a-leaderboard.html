<!DOCTYPE html>
<html lang="zh">
<head>
    <title>力扣排行榜</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">力扣排行榜</strong>
                标签:
                
                    <a href="/problems?tag=design" class="badge bg-secondary tag-link">设计</a>
                
                    <a href="/problems?tag=hash-table" class="badge bg-secondary tag-link">哈希表</a>
                
                    <a href="/problems?tag=sorting" class="badge bg-secondary tag-link">排序</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Medium</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedDict


class Leaderboard:

    def __init__(self):
        self.scores = {}
        self.sortedScores = SortedDict()

    def addScore(self, playerId: int, score: int) -&gt; None:

        # 分数字典只包含从 playerID 到它们的分数的映射。
        # sortedScores 包含一个 BST，
        # 其中 key 作为比分，value 作为拥有该比分的球员的数量。

        if playerId not in self.scores:
            self.scores[playerId] = score
            self.sortedScores[-score] = self.sortedScores.get(-score, 0) + 1
        else:
            preScore = self.scores[playerId]
            val = self.sortedScores.get(-preScore) # 只有一个
            if val == 1:
                del self.sortedScores[-preScore]
            else:
                self.sortedScores[-preScore] = val - 1

            newScore = preScore + score
            self.scores[playerId] = newScore
            self.sortedScores[-newScore] = self.sortedScores.get(-newScore, 0) + 1

    def top(self, K: int) -&gt; int:
        count, total = 0, 0

        for key, value in self.sortedScores.items():
            times = self.sortedScores.get(key)
            for _ in range(times):
                total += -key
                count += 1

                # 找到 top-K分数，break。
                if count == K:
                    break

            # 找到 top-K分数，break。
            if count == K:
                break

        return total

    def reset(self, playerId: int) -&gt; None:
        preScore = self.scores[playerId]
        if self.sortedScores[-preScore] == 1:
            del self.sortedScores[-preScore]
        else:
            self.sortedScores[-preScore] -= 1
        del self.scores[playerId]


# class Leaderboard:

#     def __init__(self):
#         self.dic = set([])
#         self.deq = []

#     def addScore(self, playerId: int, score: int) -&gt; None:
#         if playerId not in self.dic:
#             self.dic.add(playerId)
#             if not self.deq:
#                 self.deq.insert(0, (score, playerId))
#             if self.deq[-1][0] &gt; score:
#                 self.deq.append((score, playerId))
#             for idx, i in enumerate(self.deq):
#                 if i[0] &lt; score:
#                     self.deq.insert(idx, (score, playerId))
#                     break

#         else:
#             for idx, i in enumerate(self.deq):
#                 if i[1] == playerId:
#                     score += i[0]
#                     tmp = idx
#                     while tmp &gt; 0 and score &gt; self.deq[tmp][0]:
#                         self.deq[tmp] = self.deq[tmp - 1]
#                         tmp -= 1
#                     self.deq[tmp] = (score, playerId)
#                     break

#     def top(self, K: int) -&gt; int:
#         return sum([self.deq[i][0] for i in range(min(K, len(self.deq)))])

#     def reset(self, playerId: int) -&gt; None:
#         self.dic.remove(playerId)
#         for idx, i in enumerate(self.deq):
#             if i[1] == playerId:
#                 self.deq.pop(idx)
#                 break


# Your Leaderboard object will be instantiated and called as such:
# obj = Leaderboard()
# obj.addScore(playerId,score)
# param_2 = obj.top(K)
# obj.reset(playerId)
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 42 ms</p>
                    <p class="mb-0">内存: 16.9 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>这个题解利用了Python的SortedDict来维护一个有序的字典，其中键表示分数（以负数形式存储以保持最大的分数在前），值表示该分数对应的玩家数量。这允许快速增加分数、重置分数和计算前K高分的总和。具体操作如下：
1. 在增加分数时，首先检查玩家是否已存在。如果不存在，直接添加；如果存在，更新分数，并调整SortedDict中的统计。
2. 计算前K高分的总和时，从SortedDict开始累加最高的分数，直到达到K个。
3. 重置玩家分数时，将该玩家的分数从SortedDict中减去，并从scores字典中删除玩家。</p>
                        <p>时间复杂度: O(log n) for addScore and reset, O(K) for top</p>
                        <p>空间复杂度: O(p)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">from sortedcontainers import SortedDict

class Leaderboard:

    def __init__(self):
        self.scores = {}  # 玩家ID映射到分数
        self.sortedScores = SortedDict()  # 存储分数和相应的玩家数量

    def addScore(self, playerId: int, score: int) -&gt; None:
        if playerId not in self.scores:
            self.scores[playerId] = score
            self.sortedScores[-score] = self.sortedScores.get(-score, 0) + 1
        else:
            preScore = self.scores[playerId]
            if self.sortedScores[-preScore] == 1:
                del self.sortedScores[-preScore]
            else:
                self.sortedScores[-preScore] -= 1
            newScore = preScore + score
            self.scores[playerId] = newScore
            self.sortedScores[-newScore] = self.sortedScores.get(-newScore, 0) + 1

    def top(self, K: int) -&gt; int:
        count, total = 0, 0
        for key, value in self.sortedScores.items():
            times = value
            for _ in range(times):
                total += -key
                count += 1
                if count == K:
                    break
            if count == K:
                break
        return total

    def reset(self, playerId: int) -&gt; None:
        preScore = self.scores[playerId]
        if self.sortedScores[-preScore] == 1:
            del self.sortedScores[-preScore]
        else:
            self.sortedScores[-preScore] -= 1
        del self.scores[playerId]</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>