<!DOCTYPE html>
<html lang="zh">
<head>
    <title>与数组中元素的最大异或值</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="/static/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/detail.css">
    <link rel="stylesheet" href="/static/css/github.css">
    <style>
        body {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        .container-fluid {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        main {
            flex-grow: 1;
        }
        .code-pre {
             white-space: pre-wrap;
             word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div class="container-fluid mt-3">
        <header class="d-flex flex-column flex-md-row justify-content-md-between align-items-md-center mb-3">
            <a href="/problems" class="btn btn-secondary mb-2 mb-md-0">返回题目列表</a>
            <div class="text-md-end">
                <strong class="me-md-3 d-block d-md-inline mb-2 mb-md-0">与数组中元素的最大异或值</strong>
                标签:
                
                    <a href="/problems?tag=bit-manipulation" class="badge bg-secondary tag-link">位运算</a>
                
                    <a href="/problems?tag=trie" class="badge bg-secondary tag-link">字典树</a>
                
                    <a href="/problems?tag=array" class="badge bg-secondary tag-link">数组</a>
                
                &nbsp;&nbsp;
                难度: <span class="badge bg-secondary">Hard</span>
            </div>
        </header>

        <main>
            <section class="mb-4">
                <h2>Submission</h2>
                <div class="code-block">
                    <pre class="bg-light p-2 code-pre"><code class="language-python">class Trie:
    L = 30

    def __init__(self):
        self.left = None
        self.right = None

    def insert(self, val: int):
        node = self
        for i in range(Trie.L, -1, -1):
            bit = (val &gt;&gt; i) &amp; 1
            if bit == 0:
                if not node.left:
                    node.left = Trie()
                node = node.left
            else:
                if not node.right:
                    node.right = Trie()
                node = node.right
    
    def getMaxXor(self, val: int) -&gt; int:
        ans, node = 0, self
        for i in range(Trie.L, -1, -1):
            bit = (val &gt;&gt; i) &amp; 1
            check = False
            if bit == 0:
                if node.right:
                    node = node.right
                    check = True
                else:
                    node = node.left
            else:
                if node.left:
                    node = node.left
                    check = True
                else:
                    node = node.right
            if check:
                ans |= 1 &lt;&lt; i
        return ans


class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -&gt; List[int]:
        n, q = len(nums), len(queries)
        nums.sort()
        queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda query: query[1])
        
        ans = [0] * q
        t = Trie()
        idx = 0
        for x, m, qid in queries:
            while idx &lt; n and nums[idx] &lt;= m:
                t.insert(nums[idx])
                idx += 1
            if idx == 0:
                # 字典树为空
                ans[qid] = -1
            else:
                ans[qid] = t.getMaxXor(x)
        
        return ans


#-------------------------------
# class Trie:
#     def __init__(self):
#         self.num = [None,None]

#     def insert(self,nums):
#         node = self
#         for i in range(30,-1,-1):
#             n = nums&gt;&gt;i &amp; 1
#             if not node.num[n]:
#                 node.num[n] = Trie()
#             node = node.num[n]

#     def search(self,nums):
#         node = self
#         ans = 0
#         for i in range(30,-1,-1):
#             ans |= 1&lt;&lt;i
#             cur = nums&gt;&gt;i &amp; 1
#             if not node.num[1^cur]:
#                 node = node.num[cur]
#                 ans ^= 1&lt;&lt;i
#             else:
#                 node = node.num[1^cur]
#         return ans

# class Solution:
#     def maximizeXor(self, nums: List[int], queries: List[List[int]]) -&gt; List[int]:
#         n,q = len(nums),len(queries)
#         ans = [-1] * q
#         nums.sort()
#         target = sorted([(x,m,i) for i,(x,m) in enumerate(queries)],key = lambda x:x[1])
#         tree = Trie()
#         for x,m,i in target:
#             idx = 0
#             while idx&lt;n and nums[idx]&lt;=m:
#                 tree.insert(nums[idx])
#                 idx += 1
#             if idx&gt;0:
#                 ans[i] = tree.search(x)
#         return ans
</code></pre>
                    <button class="btn btn-sm btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                    <p class="mt-2 mb-0">运行时间: 2613 ms</p>
                    <p class="mb-0">内存: 162.6 MB</p>
                </div>
            </section>

            
                <section>
                    <h2>Explain</h2>
                    <div>
                        <p>本题解的核心是使用字典树（Trie）针对整数进行位操作的优化存储。首先，将数组nums排序并对查询数组queries按m值排序以方便处理。对于每个查询（xi, mi），我们将nums中所有不大于mi的元素插入到Trie中。之后，我们使用Trie树的getMaxXor函数来找到与xi进行XOR操作可以获得的最大值。如果没有任何元素被插入到Trie中（即所有nums元素均大于mi），则返回-1。</p>
                        <p>时间复杂度: O((n + q) * L)</p>
                        <p>空间复杂度: O(nL)</p>
                        
                             <pre class="bg-light p-2 code-pre"><code class="language-python">class Trie:
    L = 30  # 最多30位二进制数字

    def __init__(self):
        self.left = None  # 左子树表示0
        self.right = None  # 右子树表示1

    def insert(self, val: int):
        node = self
        for i in range(Trie.L, -1, -1):  # 从高位到低位处理
            bit = (val &gt;&gt; i) &amp; 1  # 获取当前位的值
            if bit == 0:
                if not node.left:
                    node.left = Trie()  # 如果左节点不存在，则创建
                node = node.left
            else:
                if not node.right:
                    node.right = Trie()  # 如果右节点不存在，则创建
                node = node.right

    def getMaxXor(self, val: int) -&gt; int:
        ans, node = 0, self
        for i in range(Trie.L, -1, -1):
            bit = (val &gt;&gt; i) &amp; 1
            check = False
            if bit == 0:
                if node.right:
                    node = node.right
                    check = True
                else:
                    node = node.left
            else:
                if node.left:
                    node = node.left
                    check = True
                else:
                    node = node.right
            if check:
                ans |= 1 &lt;&lt; i  # 如果对应位能够匹配到期望的异或结果，设置结果位
        return ans

class Solution:
    def maximizeXor(self, nums: List[int], queries: List[List[int]]) -&gt; List[int]:
        n, q = len(nums), len(queries)
        nums.sort()  # 排序nums
        queries = sorted([(x, m, i) for i, (x, m) in enumerate(queries)], key=lambda query: query[1])  # 按mi排序查询
        ans = [0] * q
        t = Trie()
        idx = 0
        for x, m, qid in queries:  # 处理每一个查询
            while idx &lt; n and nums[idx] &lt;= m:
                t.insert(nums[idx])  # 插入符合条件的nums元素
                idx += 1
            if idx == 0:
                ans[qid] = -1  # 如果没有可用元素，返回-1
            else:
                ans[qid] = t.getMaxXor(x)  # 计算最大XOR值
        return ans</code></pre>
                        
                    </div>
                </section>
            
        </main>
    </div>
    <script src="/static/js/jquery.min.js"></script>
    <script src="/static/js/bootstrap.bundle.min.js"></script>
    <script src="/static/js/highlight.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
            hljs.highlightAll();
        });

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>