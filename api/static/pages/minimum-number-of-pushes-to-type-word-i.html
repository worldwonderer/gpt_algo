<!DOCTYPE html>
<html lang="zh">
<head>
    <title>输入单词需要的最少按键次数 I</title>
    <link rel="shortcut icon" href="/static/favicon.ico">
    <link href="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.15.4/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/static/detail.css">
</head>
<body>
    <div class="container mt-3">
        <header class="problem-header">
            <h1>输入单词需要的最少按键次数 I</h1>
        </header>
        <main>
            <article class="problem-content">
                <p>标签:
                    
                        <a href="/problems?tag=greedy" class="badge bg-secondary tag-link">贪心</a>
                    
                        <a href="/problems?tag=math" class="badge bg-secondary tag-link">数学</a>
                    
                        <a href="/problems?tag=string" class="badge bg-secondary tag-link">字符串</a>
                    
                </p>
                <p>难度: <span class="badge bg-secondary">Easy</span></p>
                
                    <div class="problem-description">
                        <p>给你一个字符串 <code>word</code>，由 <strong>不同 </strong>小写英文字母组成。</p>

<p>电话键盘上的按键与 <strong>不同 </strong>小写英文字母集合相映射，可以通过按压按键来组成单词。例如，按键 <code>2</code> 对应 <code>["a","b","c"]</code>，我们需要按一次键来输入 <code>"a"</code>，按两次键来输入 <code>"b"</code>，按三次键来输入 <code>"c"</code><em>。</em></p>

<p>现在允许你将编号为 <code>2</code> 到 <code>9</code> 的按键重新映射到 <strong>不同 </strong>字母集合。每个按键可以映射到<strong> 任意数量 </strong>的字母，但每个字母 <strong>必须</strong> <strong>恰好</strong> 映射到 <strong>一个 </strong>按键上。你需要找到输入字符串 <code>word</code> 所需的<strong> 最少 </strong>按键次数。</p>

<p>返回重新映射按键后输入 <code>word</code> 所需的 <strong>最少 </strong>按键次数。</p>

<p>下面给出了一种电话键盘上字母到按键的映射作为示例。注意 <code>1</code>，<code>*</code>，<code>#</code> 和 <code>0</code> <strong>不</strong> 对应任何字母。</p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/26/keypaddesc.png" style="width: 329px; height: 313px;" />


<p><strong class="example">示例 1：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/26/keypadv1e1.png" style="width: 329px; height: 313px;" />
<pre>
<strong>输入：</strong>word = "abcde"
<strong>输出：</strong>5
<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。
"a" -&gt; 在按键 2 上按一次
"b" -&gt; 在按键 3 上按一次
"c" -&gt; 在按键 4 上按一次
"d" -&gt; 在按键 5 上按一次
"e" -&gt; 在按键 6 上按一次
总成本为 1 + 1 + 1 + 1 + 1 = 5 。
可以证明不存在其他成本更低的映射方案。
</pre>

<p><strong class="example">示例 2：</strong></p>
<img alt="" src="https://assets.leetcode.com/uploads/2023/12/26/keypadv1e2.png" style="width: 329px; height: 313px;" />
<pre>
<strong>输入：</strong>word = "xycdefghij"
<strong>输出：</strong>12
<strong>解释：</strong>图片中给出的重新映射方案的输入成本最小。
"x" -&gt; 在按键 2 上按一次
"y" -&gt; 在按键 2 上按两次
"c" -&gt; 在按键 3 上按一次
"d" -&gt; 在按键 3 上按两次
"e" -&gt; 在按键 4 上按一次
"f" -&gt; 在按键 5 上按一次
"g" -&gt; 在按键 6 上按一次
"h" -&gt; 在按键 7 上按一次
"i" -&gt; 在按键 8 上按一次
"j" -&gt; 在按键 9 上按一次
总成本为 1 + 2 + 1 + 2 + 1 + 1 + 1 + 1 + 1 + 1 = 12 。
可以证明不存在其他成本更低的映射方案。
</pre>



<p><strong>提示：</strong></p>

<ul>
	<li><code>1 &lt;= word.length &lt;= 26</code></li>
	<li><code>word</code> 仅由小写英文字母组成。</li>
	<li><code>word</code> 中的所有字母互不相同。</li>
</ul>

                    </div>
                
            </article>

            <section>
                <h2>Submission</h2>
                <div class="code-block">
                    <p>运行时间: 19 ms</p>
                    <p>内存: 15.9 MB</p>
                    <pre class="bg-light p-2 code-pre">class Solution:
    def minimumPushes(self, word: str) -&gt; int:
        nums={}
        for w in word:
            nums.setdefault(w,0)
            nums[w]+=1
        nums=nums.values()
        # print(nums)
        nums=sorted(nums,reverse=True)
        ans=0
        for i in range(0,len(nums)):
            ans+=nums[i]*i//8+1
        return ans</pre>
                    <button class="btn btn-secondary copy-btn" onclick="copyCode(this)">复制代码</button>
                </div>
            </section>

            <section class="vote-buttons">
                <button id="like-button" class="btn btn-outline-success"><i class="fas fa-thumbs-up"></i><span id="like-count" class="vote-count">0</span></button>
                <button id="dislike-button" class="btn btn-outline-danger"><i class="fas fa-thumbs-down"></i><span id="dislike-count" class="vote-count">0</span></button>
            </section>

            
                <section class="explain-section">
                    <h2>Explain</h2>
                    <div class="card">
                        <div class="card-header" id="explainHeader">
                            <span class="mb-0">
                                <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#explainCollapse" aria-expanded="false" aria-controls="explainCollapse">
                                     <i class="fas fa-chevron-down float-end"></i>
                                </button>
                            </span>
                        </div>
                        <div id="explainCollapse" class="collapse" aria-labelledby="explainHeader">
                            <div class="card-body">
                                <p>该题目的核心思想是重新映射电话键盘上的按键到字母，以使得输入给定的单词所需的按键次数最小。解题步骤如下：

1. 统计单词中每个字母的出现频率。
2. 将频率按从高到低排序，因为频率高的字母应尽可能放在按键次数少的位置上。
3. 计算按键次数：由于题目没有明确按键上字母的数量限制，理论上可以假设每个按键上可以放无限多的字母。但由于每个按键的按键次数是有限的，我们需要将出现次数高的字母尽量分配给按键次数少的位置（例如，按键&#39;2&#39;上的第一个位置）。为了达到这个目的，对于每个字母，按其在排序后的位置计算需要的按键次数，即位置除以8（因为一个按键最多有8个位置）加1。

这种方法利用了贪心的策略，即优先考虑频率高的字母，以减少总的按键次数。</p>
                                <p>时间复杂度: O(n)</p>
                                <p>空间复杂度: O(1)</p>
                                <pre class="bg-light p-2">class Solution:
    def minimumPushes(self, word: str) -&gt; int:
        # 统计每个字母的出现次数
        nums = {}
        for w in word:
            nums.setdefault(w, 0)
            nums[w] += 1
        # 获取频率列表并按降序排序
        nums = sorted(nums.values(), reverse=True)
        ans = 0
        # 计算每个字母需要的按键次数
        for i in range(len(nums)):
            ans += (nums[i] * (i // 8) + 1)
        return ans</pre>
                            </div>
                        </div>
                    </div>
                </section>
            

            
                <section class="explore-section">
                    <h2>Explore</h2>
                    <div class="accordion" id="exploreAccordion">
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader1">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse1" aria-expanded="false" aria-controls="exploreCollapse1">
                                            在算法中，为何选择先对字母按出现频率进行降序排序？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse1" class="collapse" aria-labelledby="exploreHeader1" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>选择按字母的出现频率进行降序排序是因为我们希望频率高的字母能够尽可能使用较少的按键次数输入，即将频率最高的字母映射到按键次数最少的位置。这种方法基于贪心算法的原理，通过优化每一步的选择来尽量减少总的按键次数，从而达到整体的最优解。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader2">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse2" aria-expanded="false" aria-controls="exploreCollapse2">
                                            解题思路中提到的按键次数计算公式 `(i // 8 + 1)` 是如何得出的，这里的8代表什么？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse2" class="collapse" aria-labelledby="exploreHeader2" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>公式 `(i // 8 + 1)` 用于计算每个字母所需的按键次数。这里的数字 `8` 代表的是一个假定情况，即每个按键最多可以映射8个不同的字母。因此，`i // 8` 计算的是字母在排序后的列表中属于哪一个按键（每8个字母一个周期），而 `+1` 是因为按键次数从1开始计数。这是一种简化的假设，实际上可以根据具体情况调整这个数字，以适应不同的按键和字母映射策略。</p>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="card">
                                <div class="card-header" id="exploreHeader3">
                                    <span class="mb-0">
                                        <button class="btn btn-link btn-block text-start collapsed" type="button" data-bs-toggle="collapse" data-bs-target="#exploreCollapse3" aria-expanded="false" aria-controls="exploreCollapse3">
                                            如果每个按键可以映射任意数量的字母，那么如何保证每个字母恰好映射到一个按键上？ <i class="fas fa-chevron-down float-end"></i>
                                        </button>
                                    </span>
                                </div>
                                <div id="exploreCollapse3" class="collapse" aria-labelledby="exploreHeader3" data-bs-parent="#exploreAccordion">
                                    <div class="card-body">
                                        <p>尽管每个按键可以映射任意数量的字母，但我们需要确保每个字母恰好映射到一个按键上以满足题目要求。这可以通过为每个字母分配一个唯一的按键来实现。在实际操作中，可以通过创建一个映射表，将每个字母映射到一个具体的按键编号上。这个过程需要确保每个字母都被映射一次，而没有一个字母被映射到多个按键或者一个按键映射多个相同的字母。</p>
                                    </div>
                                </div>
                            </div>
                        
                    </div>
                </section>
            

            
        </main>

        <footer class="mt-4 mb-3">
            <div class="d-flex justify-content-between">
                <a href="/problems" class="btn btn-secondary">返回题目列表</a>
            </div>
        </footer>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.1.0/js/bootstrap.bundle.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            fetchInitialCounts();
            setupEventListeners();
        });

        function fetchInitialCounts() {
            fetch('/api/vote_count/minimum-number-of-pushes-to-type-word-i')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('like-count').textContent = data.likes;
                    document.getElementById('dislike-count').textContent = data.dislikes;
                })
                .catch(error => console.error('Error loading initial counts:', error));
        }

        function setupEventListeners() {
            document.getElementById('like-button').addEventListener('click', function() {
                updateVoteCounts('like');
            });

            document.getElementById('dislike-button').addEventListener('click', function() {
                updateVoteCounts('dislike');
            });

            const copyButtons = document.querySelectorAll('.copy-btn');
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    copyCode(this);
                });
            });
        }

        function updateVoteCounts(voteType) {
            const baseUrl = "/api/vote/minimum-number-of-pushes-to-type-word-i/PLACEHOLDER";
            const url = baseUrl.replace('PLACEHOLDER', voteType);

            fetch(url, { method: 'POST' })
                .then(response => response.json())
                .then(data => {
                    if (data.likes !== undefined) {
                        document.getElementById('like-count').textContent = data.likes;
                    }
                    if (data.dislikes !== undefined) {
                        document.getElementById('dislike-count').textContent = data.dislikes;
                    }
                })
                .catch(error => console.error('Error updating counts:', error));
        }

        function copyCode(button) {
            const codeBlock = button.previousElementSibling;
            const code = codeBlock.textContent;
            navigator.clipboard.writeText(code).then(function() {
                button.textContent = '已复制';
                setTimeout(function() {
                    button.textContent = '复制代码';
                }, 2000);
            }, function(err) {
                console.error('无法复制代码: ', err);
            });
        }
    </script>
</body>
</html>